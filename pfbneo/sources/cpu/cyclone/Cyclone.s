
;@ Cyclone 68000 Emulator v0.099 - Assembler Output

;@ Copyright (c) 2004,2011 FinalDave (emudave (at) gmail.com)
;@ Copyright (c) 2005-2011 GraÅ¾vydas "notaz" Ignotas (notasas (at) gmail.com)

;@ This code is licensed under the GNU General Public License version 2.0 and the MAME License.
;@ You can choose the license that has the most advantages for you.

;@ SVN repository can be found at http://code.google.com/p/cyclone68000/

  .arm

  .text
  .align 4

  .global CycloneInit
  .type CycloneInit, %function
  .global CycloneReset
  .type CycloneReset, %function
  .global CycloneRun
  .type CycloneRun, %function
  .global CycloneSetSr
  .type CycloneSetSr, %function
  .global CycloneGetSr
  .type CycloneGetSr, %function
  .global CycloneFlushIrq
  .type CycloneFlushIrq, %function
  .global CyclonePack
  .type CyclonePack, %function
  .global CycloneUnpack
  .type CycloneUnpack, %function
  .global CycloneVer
  .type CycloneVer, %function

CycloneVer: .long 0x0099

;@ --------------------------- Framework --------------------------
CycloneRun:
  stmdb sp!,{r4-r8,r10,r11,lr}
  mov r7,r0          ;@ r7 = Pointer to Cpu Context
                     ;@ r0-3 = Temporary registers
  ldrb r10,[r7,#0x46]    ;@ r10 = Flags (NZCV)
  ldr r6,=CycloneJumpTab ;@ r6 = Opcode Jump table
  ldr r5,[r7,#0x5c]  ;@ r5 = Cycles
  ldr r4,[r7,#0x40]  ;@ r4 = Current PC + Memory Base
                     ;@ r8 = Current Opcode
  ldr r1,[r7,#0x44]  ;@ Get SR high T_S__III and irq level
  mov r10,r10,lsl #28;@ r10 = Flags 0xf0000000, cpsr format
                     ;@ r11 = Source value / Memory Base
  str r6,[r7,#0x54]  ;@ make a copy to avoid literal pools

  mov r2,#0
  str r2,[r7,#0x98]  ;@ clear custom CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  beq NoInts0
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  bgt CycloneDoInterrupt
NoInts0:

;@ Check if our processor is in special state
;@ and jump to opcode handler if not
  ldr r0,[r7,#0x58] ;@ state_flags
  ldrh r8,[r4],#2 ;@ Fetch first opcode
  tst r0,#0x03 ;@ special state?
  ldreq pc,[r6,r8,asl #2] ;@ Jump to opcode handler

CycloneSpecial:
  tst r0,#2 ;@ tracing?
  bne CycloneDoTrace
;@ stopped or halted
  mov r5,#0
  str r5,[r7,#0x5C]  ;@ eat all cycles
  ldmia sp!,{r4-r8,r10,r11,pc} ;@ we are stopped, do nothing!


;@ We come back here after execution
CycloneEnd:
  sub r4,r4,#2
CycloneEndNoBack:
  ldr r1,[r7,#0x98]
  mov r10,r10,lsr #28
  tst r1,r1
  bxne r1            ;@ jump to alternative CycloneEnd
  str r4,[r7,#0x40]  ;@ Save Current PC + Memory Base
  str r5,[r7,#0x5c]  ;@ Save Cycles
  strb r10,[r7,#0x46] ;@ Save Flags (NZCV)
  ldmia sp!,{r4-r8,r10,r11,pc}
  .ltorg


CycloneInit:
;@ decompress jump table
  ldr r12,=CycloneJumpTab
  add r0,r12,#0xe000*4 ;@ ctrl code pointer
  ldr r1,[r0,#-4]
  tst r1,r1
  movne pc,lr ;@ already uncompressed
  add r3,r12,#0xa000*4 ;@ handler table pointer, r12=dest
unc_loop:
  ldrh r1,[r0],#2
  and r2,r1,#0xf
  bic r1,r1,#0xf
  ldr r1,[r3,r1,lsr #2] ;@ r1=handler
  cmp r2,#0xf
  addeq r2,r2,#1 ;@ 0xf is really 0x10
  tst r2,r2
  ldreqh r2,[r0],#2 ;@ counter is in next word
  tst r2,r2
  beq unc_finish ;@ done decompressing
  tst r1,r1
  addeq r12,r12,r2,lsl #2 ;@ 0 handler means we should skip those bytes
  beq unc_loop
unc_loop_in:
  subs r2,r2,#1
  str r1,[r12],#4
  bgt unc_loop_in
  b unc_loop
unc_finish:
  ldr r12,=CycloneJumpTab
  ;@ set a-line and f-line handlers
  add r0,r12,#0xa000*4
  ldr r1,[r0,#4] ;@ a-line handler
  ldr r3,[r0,#8] ;@ f-line handler
  mov r2,#0x1000
unc_fill3:
  subs r2,r2,#1
  str r1,[r0],#4
  bgt unc_fill3
  add r0,r12,#0xf000*4
  mov r2,#0x1000
unc_fill4:
  subs r2,r2,#1
  str r3,[r0],#4
  bgt unc_fill4
  bx lr
  .ltorg

CycloneReset:
  stmfd sp!,{r7,lr}
  mov r7,r0
  mov r0,#0
  str r0,[r7,#0x58] ;@ state_flags
  str r0,[r7,#0x48] ;@ OSP
  mov r1,#0x27 ;@ Supervisor mode
  strb r1,[r7,#0x44] ;@ set SR high
  strb r0,[r7,#0x47] ;@ IRQ
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  str r0,[r7,#0x3c] ;@ Stack pointer
  mov r0,#0
  str r0,[r7,#0x60] ;@ Membase
  mov r0,#4
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  bl m68k_checkpc ;@ Call checkpc()
  str r0,[r7,#0x40] ;@ PC + base
  ldmfd sp!,{r7,pc}

CycloneSetSr:
  mov r2,r1,lsr #8
  and r2,r2,#0xa7 ;@ only defined bits
  strb r2,[r0,#0x44] ;@ set SR high
  mov r2,r1,lsl #25
  str r2,[r0,#0x4c] ;@ the X flag
  bic r2,r1,#0xf3
  tst r1,#1
  orrne r2,r2,#2
  tst r1,#2
  orrne r2,r2,#1
  strb r2,[r0,#0x46] ;@ flags
  bx lr

CycloneGetSr:
  ldrb r1,[r0,#0x46] ;@ flags
  bic r2,r1,#0xf3
  tst r1,#1
  orrne r2,r2,#2
  tst r1,#2
  orrne r2,r2,#1
  ldr r1,[r0,#0x4c] ;@ the X flag
  tst r1,#0x20000000
  orrne r2,r2,#0x10
  ldrb r1,[r0,#0x44] ;@ the SR high
  orr r0,r2,r1,lsl #8
  bx lr

CyclonePack:
  stmfd sp!,{r4,r5,lr}
  mov r4,r0
  mov r5,r1
  mov r3,#16
;@ 0x00-0x3f: DA registers
c_pack_loop:
  ldr r1,[r0],#4
  subs r3,r3,#1
  str r1,[r5],#4
  bne c_pack_loop
;@ 0x40: PC
  ldr r0,[r4,#0x40] ;@ PC + Memory Base
  ldr r1,[r4,#0x60] ;@ Memory base
  sub r0,r0,r1
  str r0,[r5],#4
;@ 0x44: SR
  mov r0,r4
  bl CycloneGetSr
  strh r0,[r5],#2
;@ 0x46: IRQ level
  ldrb r0,[r4,#0x47]
  strb r0,[r5],#2
;@ 0x48: other SP
  ldr r0,[r4,#0x48]
  str r0,[r5],#4
;@ 0x4c: CPU state flags
  ldr r0,[r4,#0x58]
  str r0,[r5],#4
  ldmfd sp!,{r4,r5,pc}

CycloneUnpack:
  stmfd sp!,{r5,r7,lr}
  mov r7,r0
  movs r5,r1
  beq c_unpack_do_pc
  mov r3,#16
;@ 0x00-0x3f: DA registers
c_unpack_loop:
  ldr r1,[r5],#4
  subs r3,r3,#1
  str r1,[r0],#4
  bne c_unpack_loop
;@ 0x40: PC
  ldr r0,[r5],#4 ;@ PC
  str r0,[r7,#0x40] ;@ handle later
;@ 0x44: SR
  ldrh r1,[r5],#2
  mov r0,r7
  bl CycloneSetSr
;@ 0x46: IRQ level
  ldrb r0,[r5],#2
  strb r0,[r7,#0x47]
;@ 0x48: other SP
  ldr r0,[r5],#4
  str r0,[r7,#0x48]
;@ 0x4c: CPU state flags
  ldr r0,[r5],#4
  str r0,[r7,#0x58]
c_unpack_do_pc:
  ldr r0,[r7,#0x40] ;@ unbased PC
  mov r1,#0
  str r1,[r7,#0x60] ;@ Memory base
  bl m68k_checkpc ;@ Call checkpc()
  str r0,[r7,#0x40] ;@ PC + Memory Base
  ldmfd sp!,{r5,r7,pc}

CycloneFlushIrq:
  ldr r1,[r0,#0x44]  ;@ Get SR high T_S__III and irq level
  mov r2,r1,lsr #24 ;@ Get IRQ level
  cmp r2,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r2,r1 ;@ irq<=6: Is irq<=mask ?
  movle r0,#0
  bxle lr ;@ no ints

  stmdb sp!,{r4,r5,r7,r8,r10,r11,lr}
  mov r7,r0
  mov r0,r2
  ldrb r10,[r7,#0x46]  ;@ r10 = Flags (NZCV)
  mov r5,#0
  ldr r4,[r7,#0x40]    ;@ r4 = Current PC + Memory Base
  mov r10,r10,lsl #28  ;@ r10 = Flags 0xf0000000, cpsr format
  adr r2,CycloneFlushIrqEnd
  str r2,[r7,#0x98]  ;@ set custom CycloneEnd
  b CycloneDoInterrupt

CycloneFlushIrqEnd:
  rsb r0,r5,#0
  str r4,[r7,#0x40]   ;@ Save Current PC + Memory Base
  strb r10,[r7,#0x46] ;@ Save Flags (NZCV)
  ldmia sp!,{r4,r5,r7,r8,r10,r11,lr}
  bx lr


CycloneSetRealTAS:
  bx lr

;@ DoInterrupt - r0=IRQ level
CycloneDoInterruptGoBack:
  sub r4,r4,#2
CycloneDoInterrupt:
  bic r8,r8,#0xff000000
  orr r8,r8,r0,lsl #29 ;@ abuse r8
  ldr r2,[r7,#0x58] ;@ state flags
  and r0,r0,#7
  orr r3,r0,#0x20 ;@ Supervisor mode + IRQ level
  bic r2,r2,#3 ;@ clear stopped and trace states
  orr r2,r2,#4 ;@ set activity bit: 'not processing instruction'
  str r2,[r7,#0x58]
  ldrb r6,[r7,#0x44] ;@ Get old SR high, abuse r6
  strb r3,[r7,#0x44] ;@ Put new SR high

  ldr r1,[r7,#0x60] ;@ Get Memory base
  ldr r11,[r7,#0x3c] ;@ Get A7
  tst r6,#0x20
;@ get our SP:
  ldreq r2,[r7,#0x48] ;@ ...or OSP as our stack pointer
  streq r11,[r7,#0x48]
  moveq r11,r2
;@ Push old PC onto stack
  sub r0,r11,#4 ;@ Predecremented A7
  sub r1,r4,r1 ;@ r1 = Old PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler
;@ Push old SR:
  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,lsr #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r6,lsl #8 ;@ Include old SR high
  sub r0,r11,#6 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  mov r11,r8,lsr #29
  mov r0,r11
;@ call IrqCallback if it is defined
  ldr r3,[r7,#0x8c] ;@ IrqCallback
  add lr,pc,#4*3
  tst r3,r3
  streqb r3,[r7,#0x47] ;@ just clear IRQ if there is no callback
  mvneq r0,#0 ;@ and simulate -1 return
  bxne r3
;@ get IRQ vector address:
  cmn r0,#1 ;@ returned -1?
  addeq r0,r11,#0x18 ;@ use autovector then
  cmn r0,#2 ;@ returned -2?
  moveq r0,#0x18 ;@ use spurious interrupt then
  mov r0,r0,lsl #2 ;@ get vector address

  ldr r11,[r7,#0x60] ;@ Get Memory base
;@ Read IRQ Vector:
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  tst r0,r0 ;@ uninitialized int vector?
  moveq r0,#0x3c
  bleq m68k_read32 ;@ Call read32(r0) handler
  add lr,pc,#4
  add r0,r0,r11 ;@ r0 = Memory Base + New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0

  tst r4,#1
  bne ExceptionAddressError_r_prg_r4
  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#44 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Exception:
  ;@ Cause an Exception - Vector number in r0
  mov r11,lr ;@ Preserve ARM return address
  bic r8,r8,#0xff000000
  orr r8,r8,r0,lsl #24 ;@ abuse r8
  ldr r6,[r7,#0x44] ;@ Get old SR high, abuse r6
  ldr r2,[r7,#0x58] ;@ state flags
  and r3,r6,#0x27 ;@ clear trace and unused flags
  orr r3,r3,#0x20 ;@ set supervisor mode
  bic r2,r2,#3 ;@ clear stopped and trace states
  str r2,[r7,#0x58]
  strb r3,[r7,#0x44] ;@ Put new SR high

  ldr r0,[r7,#0x3c] ;@ Get A7
  tst r6,#0x20
;@ get our SP:
  ldreq r2,[r7,#0x48] ;@ ...or OSP as our stack pointer
  streq r0,[r7,#0x48]
  moveq r0,r2
;@ Push old PC onto stack
  ldr r1,[r7,#0x60] ;@ Get Memory base
  sub r0,r0,#4 ;@ Predecremented A7
  str r0,[r7,#0x3c] ;@ Save A7
  sub r1,r4,r1 ;@ r1 = Old PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler
;@ Push old SR:
  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,lsr #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  ldr r0,[r7,#0x3c] ;@ A7
  orr r1,r1,r6,lsl #8 ;@ Include SR high
  sub r0,r0,#2 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ Read Exception Vector:
  mov r0,r8,lsr #24
  mov r0,r0,lsl #2
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  ldr r3,[r7,#0x60] ;@ Get Memory base
  add lr,pc,#4
  add r0,r0,r3 ;@ r0 = Memory Base + New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0

  tst r4,#1
  bne ExceptionAddressError_r_prg_r4
  ldr r6,[r7,#0x54]
  bx r11 ;@ Return

ExceptionAddressError_r_data:
  ldr r1,[r7,#0x44]
  mov r6,#0x11
  mov r11,r0
  tst r1,#0x20
  orrne r6,r6,#4
  b ExceptionAddressError

ExceptionAddressError_r_prg:
  ldr r1,[r7,#0x44]
  mov r6,#0x12
  mov r11,r0
  tst r1,#0x20
  orrne r6,r6,#4
  b ExceptionAddressError

ExceptionAddressError_w_data:
  ldr r1,[r7,#0x44]
  mov r6,#0x01
  mov r11,r0
  tst r1,#0x20
  orrne r6,r6,#4
  b ExceptionAddressError

ExceptionAddressError_r_prg_r4:
  ldr r1,[r7,#0x44]
  ldr r3,[r7,#0x60] ;@ Get Memory base
  mov r6,#0x12
  sub r11,r4,r3
  tst r1,#0x20
  orrne r6,r6,#4

ExceptionAddressError:
;@ r6 - info word (without instruction/not bit), r11 - faulting address
  ldrb r0,[r7,#0x44] ;@ Get old SR high
  ldr r2,[r7,#0x58] ;@ state flags
  and r3,r0,#0x27 ;@ clear trace and unused flags
  orr r3,r3,#0x20 ;@ set supervisor mode
  strb r3,[r7,#0x44] ;@ Put new SR high
  bic r2,r2,#3 ;@ clear stopped and trace states
  tst r2,#4
  orrne r6,r6,#8 ;@ complete info word
  orr r2,r2,#4 ;@ set activity bit: 'not processing instruction'
  str r2,[r7,#0x58]
  and r10,r10,#0xf0000000
  orr r10,r10,r0,lsl #4 ;@ some preparations for SR push

  ldr r0,[r7,#0x3c] ;@ Get A7
  tst r10,#0x200
;@ get our SP:
  ldreq r2,[r7,#0x48] ;@ ...or OSP as our stack pointer
  streq r0,[r7,#0x48]
  moveq r0,r2
;@ Push old PC onto stack
  ldr r1,[r7,#0x60] ;@ Get Memory base
  sub r0,r0,#4 ;@ Predecremented A7
  sub r1,r4,r1 ;@ r1 = Old PC
  str r0,[r7,#0x3c] ;@ Save A7
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler
;@ Push old SR:
  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,ror #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  ldr r0,[r7,#0x3c] ;@ A7
  and r10,r10,#0xf0000000
  sub r0,r0,#2 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler
;@ Push IR:
  ldr r0,[r7,#0x3c] ;@ A7
  mov r1,r8
  sub r0,r0,#2 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler
;@ Push address:
  ldr r0,[r7,#0x3c] ;@ A7
  mov r1,r11
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler
;@ Push info word:
  ldr r0,[r7,#0x3c] ;@ A7
  mov r1,r6
  sub r0,r0,#2 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ Read Exception Vector:
  mov r0,#0x0c
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  ldr r3,[r7,#0x60] ;@ Get Memory base
  add lr,pc,#4
  add r0,r0,r3 ;@ r0 = Memory Base + New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0

  bic r4,r4,#1
  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#50 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

CycloneDoTraceWithChecks:
  ldr r0,[r7,#0x58]
  cmp r5,#0
  orr r0,r0,#2 ;@ go to trace mode
  str r0,[r7,#0x58]
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  beq CycloneDoTrace
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  bgt CycloneDoInterruptGoBack

CycloneDoTrace:
  str r5,[r7,#0x9c] ;@ save cycles
  ldr r1,[r7,#0x98]
  mov r5,#0
  str r1,[r7,#0xa0]
  adr r0,TraceEnd
  str r0,[r7,#0x98] ;@ store TraceEnd as CycloneEnd hadler
  ldr pc,[r6,r8,asl #2] ;@ Jump to opcode handler

TraceEnd:
  ldr r2,[r7,#0x58]
  ldr r0,[r7,#0x9c] ;@ restore cycles
  ldr r1,[r7,#0xa0] ;@ old CycloneEnd handler
  mov r10,r10,lsl #28
  add r5,r0,r5
  str r1,[r7,#0x98]
;@ still tracing?
  tst r2,#2
  beq TraceDisabled
;@ trace exception
  ldr r1,[r7,#0x58]
  mov r0,#9
  orr r1,r1,#4 ;@ set activity bit: 'not processing instruction'
  str r1,[r7,#0x58]
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

TraceDisabled:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  cmp r5,#0
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------------------------- Opcodes ---------------------------
Op____: ;@ Called if an opcode is not recognised
  ldr r1,[r7,#0x58]
  sub r4,r4,#2
  orr r1,r1,#4 ;@ set activity bit: 'not processing instruction'
  str r1,[r7,#0x58]
  mov r0,#4
  bl Exception

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Op__al: ;@ Unrecognised a-line opcode
  sub r4,r4,#2
  mov r0,#0x0a
  bl Exception

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Op__fl: ;@ Unrecognised f-line opcode
  sub r4,r4,#2
  mov r0,#0x0b
  bl Exception

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6702] beq 4 uses Op6702 ----------
Op6702:
  tst r10,#0x40000000 ;@ eq: Z
  beq BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

BccDontBranch8:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6602] bne 4 uses Op6602 ----------
Op6602:
  tst r10,#0x40000000 ;@ ne: !Z
  bne BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51c8] dbra d0, 3335 uses Op51c8 ----------
Op51c8:
;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ Dn.w is -1:
DbraMin1:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a38] tst.b $3333.w uses Op4a38 ----------
Op4a38:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r0,r0,asl #24

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d040] add.w d0, d0 uses Opd040 ----------
Opd040:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a79] tst.w $33333333.l uses Op4a79 ----------
Op4a79:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r0,r0,asl #16

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0240] andi.w #$3333, d0 uses Op0240 ----------
Op0240:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r10,r10,asl #16
;@ Do arithmetic:
  ands r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2038] move.l $3333.w, d0 uses Op2038 ----------
Op2038:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0b8] cmp.l $3333.w, d0 uses Opb0b8 ----------
Opb0b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6002] bra 4 uses Op6002 ----------
Op6002:
  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30c0] move.w d0, (a0)+ uses Op30c0 ----------
Op30c0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrh r1,[r7,r1]

  movs r2,r1,lsl #16
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3028] move.w ($3333,a0), d0 uses Op3028 ----------
Op3028:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c40] cmpi.w #$3333, d0 uses Op0c40 ----------
Op0c40:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c79] cmpi.w #$3333, $33333333.l uses Op0c79 ----------
Op0c79:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e75] rts uses Op4e75 ----------
Op4e75:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Pop PC:
  ldr r0,[r7,#0x3c]
  add r1,r0,#4 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  ldr r1,[r7,#0x60] ;@ Get Memory base
  add r0,r0,r1 ;@ Memory Base+PC

  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e71] nop uses Op4e71 ----------
Op4e71:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3000] move.w d0, d0 uses Op3000 ----------
Op3000:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrh r1,[r7,r1]

  movs r2,r1,lsl #16
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0839] btst #$33, $33333333.l uses Op0839 ----------
Op0839:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [7000] moveq #$0, d0 uses Op7000 ----------
Op7000:
  movs r0,r8,asl #24
  and r1,r8,#0x0e00
  mov r0,r0,asr #24 ;@ Sign extended Quick value
  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  str r0,[r7,r1,lsr #7] ;@ Store into Dn

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3040] movea.w d0, a0 uses Op3040 ----------
Op3040:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0838] btst #$33, $3333.w uses Op0838 ----------
Op0838:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a39] tst.b $33333333.l uses Op4a39 ----------
Op4a39:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r0,r0,asl #24

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33d8] move.w (a0)+, $33333333.l uses Op33d8 ----------
Op33d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6700] beq 3335 uses Op6700 ----------
Op6700:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  tst r10,#0x40000000 ;@ eq: Z
  beq BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

BccDontBranch16:
  add r4,r4,#2
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b038] cmp.b $3333.w, d0 uses Opb038 ----------
Opb038:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3039] move.w $33333333.l, d0 uses Op3039 ----------
Op3039:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4840] swap d0 uses Op4840 ----------
Op4840:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  movs r1,r0,ror #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6102] bsr 4 uses Op6102 ----------
Op6102:
  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
;@ Bsr - remember old PC
  ldr r12,[r7,#0x60] ;@ Get Memory base
  ldr r2,[r7,#0x3c]
  sub r1,r4,r12 ;@ r1 = Old PC

;@ Push r1 onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6100] bsr 3335 uses Op6100 ----------
Op6100:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
;@ Bsr - remember old PC
  ldr r12,[r7,#0x60] ;@ Get Memory base
  ldr r2,[r7,#0x3c]
  sub r1,r4,r12 ;@ r1 = Old PC
  add r1,r1,#2

;@ Push r1 onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  add r0,r4,r11 ;@ New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e40] addq.w #7, d0 uses Op5e40 ----------
Op5e40:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1039] move.b $33333333.l, d0 uses Op1039 ----------
Op1039:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20c0] move.l d0, (a0)+ uses Op20c0 ----------
Op20c0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1018] move.b (a0)+, d0 uses Op1018 ----------
Op1018:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30d0] move.w (a0), (a0)+ uses Op30d0 ----------
Op30d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3080] move.w d0, (a0) uses Op3080 ----------
Op3080:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrh r1,[r7,r1]

  movs r2,r1,lsl #16
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3018] move.w (a0)+, d0 uses Op3018 ----------
Op3018:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c040] and.w d0, d0 uses Opc040 ----------
Opc040:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3180] move.w d0, ($33,a0,d3.w*2) uses Op3180 ----------
Op3180:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrh r1,[r7,r1]

  movs r2,r1,lsl #16
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1198] move.b (a0)+, ($33,a0,d3.w*2) uses Op1198 ----------
Op1198:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6502] bcs 4 uses Op6502 ----------
Op6502:
  tst r10,#0x20000000 ;@ cs: C
  beq BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6500] bcs 3335 uses Op6500 ----------
Op6500:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  tst r10,#0x20000000 ;@ cs: C
  beq BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6402] bcc 4 uses Op6402 ----------
Op6402:
  tst r10,#0x20000000 ;@ cc: !C
  bne BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6a02] bpl 4 uses Op6a02 ----------
Op6a02:
  tst r10,r10 ;@ pl: !N
  bmi BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41f0] lea ($33,a0,d3.w*2), a0 uses Op41f0 ----------
Op41f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r1:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r1,r2,r3 ;@ r1=Disp+An+Rn
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a28] tst.b ($3333,a0) uses Op4a28 ----------
Op4a28:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r0,r0,asl #24

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0828] btst #$33, ($3333,a0) uses Op0828 ----------
Op0828:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0640] addi.w #$3333, d0 uses Op0640 ----------
Op0640:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10c0] move.b d0, (a0)+ uses Op10c0 ----------
Op10c0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsl #2]

  movs r2,r1,lsl #24
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10d8] move.b (a0)+, (a0)+ uses Op10d8 ----------
Op10d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0000] ori.b #$33, d0 uses Op0000 ----------
Op0000:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r10,r10,asl #24
;@ Do arithmetic:
  orrs r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0010] ori.b #$33, (a0) uses Op0010 ----------
Op0010:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orrs r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0018] ori.b #$33, (a0)+ uses Op0018 ----------
Op0018:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orrs r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [001f] ori.b #$33, (a7)+ uses Op001f ----------
Op001f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orrs r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0020] ori.b #$33, -(a0) uses Op0020 ----------
Op0020:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orrs r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0027] ori.b #$33, -(a7) uses Op0027 ----------
Op0027:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orrs r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0028] ori.b #$33, ($3333,a0) uses Op0028 ----------
Op0028:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orrs r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0030] ori.b #$33, ($33,a0,d3.w*2) uses Op0030 ----------
Op0030:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orrs r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0038] ori.b #$33, $3333.w uses Op0038 ----------
Op0038:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orrs r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0039] ori.b #$33, $33333333.l uses Op0039 ----------
Op0039:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orrs r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [003c] ori.b #$33, ccr uses Op003c ----------
Op003c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  ldr r2,[r7,#0x4c]   ;@ Load old X bit
  orr r10,r10,r0,lsl #28
  orr r2,r2,r0,lsl #25 ;@ X bit
  str r2,[r7,#0x4c]   ;@ Save X bit

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0040] ori.w #$3333, d0 uses Op0040 ----------
Op0040:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r10,r10,asl #16
;@ Do arithmetic:
  orrs r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0050] ori.w #$3333, (a0) uses Op0050 ----------
Op0050:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orrs r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0058] ori.w #$3333, (a0)+ uses Op0058 ----------
Op0058:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orrs r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0060] ori.w #$3333, -(a0) uses Op0060 ----------
Op0060:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orrs r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0068] ori.w #$3333, ($3333,a0) uses Op0068 ----------
Op0068:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orrs r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0070] ori.w #$3333, ($33,a0,d3.w*2) uses Op0070 ----------
Op0070:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orrs r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0078] ori.w #$3333, $3333.w uses Op0078 ----------
Op0078:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orrs r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0079] ori.w #$3333, $33333333.l uses Op0079 ----------
Op0079:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orrs r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [007c] ori.w #$3333, sr uses Op007c ----------
Op007c:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  ldr r2,[r7,#0x4c]   ;@ Load old X bit
  orr r10,r10,r0,lsl #28
  orr r2,r2,r0,lsl #25 ;@ X bit
  orr r1,r11,r0,lsr #8
  and r1,r1,#0xa7 ;@ mask-out unused bits
  str r2,[r7,#0x4c]   ;@ Save X bit
  strb r1,[r7,#0x44]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#20 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0080] ori.l #$33333333, d0 uses Op0080 ----------
Op0080:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  orrs r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0090] ori.l #$33333333, (a0) uses Op0090 ----------
Op0090:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orrs r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0098] ori.l #$33333333, (a0)+ uses Op0098 ----------
Op0098:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orrs r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00a0] ori.l #$33333333, -(a0) uses Op00a0 ----------
Op00a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orrs r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00a8] ori.l #$33333333, ($3333,a0) uses Op00a8 ----------
Op00a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orrs r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00b0] ori.l #$33333333, ($33,a0,d3.w*2) uses Op00b0 ----------
Op00b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orrs r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00b8] ori.l #$33333333, $3333.w uses Op00b8 ----------
Op00b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orrs r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00b9] ori.l #$33333333, $33333333.l uses Op00b9 ----------
Op00b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orrs r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0100] btst d0, d0 uses Op0100 ----------
Op0100:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  and r11,r11,#31 ;@ reg - do mod 32

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0108] movep.w ($3333,a0), d0 uses Op0108 ----------
Op0108:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r6:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r6,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r6) into r11:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r6,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

  add r0,r6,#2
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  orr r1,r11,r1,lsr #8 ;@ second byte
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0110] btst d0, (a0) uses Op0110 ----------
Op0110:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0118] btst d0, (a0)+ uses Op0118 ----------
Op0118:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [011f] btst d0, (a7)+ uses Op011f ----------
Op011f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0120] btst d0, -(a0) uses Op0120 ----------
Op0120:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0127] btst d0, -(a7) uses Op0127 ----------
Op0127:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0128] btst d0, ($3333,a0) uses Op0128 ----------
Op0128:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0130] btst d0, ($33,a0,d3.w*2) uses Op0130 ----------
Op0130:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0138] btst d0, $3333.w uses Op0138 ----------
Op0138:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0139] btst d0, $33333333.l uses Op0139 ----------
Op0139:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [013a] btst d0, ($3333,pc); =3335 uses Op013a ----------
Op013a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [013b] btst d0, ($33,pc,d3.w*2); =35 uses Op013b ----------
Op013b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [013c] btst d0, #$33 uses Op013c ----------
Op013c:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0140] bchg d0, d0 uses Op0140 ----------
Op0140:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get register index into r8:
  and r8,r8,#0x000f
;@ EaRead : Read register[r8] into r0:
  ldr r0,[r7,r8,lsl #2]

  and r11,r11,#31 ;@ reg - do mod 32

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r11 ;@ Toggle bit

;@ EaWrite: r1 into register[r8]:
  str r1,[r7,r8,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0148] movep.l ($3333,a0), d0 uses Op0148 ----------
Op0148:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r6:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r6,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r6) into r11:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r6,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

  add r0,r6,#2
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  orr r11,r11,r1,lsr #8 ;@ second byte
  add r0,r6,#4
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  orr r11,r11,r1,lsr #16 ;@ third byte
  add r0,r6,#6
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  orr r1,r11,r1,lsr #24 ;@ fourth byte
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0150] bchg d0, (a0) uses Op0150 ----------
Op0150:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a0)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0158] bchg d0, (a0)+ uses Op0158 ----------
Op0158:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a0)+' into r8:
  and r2,r8,#0x000f
  ldr r8,[r7,r2,lsl #2]
  add r3,r8,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a0)+' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [015f] bchg d0, (a7)+ uses Op015f ----------
Op015f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a7)+' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  add r3,r8,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a7)+' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0160] bchg d0, -(a0) uses Op0160 ----------
Op0160:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
  sub r8,r8,#1 ;@ Pre-decrement An
  str r8,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '-(a0)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0167] bchg d0, -(a7) uses Op0167 ----------
Op0167:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#2 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '-(a7)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0168] bchg d0, ($3333,a0) uses Op0168 ----------
Op0168:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($3333,a0)' into r8:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r8,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0170] bchg d0, ($33,a0,d3.w*2) uses Op0170 ----------
Op0170:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($33,a0,d3.w*2)' into r8:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r8,r2,r3 ;@ r8=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0178] bchg d0, $3333.w uses Op0178 ----------
Op0178:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '$3333.w' into r8:
  ldrsh r8,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '$3333.w' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0179] bchg d0, $33333333.l uses Op0179 ----------
Op0179:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '$33333333.l' into r8:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r8,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0180] bclr d0, d0 uses Op0180 ----------
Op0180:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get register index into r8:
  and r8,r8,#0x000f
;@ EaRead : Read register[r8] into r0:
  ldr r0,[r7,r8,lsl #2]

  and r11,r11,#31 ;@ reg - do mod 32

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r11 ;@ Clear bit

;@ EaWrite: r1 into register[r8]:
  str r1,[r7,r8,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0188] movep.w d0, ($3333,a0) uses Op0188 ----------
Op0188:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($3333,a0)' into r8:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r8,r0,r2 ;@ Add on offset
  mov r0,r8
  mov r1,r11,lsr #8 ;@ first or third byte
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  add r0,r8,#2
  and r1,r11,#0xff
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0190] bclr d0, (a0) uses Op0190 ----------
Op0190:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r11 ;@ Clear bit

;@ EaWrite: Write r1 into '(a0)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0198] bclr d0, (a0)+ uses Op0198 ----------
Op0198:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a0)+' into r8:
  and r2,r8,#0x000f
  ldr r8,[r7,r2,lsl #2]
  add r3,r8,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r11 ;@ Clear bit

;@ EaWrite: Write r1 into '(a0)+' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [019f] bclr d0, (a7)+ uses Op019f ----------
Op019f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a7)+' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  add r3,r8,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r11 ;@ Clear bit

;@ EaWrite: Write r1 into '(a7)+' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01a0] bclr d0, -(a0) uses Op01a0 ----------
Op01a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
  sub r8,r8,#1 ;@ Pre-decrement An
  str r8,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r11 ;@ Clear bit

;@ EaWrite: Write r1 into '-(a0)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01a7] bclr d0, -(a7) uses Op01a7 ----------
Op01a7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#2 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r11 ;@ Clear bit

;@ EaWrite: Write r1 into '-(a7)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01a8] bclr d0, ($3333,a0) uses Op01a8 ----------
Op01a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($3333,a0)' into r8:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r8,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r11 ;@ Clear bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01b0] bclr d0, ($33,a0,d3.w*2) uses Op01b0 ----------
Op01b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($33,a0,d3.w*2)' into r8:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r8,r2,r3 ;@ r8=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r11 ;@ Clear bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01b8] bclr d0, $3333.w uses Op01b8 ----------
Op01b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '$3333.w' into r8:
  ldrsh r8,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r11 ;@ Clear bit

;@ EaWrite: Write r1 into '$3333.w' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01b9] bclr d0, $33333333.l uses Op01b9 ----------
Op01b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '$33333333.l' into r8:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r8,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r11 ;@ Clear bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01c0] bset d0, d0 uses Op01c0 ----------
Op01c0:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get register index into r8:
  and r8,r8,#0x000f
;@ EaRead : Read register[r8] into r0:
  ldr r0,[r7,r8,lsl #2]

  and r11,r11,#31 ;@ reg - do mod 32

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r11 ;@ Set bit

;@ EaWrite: r1 into register[r8]:
  str r1,[r7,r8,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01c8] movep.l d0, ($3333,a0) uses Op01c8 ----------
Op01c8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($3333,a0)' into r8:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r8,r0,r2 ;@ Add on offset
  mov r1,r11,lsr #24 ;@ first byte
;@ EaWrite: Write r1 into '($3333,a0)' (address in r8):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  add r0,r8,#2
  mov r1,r11,lsr #16 ;@ second byte
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  add r0,r8,#4
  mov r1,r11,lsr #8 ;@ first or third byte
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  add r0,r8,#6
  and r1,r11,#0xff
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01d0] bset d0, (a0) uses Op01d0 ----------
Op01d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r11 ;@ Set bit

;@ EaWrite: Write r1 into '(a0)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01d8] bset d0, (a0)+ uses Op01d8 ----------
Op01d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a0)+' into r8:
  and r2,r8,#0x000f
  ldr r8,[r7,r2,lsl #2]
  add r3,r8,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r11 ;@ Set bit

;@ EaWrite: Write r1 into '(a0)+' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01df] bset d0, (a7)+ uses Op01df ----------
Op01df:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a7)+' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  add r3,r8,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r11 ;@ Set bit

;@ EaWrite: Write r1 into '(a7)+' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01e0] bset d0, -(a0) uses Op01e0 ----------
Op01e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
  sub r8,r8,#1 ;@ Pre-decrement An
  str r8,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r11 ;@ Set bit

;@ EaWrite: Write r1 into '-(a0)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01e7] bset d0, -(a7) uses Op01e7 ----------
Op01e7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#2 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r11 ;@ Set bit

;@ EaWrite: Write r1 into '-(a7)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01e8] bset d0, ($3333,a0) uses Op01e8 ----------
Op01e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($3333,a0)' into r8:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r8,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r11 ;@ Set bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01f0] bset d0, ($33,a0,d3.w*2) uses Op01f0 ----------
Op01f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($33,a0,d3.w*2)' into r8:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r8,r2,r3 ;@ r8=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r11 ;@ Set bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01f8] bset d0, $3333.w uses Op01f8 ----------
Op01f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '$3333.w' into r8:
  ldrsh r8,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r11 ;@ Set bit

;@ EaWrite: Write r1 into '$3333.w' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01f9] bset d0, $33333333.l uses Op01f9 ----------
Op01f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '$33333333.l' into r8:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r8,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r11 ;@ Set bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0200] andi.b #$33, d0 uses Op0200 ----------
Op0200:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r10,r10,asl #24
;@ Do arithmetic:
  ands r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0210] andi.b #$33, (a0) uses Op0210 ----------
Op0210:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  ands r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0218] andi.b #$33, (a0)+ uses Op0218 ----------
Op0218:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  ands r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [021f] andi.b #$33, (a7)+ uses Op021f ----------
Op021f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  ands r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0220] andi.b #$33, -(a0) uses Op0220 ----------
Op0220:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  ands r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0227] andi.b #$33, -(a7) uses Op0227 ----------
Op0227:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  ands r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0228] andi.b #$33, ($3333,a0) uses Op0228 ----------
Op0228:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  ands r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0230] andi.b #$33, ($33,a0,d3.w*2) uses Op0230 ----------
Op0230:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  ands r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0238] andi.b #$33, $3333.w uses Op0238 ----------
Op0238:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  ands r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0239] andi.b #$33, $33333333.l uses Op0239 ----------
Op0239:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  ands r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [023c] andi.b #$33, ccr uses Op023c ----------
Op023c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  ldr r2,[r7,#0x4c]   ;@ Load old X bit
  and r10,r10,r0,lsl #28
  and r2,r2,r0,lsl #25 ;@ X bit
  str r2,[r7,#0x4c]   ;@ Save X bit

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0250] andi.w #$3333, (a0) uses Op0250 ----------
Op0250:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  ands r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0258] andi.w #$3333, (a0)+ uses Op0258 ----------
Op0258:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  ands r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0260] andi.w #$3333, -(a0) uses Op0260 ----------
Op0260:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  ands r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0268] andi.w #$3333, ($3333,a0) uses Op0268 ----------
Op0268:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  ands r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0270] andi.w #$3333, ($33,a0,d3.w*2) uses Op0270 ----------
Op0270:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  ands r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0278] andi.w #$3333, $3333.w uses Op0278 ----------
Op0278:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  ands r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0279] andi.w #$3333, $33333333.l uses Op0279 ----------
Op0279:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  ands r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [027c] andi.w #$3333, sr uses Op027c ----------
Op027c:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  ldr r2,[r7,#0x4c]   ;@ Load old X bit
  and r10,r10,r0,lsl #28
  and r2,r2,r0,lsl #25 ;@ X bit
  and r1,r11,r0,lsr #8
  str r2,[r7,#0x4c]   ;@ Save X bit
  strb r1,[r7,#0x44]

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap027c
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap027c:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ble CycloneEnd
;@ CheckInterrupt:
  ldr r1,[r7,#0x44]
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [0280] andi.l #$33333333, d0 uses Op0280 ----------
Op0280:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  ands r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0290] andi.l #$33333333, (a0) uses Op0290 ----------
Op0290:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  ands r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0298] andi.l #$33333333, (a0)+ uses Op0298 ----------
Op0298:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  ands r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02a0] andi.l #$33333333, -(a0) uses Op02a0 ----------
Op02a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  ands r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02a8] andi.l #$33333333, ($3333,a0) uses Op02a8 ----------
Op02a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  ands r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02b0] andi.l #$33333333, ($33,a0,d3.w*2) uses Op02b0 ----------
Op02b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  ands r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02b8] andi.l #$33333333, $3333.w uses Op02b8 ----------
Op02b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  ands r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02b9] andi.l #$33333333, $33333333.l uses Op02b9 ----------
Op02b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  ands r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0400] subi.b #$33, d0 uses Op0400 ----------
Op0400:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0410] subi.b #$33, (a0) uses Op0410 ----------
Op0410:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0418] subi.b #$33, (a0)+ uses Op0418 ----------
Op0418:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [041f] subi.b #$33, (a7)+ uses Op041f ----------
Op041f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0420] subi.b #$33, -(a0) uses Op0420 ----------
Op0420:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0427] subi.b #$33, -(a7) uses Op0427 ----------
Op0427:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0428] subi.b #$33, ($3333,a0) uses Op0428 ----------
Op0428:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0430] subi.b #$33, ($33,a0,d3.w*2) uses Op0430 ----------
Op0430:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0438] subi.b #$33, $3333.w uses Op0438 ----------
Op0438:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0439] subi.b #$33, $33333333.l uses Op0439 ----------
Op0439:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0440] subi.w #$3333, d0 uses Op0440 ----------
Op0440:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0450] subi.w #$3333, (a0) uses Op0450 ----------
Op0450:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0458] subi.w #$3333, (a0)+ uses Op0458 ----------
Op0458:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0460] subi.w #$3333, -(a0) uses Op0460 ----------
Op0460:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0468] subi.w #$3333, ($3333,a0) uses Op0468 ----------
Op0468:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0470] subi.w #$3333, ($33,a0,d3.w*2) uses Op0470 ----------
Op0470:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0478] subi.w #$3333, $3333.w uses Op0478 ----------
Op0478:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0479] subi.w #$3333, $33333333.l uses Op0479 ----------
Op0479:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0480] subi.l #$33333333, d0 uses Op0480 ----------
Op0480:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0490] subi.l #$33333333, (a0) uses Op0490 ----------
Op0490:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0498] subi.l #$33333333, (a0)+ uses Op0498 ----------
Op0498:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04a0] subi.l #$33333333, -(a0) uses Op04a0 ----------
Op04a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04a8] subi.l #$33333333, ($3333,a0) uses Op04a8 ----------
Op04a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04b0] subi.l #$33333333, ($33,a0,d3.w*2) uses Op04b0 ----------
Op04b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04b8] subi.l #$33333333, $3333.w uses Op04b8 ----------
Op04b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04b9] subi.l #$33333333, $33333333.l uses Op04b9 ----------
Op04b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0600] addi.b #$33, d0 uses Op0600 ----------
Op0600:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0610] addi.b #$33, (a0) uses Op0610 ----------
Op0610:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0618] addi.b #$33, (a0)+ uses Op0618 ----------
Op0618:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [061f] addi.b #$33, (a7)+ uses Op061f ----------
Op061f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0620] addi.b #$33, -(a0) uses Op0620 ----------
Op0620:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0627] addi.b #$33, -(a7) uses Op0627 ----------
Op0627:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0628] addi.b #$33, ($3333,a0) uses Op0628 ----------
Op0628:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0630] addi.b #$33, ($33,a0,d3.w*2) uses Op0630 ----------
Op0630:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0638] addi.b #$33, $3333.w uses Op0638 ----------
Op0638:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0639] addi.b #$33, $33333333.l uses Op0639 ----------
Op0639:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0650] addi.w #$3333, (a0) uses Op0650 ----------
Op0650:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0658] addi.w #$3333, (a0)+ uses Op0658 ----------
Op0658:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0660] addi.w #$3333, -(a0) uses Op0660 ----------
Op0660:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0668] addi.w #$3333, ($3333,a0) uses Op0668 ----------
Op0668:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0670] addi.w #$3333, ($33,a0,d3.w*2) uses Op0670 ----------
Op0670:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0678] addi.w #$3333, $3333.w uses Op0678 ----------
Op0678:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0679] addi.w #$3333, $33333333.l uses Op0679 ----------
Op0679:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0680] addi.l #$33333333, d0 uses Op0680 ----------
Op0680:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0690] addi.l #$33333333, (a0) uses Op0690 ----------
Op0690:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0698] addi.l #$33333333, (a0)+ uses Op0698 ----------
Op0698:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06a0] addi.l #$33333333, -(a0) uses Op06a0 ----------
Op06a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06a8] addi.l #$33333333, ($3333,a0) uses Op06a8 ----------
Op06a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06b0] addi.l #$33333333, ($33,a0,d3.w*2) uses Op06b0 ----------
Op06b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06b8] addi.l #$33333333, $3333.w uses Op06b8 ----------
Op06b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06b9] addi.l #$33333333, $33333333.l uses Op06b9 ----------
Op06b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0800] btst #$33, d0 uses Op0800 ----------
Op0800:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#0x1F ;@ reg - do mod 32
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0810] btst #$33, (a0) uses Op0810 ----------
Op0810:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0818] btst #$33, (a0)+ uses Op0818 ----------
Op0818:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [081f] btst #$33, (a7)+ uses Op081f ----------
Op081f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0820] btst #$33, -(a0) uses Op0820 ----------
Op0820:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0827] btst #$33, -(a7) uses Op0827 ----------
Op0827:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0830] btst #$33, ($33,a0,d3.w*2) uses Op0830 ----------
Op0830:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [083a] btst #$33, ($3333,pc); =3337 uses Op083a ----------
Op083a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [083b] btst #$33, ($33,pc,d3.w*2); =37 uses Op083b ----------
Op083b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0840] bchg #$33, d0 uses Op0840 ----------
Op0840:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#0x1F ;@ reg - do mod 32
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r8:
  and r8,r8,#0x000f
;@ EaRead : Read register[r8] into r0:
  ldr r0,[r7,r8,lsl #2]

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r11 ;@ Toggle bit

;@ EaWrite: r1 into register[r8]:
  str r1,[r7,r8,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0850] bchg #$33, (a0) uses Op0850 ----------
Op0850:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a0)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0858] bchg #$33, (a0)+ uses Op0858 ----------
Op0858:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r8:
  and r2,r8,#0x000f
  ldr r8,[r7,r2,lsl #2]
  add r3,r8,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a0)+' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [085f] bchg #$33, (a7)+ uses Op085f ----------
Op085f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  add r3,r8,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a7)+' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0860] bchg #$33, -(a0) uses Op0860 ----------
Op0860:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
  sub r8,r8,#1 ;@ Pre-decrement An
  str r8,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '-(a0)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0867] bchg #$33, -(a7) uses Op0867 ----------
Op0867:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#2 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '-(a7)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0868] bchg #$33, ($3333,a0) uses Op0868 ----------
Op0868:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r8:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r8,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0870] bchg #$33, ($33,a0,d3.w*2) uses Op0870 ----------
Op0870:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r8:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r8,r2,r3 ;@ r8=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0878] bchg #$33, $3333.w uses Op0878 ----------
Op0878:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r8:
  ldrsh r8,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '$3333.w' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0879] bchg #$33, $33333333.l uses Op0879 ----------
Op0879:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r8:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r8,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0880] bclr #$33, d0 uses Op0880 ----------
Op0880:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#0x1F ;@ reg - do mod 32
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r8:
  and r8,r8,#0x000f
;@ EaRead : Read register[r8] into r0:
  ldr r0,[r7,r8,lsl #2]

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r11 ;@ Clear bit

;@ EaWrite: r1 into register[r8]:
  str r1,[r7,r8,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0890] bclr #$33, (a0) uses Op0890 ----------
Op0890:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r11 ;@ Clear bit

;@ EaWrite: Write r1 into '(a0)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0898] bclr #$33, (a0)+ uses Op0898 ----------
Op0898:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r8:
  and r2,r8,#0x000f
  ldr r8,[r7,r2,lsl #2]
  add r3,r8,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r11 ;@ Clear bit

;@ EaWrite: Write r1 into '(a0)+' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [089f] bclr #$33, (a7)+ uses Op089f ----------
Op089f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  add r3,r8,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r11 ;@ Clear bit

;@ EaWrite: Write r1 into '(a7)+' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08a0] bclr #$33, -(a0) uses Op08a0 ----------
Op08a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
  sub r8,r8,#1 ;@ Pre-decrement An
  str r8,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r11 ;@ Clear bit

;@ EaWrite: Write r1 into '-(a0)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08a7] bclr #$33, -(a7) uses Op08a7 ----------
Op08a7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#2 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r11 ;@ Clear bit

;@ EaWrite: Write r1 into '-(a7)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08a8] bclr #$33, ($3333,a0) uses Op08a8 ----------
Op08a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r8:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r8,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r11 ;@ Clear bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08b0] bclr #$33, ($33,a0,d3.w*2) uses Op08b0 ----------
Op08b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r8:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r8,r2,r3 ;@ r8=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r11 ;@ Clear bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08b8] bclr #$33, $3333.w uses Op08b8 ----------
Op08b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r8:
  ldrsh r8,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r11 ;@ Clear bit

;@ EaWrite: Write r1 into '$3333.w' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08b9] bclr #$33, $33333333.l uses Op08b9 ----------
Op08b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r8:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r8,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r11 ;@ Clear bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08c0] bset #$33, d0 uses Op08c0 ----------
Op08c0:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#0x1F ;@ reg - do mod 32
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r8:
  and r8,r8,#0x000f
;@ EaRead : Read register[r8] into r0:
  ldr r0,[r7,r8,lsl #2]

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r11 ;@ Set bit

;@ EaWrite: r1 into register[r8]:
  str r1,[r7,r8,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08d0] bset #$33, (a0) uses Op08d0 ----------
Op08d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r11 ;@ Set bit

;@ EaWrite: Write r1 into '(a0)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08d8] bset #$33, (a0)+ uses Op08d8 ----------
Op08d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r8:
  and r2,r8,#0x000f
  ldr r8,[r7,r2,lsl #2]
  add r3,r8,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r11 ;@ Set bit

;@ EaWrite: Write r1 into '(a0)+' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08df] bset #$33, (a7)+ uses Op08df ----------
Op08df:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  add r3,r8,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r11 ;@ Set bit

;@ EaWrite: Write r1 into '(a7)+' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08e0] bset #$33, -(a0) uses Op08e0 ----------
Op08e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
  sub r8,r8,#1 ;@ Pre-decrement An
  str r8,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r11 ;@ Set bit

;@ EaWrite: Write r1 into '-(a0)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08e7] bset #$33, -(a7) uses Op08e7 ----------
Op08e7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#2 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r11 ;@ Set bit

;@ EaWrite: Write r1 into '-(a7)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08e8] bset #$33, ($3333,a0) uses Op08e8 ----------
Op08e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r8:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r8,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r11 ;@ Set bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08f0] bset #$33, ($33,a0,d3.w*2) uses Op08f0 ----------
Op08f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r8:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r8,r2,r3 ;@ r8=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r11 ;@ Set bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08f8] bset #$33, $3333.w uses Op08f8 ----------
Op08f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r8:
  ldrsh r8,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r11 ;@ Set bit

;@ EaWrite: Write r1 into '$3333.w' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08f9] bset #$33, $33333333.l uses Op08f9 ----------
Op08f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r8:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r8,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r8) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r8,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r11 ;@ Set bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r8):
  and r1,r1,#0xff
  bic r0,r8,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a00] eori.b #$33, d0 uses Op0a00 ----------
Op0a00:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r10,r10,asl #24
;@ Do arithmetic:
  eors r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a10] eori.b #$33, (a0) uses Op0a10 ----------
Op0a10:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eors r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a18] eori.b #$33, (a0)+ uses Op0a18 ----------
Op0a18:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eors r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a1f] eori.b #$33, (a7)+ uses Op0a1f ----------
Op0a1f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eors r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a20] eori.b #$33, -(a0) uses Op0a20 ----------
Op0a20:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eors r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a27] eori.b #$33, -(a7) uses Op0a27 ----------
Op0a27:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eors r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a28] eori.b #$33, ($3333,a0) uses Op0a28 ----------
Op0a28:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eors r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a30] eori.b #$33, ($33,a0,d3.w*2) uses Op0a30 ----------
Op0a30:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eors r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a38] eori.b #$33, $3333.w uses Op0a38 ----------
Op0a38:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eors r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a39] eori.b #$33, $33333333.l uses Op0a39 ----------
Op0a39:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eors r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a3c] eori.b #$33, ccr uses Op0a3c ----------
Op0a3c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  ldr r2,[r7,#0x4c]   ;@ Load old X bit
  eor r10,r10,r0,lsl #28
  eor r2,r2,r0,lsl #25 ;@ X bit
  str r2,[r7,#0x4c]   ;@ Save X bit

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a40] eori.w #$3333, d0 uses Op0a40 ----------
Op0a40:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r10,r10,asl #16
;@ Do arithmetic:
  eors r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a50] eori.w #$3333, (a0) uses Op0a50 ----------
Op0a50:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eors r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a58] eori.w #$3333, (a0)+ uses Op0a58 ----------
Op0a58:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eors r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a60] eori.w #$3333, -(a0) uses Op0a60 ----------
Op0a60:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eors r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a68] eori.w #$3333, ($3333,a0) uses Op0a68 ----------
Op0a68:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eors r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a70] eori.w #$3333, ($33,a0,d3.w*2) uses Op0a70 ----------
Op0a70:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eors r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a78] eori.w #$3333, $3333.w uses Op0a78 ----------
Op0a78:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eors r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a79] eori.w #$3333, $33333333.l uses Op0a79 ----------
Op0a79:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eors r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a7c] eori.w #$3333, sr uses Op0a7c ----------
Op0a7c:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  ldr r2,[r7,#0x4c]   ;@ Load old X bit
  eor r10,r10,r0,lsl #28
  eor r2,r2,r0,lsl #25 ;@ X bit
  eor r1,r11,r0,lsr #8
  and r1,r1,#0xa7 ;@ mask-out unused bits
  str r2,[r7,#0x4c]   ;@ Save X bit
  strb r1,[r7,#0x44]

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap0a7c
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap0a7c:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#20 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [0a80] eori.l #$33333333, d0 uses Op0a80 ----------
Op0a80:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  eors r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a90] eori.l #$33333333, (a0) uses Op0a90 ----------
Op0a90:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eors r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a98] eori.l #$33333333, (a0)+ uses Op0a98 ----------
Op0a98:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eors r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0aa0] eori.l #$33333333, -(a0) uses Op0aa0 ----------
Op0aa0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eors r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0aa8] eori.l #$33333333, ($3333,a0) uses Op0aa8 ----------
Op0aa8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eors r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ab0] eori.l #$33333333, ($33,a0,d3.w*2) uses Op0ab0 ----------
Op0ab0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eors r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ab8] eori.l #$33333333, $3333.w uses Op0ab8 ----------
Op0ab8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eors r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ab9] eori.l #$33333333, $33333333.l uses Op0ab9 ----------
Op0ab9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eors r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c00] cmpi.b #$33, d0 uses Op0c00 ----------
Op0c00:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c10] cmpi.b #$33, (a0) uses Op0c10 ----------
Op0c10:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c18] cmpi.b #$33, (a0)+ uses Op0c18 ----------
Op0c18:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c1f] cmpi.b #$33, (a7)+ uses Op0c1f ----------
Op0c1f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c20] cmpi.b #$33, -(a0) uses Op0c20 ----------
Op0c20:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c27] cmpi.b #$33, -(a7) uses Op0c27 ----------
Op0c27:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c28] cmpi.b #$33, ($3333,a0) uses Op0c28 ----------
Op0c28:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c30] cmpi.b #$33, ($33,a0,d3.w*2) uses Op0c30 ----------
Op0c30:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c38] cmpi.b #$33, $3333.w uses Op0c38 ----------
Op0c38:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c39] cmpi.b #$33, $33333333.l uses Op0c39 ----------
Op0c39:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c50] cmpi.w #$3333, (a0) uses Op0c50 ----------
Op0c50:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c58] cmpi.w #$3333, (a0)+ uses Op0c58 ----------
Op0c58:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c60] cmpi.w #$3333, -(a0) uses Op0c60 ----------
Op0c60:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c68] cmpi.w #$3333, ($3333,a0) uses Op0c68 ----------
Op0c68:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c70] cmpi.w #$3333, ($33,a0,d3.w*2) uses Op0c70 ----------
Op0c70:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c78] cmpi.w #$3333, $3333.w uses Op0c78 ----------
Op0c78:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c80] cmpi.l #$33333333, d0 uses Op0c80 ----------
Op0c80:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c90] cmpi.l #$33333333, (a0) uses Op0c90 ----------
Op0c90:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c98] cmpi.l #$33333333, (a0)+ uses Op0c98 ----------
Op0c98:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ca0] cmpi.l #$33333333, -(a0) uses Op0ca0 ----------
Op0ca0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ca8] cmpi.l #$33333333, ($3333,a0) uses Op0ca8 ----------
Op0ca8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0cb0] cmpi.l #$33333333, ($33,a0,d3.w*2) uses Op0cb0 ----------
Op0cb0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0cb8] cmpi.l #$33333333, $3333.w uses Op0cb8 ----------
Op0cb8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0cb9] cmpi.l #$33333333, $33333333.l uses Op0cb9 ----------
Op0cb9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1000] move.b d0, d0 uses Op1000 ----------
Op1000:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsl #2]

  movs r2,r1,lsl #24
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1010] move.b (a0), d0 uses Op1010 ----------
Op1010:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [101f] move.b (a7)+, d0 uses Op101f ----------
Op101f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1020] move.b -(a0), d0 uses Op1020 ----------
Op1020:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1027] move.b -(a7), d0 uses Op1027 ----------
Op1027:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1028] move.b ($3333,a0), d0 uses Op1028 ----------
Op1028:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1030] move.b ($33,a0,d3.w*2), d0 uses Op1030 ----------
Op1030:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1038] move.b $3333.w, d0 uses Op1038 ----------
Op1038:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [103a] move.b ($3333,pc), d0; =3335 uses Op103a ----------
Op103a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [103b] move.b ($33,pc,d3.w*2), d0; =35 uses Op103b ----------
Op103b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [103c] move.b #$33, d0 uses Op103c ----------
Op103c:
;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1080] move.b d0, (a0) uses Op1080 ----------
Op1080:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsl #2]

  movs r2,r1,lsl #24
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1090] move.b (a0), (a0) uses Op1090 ----------
Op1090:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1098] move.b (a0)+, (a0) uses Op1098 ----------
Op1098:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [109f] move.b (a7)+, (a0) uses Op109f ----------
Op109f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10a0] move.b -(a0), (a0) uses Op10a0 ----------
Op10a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10a7] move.b -(a7), (a0) uses Op10a7 ----------
Op10a7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10a8] move.b ($3333,a0), (a0) uses Op10a8 ----------
Op10a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10b0] move.b ($33,a0,d3.w*2), (a0) uses Op10b0 ----------
Op10b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10b8] move.b $3333.w, (a0) uses Op10b8 ----------
Op10b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10b9] move.b $33333333.l, (a0) uses Op10b9 ----------
Op10b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10ba] move.b ($3333,pc), (a0); =3335 uses Op10ba ----------
Op10ba:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10bb] move.b ($33,pc,d3.w*2), (a0); =35 uses Op10bb ----------
Op10bb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10bc] move.b #$33, (a0) uses Op10bc ----------
Op10bc:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10d0] move.b (a0), (a0)+ uses Op10d0 ----------
Op10d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10df] move.b (a7)+, (a0)+ uses Op10df ----------
Op10df:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10e0] move.b -(a0), (a0)+ uses Op10e0 ----------
Op10e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10e7] move.b -(a7), (a0)+ uses Op10e7 ----------
Op10e7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10e8] move.b ($3333,a0), (a0)+ uses Op10e8 ----------
Op10e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10f0] move.b ($33,a0,d3.w*2), (a0)+ uses Op10f0 ----------
Op10f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10f8] move.b $3333.w, (a0)+ uses Op10f8 ----------
Op10f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10f9] move.b $33333333.l, (a0)+ uses Op10f9 ----------
Op10f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10fa] move.b ($3333,pc), (a0)+; =3335 uses Op10fa ----------
Op10fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10fb] move.b ($33,pc,d3.w*2), (a0)+; =35 uses Op10fb ----------
Op10fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10fc] move.b #$33, (a0)+ uses Op10fc ----------
Op10fc:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1100] move.b d0, -(a0) uses Op1100 ----------
Op1100:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsl #2]

  movs r2,r1,lsl #24
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1110] move.b (a0), -(a0) uses Op1110 ----------
Op1110:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1118] move.b (a0)+, -(a0) uses Op1118 ----------
Op1118:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [111f] move.b (a7)+, -(a0) uses Op111f ----------
Op111f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1120] move.b -(a0), -(a0) uses Op1120 ----------
Op1120:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1127] move.b -(a7), -(a0) uses Op1127 ----------
Op1127:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1128] move.b ($3333,a0), -(a0) uses Op1128 ----------
Op1128:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1130] move.b ($33,a0,d3.w*2), -(a0) uses Op1130 ----------
Op1130:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1138] move.b $3333.w, -(a0) uses Op1138 ----------
Op1138:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1139] move.b $33333333.l, -(a0) uses Op1139 ----------
Op1139:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [113a] move.b ($3333,pc), -(a0); =3335 uses Op113a ----------
Op113a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [113b] move.b ($33,pc,d3.w*2), -(a0); =35 uses Op113b ----------
Op113b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [113c] move.b #$33, -(a0) uses Op113c ----------
Op113c:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1140] move.b d0, ($3333,a0) uses Op1140 ----------
Op1140:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsl #2]

  movs r2,r1,lsl #24
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1150] move.b (a0), ($3333,a0) uses Op1150 ----------
Op1150:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1158] move.b (a0)+, ($3333,a0) uses Op1158 ----------
Op1158:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [115f] move.b (a7)+, ($3333,a0) uses Op115f ----------
Op115f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1160] move.b -(a0), ($3333,a0) uses Op1160 ----------
Op1160:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1167] move.b -(a7), ($3333,a0) uses Op1167 ----------
Op1167:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1168] move.b ($3333,a0), ($3333,a0) uses Op1168 ----------
Op1168:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1170] move.b ($33,a0,d3.w*2), ($3333,a0) uses Op1170 ----------
Op1170:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1178] move.b $3333.w, ($3333,a0) uses Op1178 ----------
Op1178:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1179] move.b $33333333.l, ($3333,a0) uses Op1179 ----------
Op1179:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [117a] move.b ($3333,pc), ($3333,a0); =3335 uses Op117a ----------
Op117a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [117b] move.b ($33,pc,d3.w*2), ($3333,a0); =35 uses Op117b ----------
Op117b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [117c] move.b #$33, ($3333,a0) uses Op117c ----------
Op117c:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1180] move.b d0, ($33,a0,d3.w*2) uses Op1180 ----------
Op1180:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsl #2]

  movs r2,r1,lsl #24
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1190] move.b (a0), ($33,a0,d3.w*2) uses Op1190 ----------
Op1190:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [119f] move.b (a7)+, ($33,a0,d3.w*2) uses Op119f ----------
Op119f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11a0] move.b -(a0), ($33,a0,d3.w*2) uses Op11a0 ----------
Op11a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11a7] move.b -(a7), ($33,a0,d3.w*2) uses Op11a7 ----------
Op11a7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11a8] move.b ($3333,a0), ($33,a0,d3.w*2) uses Op11a8 ----------
Op11a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11b0] move.b ($33,a0,d3.w*2), ($33,a0,d3.w*2) uses Op11b0 ----------
Op11b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11b8] move.b $3333.w, ($33,a0,d3.w*2) uses Op11b8 ----------
Op11b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11b9] move.b $33333333.l, ($33,a0,d3.w*2) uses Op11b9 ----------
Op11b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11ba] move.b ($3333,pc), ($33,a0,d3.w*2); =3335 uses Op11ba ----------
Op11ba:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11bb] move.b ($33,pc,d3.w*2), ($33,a0,d3.w*2); =35 uses Op11bb ----------
Op11bb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11bc] move.b #$33, ($33,a0,d3.w*2) uses Op11bc ----------
Op11bc:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11c0] move.b d0, $3333.w uses Op11c0 ----------
Op11c0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsl #2]

  movs r2,r1,lsl #24
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11d0] move.b (a0), $3333.w uses Op11d0 ----------
Op11d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11d8] move.b (a0)+, $3333.w uses Op11d8 ----------
Op11d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11df] move.b (a7)+, $3333.w uses Op11df ----------
Op11df:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11e0] move.b -(a0), $3333.w uses Op11e0 ----------
Op11e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11e7] move.b -(a7), $3333.w uses Op11e7 ----------
Op11e7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11e8] move.b ($3333,a0), $3333.w uses Op11e8 ----------
Op11e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11f0] move.b ($33,a0,d3.w*2), $3333.w uses Op11f0 ----------
Op11f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11f8] move.b $3333.w, $3333.w uses Op11f8 ----------
Op11f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11f9] move.b $33333333.l, $3333.w uses Op11f9 ----------
Op11f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11fa] move.b ($3333,pc), $3333.w; =3335 uses Op11fa ----------
Op11fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11fb] move.b ($33,pc,d3.w*2), $3333.w; =35 uses Op11fb ----------
Op11fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11fc] move.b #$33, $3333.w uses Op11fc ----------
Op11fc:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13c0] move.b d0, $33333333.l uses Op13c0 ----------
Op13c0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsl #2]

  movs r2,r1,lsl #24
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13d0] move.b (a0), $33333333.l uses Op13d0 ----------
Op13d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13d8] move.b (a0)+, $33333333.l uses Op13d8 ----------
Op13d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13df] move.b (a7)+, $33333333.l uses Op13df ----------
Op13df:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13e0] move.b -(a0), $33333333.l uses Op13e0 ----------
Op13e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13e7] move.b -(a7), $33333333.l uses Op13e7 ----------
Op13e7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13e8] move.b ($3333,a0), $33333333.l uses Op13e8 ----------
Op13e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13f0] move.b ($33,a0,d3.w*2), $33333333.l uses Op13f0 ----------
Op13f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13f8] move.b $3333.w, $33333333.l uses Op13f8 ----------
Op13f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13f9] move.b $33333333.l, $33333333.l uses Op13f9 ----------
Op13f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13fa] move.b ($3333,pc), $33333333.l; =3335 uses Op13fa ----------
Op13fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13fb] move.b ($33,pc,d3.w*2), $33333333.l; =35 uses Op13fb ----------
Op13fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13fc] move.b #$33, $33333333.l uses Op13fc ----------
Op13fc:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ec0] move.b d0, (a7)+ uses Op1ec0 ----------
Op1ec0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsl #2]

  movs r2,r1,lsl #24
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ed0] move.b (a0), (a7)+ uses Op1ed0 ----------
Op1ed0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ed8] move.b (a0)+, (a7)+ uses Op1ed8 ----------
Op1ed8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1edf] move.b (a7)+, (a7)+ uses Op1edf ----------
Op1edf:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ee0] move.b -(a0), (a7)+ uses Op1ee0 ----------
Op1ee0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ee7] move.b -(a7), (a7)+ uses Op1ee7 ----------
Op1ee7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ee8] move.b ($3333,a0), (a7)+ uses Op1ee8 ----------
Op1ee8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ef0] move.b ($33,a0,d3.w*2), (a7)+ uses Op1ef0 ----------
Op1ef0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ef8] move.b $3333.w, (a7)+ uses Op1ef8 ----------
Op1ef8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ef9] move.b $33333333.l, (a7)+ uses Op1ef9 ----------
Op1ef9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1efa] move.b ($3333,pc), (a7)+; =3335 uses Op1efa ----------
Op1efa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1efb] move.b ($33,pc,d3.w*2), (a7)+; =35 uses Op1efb ----------
Op1efb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1efc] move.b #$33, (a7)+ uses Op1efc ----------
Op1efc:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f00] move.b d0, -(a7) uses Op1f00 ----------
Op1f00:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsl #2]

  movs r2,r1,lsl #24
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f10] move.b (a0), -(a7) uses Op1f10 ----------
Op1f10:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f18] move.b (a0)+, -(a7) uses Op1f18 ----------
Op1f18:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f1f] move.b (a7)+, -(a7) uses Op1f1f ----------
Op1f1f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f20] move.b -(a0), -(a7) uses Op1f20 ----------
Op1f20:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f27] move.b -(a7), -(a7) uses Op1f27 ----------
Op1f27:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f28] move.b ($3333,a0), -(a7) uses Op1f28 ----------
Op1f28:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f30] move.b ($33,a0,d3.w*2), -(a7) uses Op1f30 ----------
Op1f30:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f38] move.b $3333.w, -(a7) uses Op1f38 ----------
Op1f38:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f39] move.b $33333333.l, -(a7) uses Op1f39 ----------
Op1f39:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f3a] move.b ($3333,pc), -(a7); =3335 uses Op1f3a ----------
Op1f3a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f3b] move.b ($33,pc,d3.w*2), -(a7); =35 uses Op1f3b ----------
Op1f3b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f3c] move.b #$33, -(a7) uses Op1f3c ----------
Op1f3c:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2000] move.l d0, d0 uses Op2000 ----------
Op2000:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2010] move.l (a0), d0 uses Op2010 ----------
Op2010:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2018] move.l (a0)+, d0 uses Op2018 ----------
Op2018:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2020] move.l -(a0), d0 uses Op2020 ----------
Op2020:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2028] move.l ($3333,a0), d0 uses Op2028 ----------
Op2028:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2030] move.l ($33,a0,d3.w*2), d0 uses Op2030 ----------
Op2030:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2039] move.l $33333333.l, d0 uses Op2039 ----------
Op2039:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [203a] move.l ($3333,pc), d0; =3335 uses Op203a ----------
Op203a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [203b] move.l ($33,pc,d3.w*2), d0; =35 uses Op203b ----------
Op203b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [203c] move.l #$33333333, d0 uses Op203c ----------
Op203c:
;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2040] movea.l d0, a0 uses Op2040 ----------
Op2040:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2050] movea.l (a0), a0 uses Op2050 ----------
Op2050:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2058] movea.l (a0)+, a0 uses Op2058 ----------
Op2058:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2060] movea.l -(a0), a0 uses Op2060 ----------
Op2060:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2068] movea.l ($3333,a0), a0 uses Op2068 ----------
Op2068:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2070] movea.l ($33,a0,d3.w*2), a0 uses Op2070 ----------
Op2070:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2078] movea.l $3333.w, a0 uses Op2078 ----------
Op2078:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2079] movea.l $33333333.l, a0 uses Op2079 ----------
Op2079:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [207a] movea.l ($3333,pc), a0; =3335 uses Op207a ----------
Op207a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [207b] movea.l ($33,pc,d3.w*2), a0; =35 uses Op207b ----------
Op207b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [207c] movea.l #$33333333, a0 uses Op207c ----------
Op207c:
;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2080] move.l d0, (a0) uses Op2080 ----------
Op2080:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2090] move.l (a0), (a0) uses Op2090 ----------
Op2090:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2098] move.l (a0)+, (a0) uses Op2098 ----------
Op2098:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20a0] move.l -(a0), (a0) uses Op20a0 ----------
Op20a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20a8] move.l ($3333,a0), (a0) uses Op20a8 ----------
Op20a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20b0] move.l ($33,a0,d3.w*2), (a0) uses Op20b0 ----------
Op20b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20b8] move.l $3333.w, (a0) uses Op20b8 ----------
Op20b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20b9] move.l $33333333.l, (a0) uses Op20b9 ----------
Op20b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20ba] move.l ($3333,pc), (a0); =3335 uses Op20ba ----------
Op20ba:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20bb] move.l ($33,pc,d3.w*2), (a0); =35 uses Op20bb ----------
Op20bb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20bc] move.l #$33333333, (a0) uses Op20bc ----------
Op20bc:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20d0] move.l (a0), (a0)+ uses Op20d0 ----------
Op20d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20d8] move.l (a0)+, (a0)+ uses Op20d8 ----------
Op20d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20e0] move.l -(a0), (a0)+ uses Op20e0 ----------
Op20e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20e8] move.l ($3333,a0), (a0)+ uses Op20e8 ----------
Op20e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20f0] move.l ($33,a0,d3.w*2), (a0)+ uses Op20f0 ----------
Op20f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20f8] move.l $3333.w, (a0)+ uses Op20f8 ----------
Op20f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20f9] move.l $33333333.l, (a0)+ uses Op20f9 ----------
Op20f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20fa] move.l ($3333,pc), (a0)+; =3335 uses Op20fa ----------
Op20fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20fb] move.l ($33,pc,d3.w*2), (a0)+; =35 uses Op20fb ----------
Op20fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20fc] move.l #$33333333, (a0)+ uses Op20fc ----------
Op20fc:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2100] move.l d0, -(a0) uses Op2100 ----------
Op2100:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2110] move.l (a0), -(a0) uses Op2110 ----------
Op2110:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2118] move.l (a0)+, -(a0) uses Op2118 ----------
Op2118:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2120] move.l -(a0), -(a0) uses Op2120 ----------
Op2120:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2128] move.l ($3333,a0), -(a0) uses Op2128 ----------
Op2128:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2130] move.l ($33,a0,d3.w*2), -(a0) uses Op2130 ----------
Op2130:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2138] move.l $3333.w, -(a0) uses Op2138 ----------
Op2138:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2139] move.l $33333333.l, -(a0) uses Op2139 ----------
Op2139:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [213a] move.l ($3333,pc), -(a0); =3335 uses Op213a ----------
Op213a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [213b] move.l ($33,pc,d3.w*2), -(a0); =35 uses Op213b ----------
Op213b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [213c] move.l #$33333333, -(a0) uses Op213c ----------
Op213c:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2140] move.l d0, ($3333,a0) uses Op2140 ----------
Op2140:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2150] move.l (a0), ($3333,a0) uses Op2150 ----------
Op2150:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2158] move.l (a0)+, ($3333,a0) uses Op2158 ----------
Op2158:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2160] move.l -(a0), ($3333,a0) uses Op2160 ----------
Op2160:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2168] move.l ($3333,a0), ($3333,a0) uses Op2168 ----------
Op2168:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2170] move.l ($33,a0,d3.w*2), ($3333,a0) uses Op2170 ----------
Op2170:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2178] move.l $3333.w, ($3333,a0) uses Op2178 ----------
Op2178:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2179] move.l $33333333.l, ($3333,a0) uses Op2179 ----------
Op2179:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [217a] move.l ($3333,pc), ($3333,a0); =3335 uses Op217a ----------
Op217a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [217b] move.l ($33,pc,d3.w*2), ($3333,a0); =35 uses Op217b ----------
Op217b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [217c] move.l #$33333333, ($3333,a0) uses Op217c ----------
Op217c:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2180] move.l d0, ($33,a0,d3.w*2) uses Op2180 ----------
Op2180:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2190] move.l (a0), ($33,a0,d3.w*2) uses Op2190 ----------
Op2190:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2198] move.l (a0)+, ($33,a0,d3.w*2) uses Op2198 ----------
Op2198:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21a0] move.l -(a0), ($33,a0,d3.w*2) uses Op21a0 ----------
Op21a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21a8] move.l ($3333,a0), ($33,a0,d3.w*2) uses Op21a8 ----------
Op21a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21b0] move.l ($33,a0,d3.w*2), ($33,a0,d3.w*2) uses Op21b0 ----------
Op21b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21b8] move.l $3333.w, ($33,a0,d3.w*2) uses Op21b8 ----------
Op21b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21b9] move.l $33333333.l, ($33,a0,d3.w*2) uses Op21b9 ----------
Op21b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21ba] move.l ($3333,pc), ($33,a0,d3.w*2); =3335 uses Op21ba ----------
Op21ba:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21bb] move.l ($33,pc,d3.w*2), ($33,a0,d3.w*2); =35 uses Op21bb ----------
Op21bb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21bc] move.l #$33333333, ($33,a0,d3.w*2) uses Op21bc ----------
Op21bc:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21c0] move.l d0, $3333.w uses Op21c0 ----------
Op21c0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21d0] move.l (a0), $3333.w uses Op21d0 ----------
Op21d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21d8] move.l (a0)+, $3333.w uses Op21d8 ----------
Op21d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21e0] move.l -(a0), $3333.w uses Op21e0 ----------
Op21e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21e8] move.l ($3333,a0), $3333.w uses Op21e8 ----------
Op21e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21f0] move.l ($33,a0,d3.w*2), $3333.w uses Op21f0 ----------
Op21f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21f8] move.l $3333.w, $3333.w uses Op21f8 ----------
Op21f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21f9] move.l $33333333.l, $3333.w uses Op21f9 ----------
Op21f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21fa] move.l ($3333,pc), $3333.w; =3335 uses Op21fa ----------
Op21fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21fb] move.l ($33,pc,d3.w*2), $3333.w; =35 uses Op21fb ----------
Op21fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21fc] move.l #$33333333, $3333.w uses Op21fc ----------
Op21fc:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23c0] move.l d0, $33333333.l uses Op23c0 ----------
Op23c0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23d0] move.l (a0), $33333333.l uses Op23d0 ----------
Op23d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23d8] move.l (a0)+, $33333333.l uses Op23d8 ----------
Op23d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23e0] move.l -(a0), $33333333.l uses Op23e0 ----------
Op23e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23e8] move.l ($3333,a0), $33333333.l uses Op23e8 ----------
Op23e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23f0] move.l ($33,a0,d3.w*2), $33333333.l uses Op23f0 ----------
Op23f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23f8] move.l $3333.w, $33333333.l uses Op23f8 ----------
Op23f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23f9] move.l $33333333.l, $33333333.l uses Op23f9 ----------
Op23f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23fa] move.l ($3333,pc), $33333333.l; =3335 uses Op23fa ----------
Op23fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23fb] move.l ($33,pc,d3.w*2), $33333333.l; =35 uses Op23fb ----------
Op23fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23fc] move.l #$33333333, $33333333.l uses Op23fc ----------
Op23fc:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ec0] move.l d0, (a7)+ uses Op2ec0 ----------
Op2ec0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ed0] move.l (a0), (a7)+ uses Op2ed0 ----------
Op2ed0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ed8] move.l (a0)+, (a7)+ uses Op2ed8 ----------
Op2ed8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ee0] move.l -(a0), (a7)+ uses Op2ee0 ----------
Op2ee0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ee8] move.l ($3333,a0), (a7)+ uses Op2ee8 ----------
Op2ee8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ef0] move.l ($33,a0,d3.w*2), (a7)+ uses Op2ef0 ----------
Op2ef0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ef8] move.l $3333.w, (a7)+ uses Op2ef8 ----------
Op2ef8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ef9] move.l $33333333.l, (a7)+ uses Op2ef9 ----------
Op2ef9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2efa] move.l ($3333,pc), (a7)+; =3335 uses Op2efa ----------
Op2efa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2efb] move.l ($33,pc,d3.w*2), (a7)+; =35 uses Op2efb ----------
Op2efb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2efc] move.l #$33333333, (a7)+ uses Op2efc ----------
Op2efc:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f00] move.l d0, -(a7) uses Op2f00 ----------
Op2f00:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f10] move.l (a0), -(a7) uses Op2f10 ----------
Op2f10:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f18] move.l (a0)+, -(a7) uses Op2f18 ----------
Op2f18:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f20] move.l -(a0), -(a7) uses Op2f20 ----------
Op2f20:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f28] move.l ($3333,a0), -(a7) uses Op2f28 ----------
Op2f28:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f30] move.l ($33,a0,d3.w*2), -(a7) uses Op2f30 ----------
Op2f30:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f38] move.l $3333.w, -(a7) uses Op2f38 ----------
Op2f38:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f39] move.l $33333333.l, -(a7) uses Op2f39 ----------
Op2f39:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f3a] move.l ($3333,pc), -(a7); =3335 uses Op2f3a ----------
Op2f3a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f3b] move.l ($33,pc,d3.w*2), -(a7); =35 uses Op2f3b ----------
Op2f3b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f3c] move.l #$33333333, -(a7) uses Op2f3c ----------
Op2f3c:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  bic r0,r8,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3010] move.w (a0), d0 uses Op3010 ----------
Op3010:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3020] move.w -(a0), d0 uses Op3020 ----------
Op3020:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3030] move.w ($33,a0,d3.w*2), d0 uses Op3030 ----------
Op3030:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3038] move.w $3333.w, d0 uses Op3038 ----------
Op3038:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [303a] move.w ($3333,pc), d0; =3335 uses Op303a ----------
Op303a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [303b] move.w ($33,pc,d3.w*2), d0; =35 uses Op303b ----------
Op303b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [303c] move.w #$3333, d0 uses Op303c ----------
Op303c:
;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:
  movs r1,r1,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3050] movea.w (a0), a0 uses Op3050 ----------
Op3050:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  sxth r1,r0 ;@ sign extend

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3058] movea.w (a0)+, a0 uses Op3058 ----------
Op3058:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  sxth r1,r0 ;@ sign extend

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3060] movea.w -(a0), a0 uses Op3060 ----------
Op3060:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  sxth r1,r0 ;@ sign extend

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3068] movea.w ($3333,a0), a0 uses Op3068 ----------
Op3068:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  sxth r1,r0 ;@ sign extend

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3070] movea.w ($33,a0,d3.w*2), a0 uses Op3070 ----------
Op3070:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  sxth r1,r0 ;@ sign extend

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3078] movea.w $3333.w, a0 uses Op3078 ----------
Op3078:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  sxth r1,r0 ;@ sign extend

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3079] movea.w $33333333.l, a0 uses Op3079 ----------
Op3079:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  sxth r1,r0 ;@ sign extend

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [307a] movea.w ($3333,pc), a0; =3335 uses Op307a ----------
Op307a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  sxth r1,r0 ;@ sign extend

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [307b] movea.w ($33,pc,d3.w*2), a0; =35 uses Op307b ----------
Op307b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  sxth r1,r0 ;@ sign extend

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [307c] movea.w #$3333, a0 uses Op307c ----------
Op307c:
;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3090] move.w (a0), (a0) uses Op3090 ----------
Op3090:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3098] move.w (a0)+, (a0) uses Op3098 ----------
Op3098:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30a0] move.w -(a0), (a0) uses Op30a0 ----------
Op30a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30a8] move.w ($3333,a0), (a0) uses Op30a8 ----------
Op30a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30b0] move.w ($33,a0,d3.w*2), (a0) uses Op30b0 ----------
Op30b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30b8] move.w $3333.w, (a0) uses Op30b8 ----------
Op30b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30b9] move.w $33333333.l, (a0) uses Op30b9 ----------
Op30b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30ba] move.w ($3333,pc), (a0); =3335 uses Op30ba ----------
Op30ba:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30bb] move.w ($33,pc,d3.w*2), (a0); =35 uses Op30bb ----------
Op30bb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30bc] move.w #$3333, (a0) uses Op30bc ----------
Op30bc:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:
  movs r1,r1,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30d8] move.w (a0)+, (a0)+ uses Op30d8 ----------
Op30d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30e0] move.w -(a0), (a0)+ uses Op30e0 ----------
Op30e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30e8] move.w ($3333,a0), (a0)+ uses Op30e8 ----------
Op30e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30f0] move.w ($33,a0,d3.w*2), (a0)+ uses Op30f0 ----------
Op30f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30f8] move.w $3333.w, (a0)+ uses Op30f8 ----------
Op30f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30f9] move.w $33333333.l, (a0)+ uses Op30f9 ----------
Op30f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30fa] move.w ($3333,pc), (a0)+; =3335 uses Op30fa ----------
Op30fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30fb] move.w ($33,pc,d3.w*2), (a0)+; =35 uses Op30fb ----------
Op30fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30fc] move.w #$3333, (a0)+ uses Op30fc ----------
Op30fc:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:
  movs r1,r1,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3100] move.w d0, -(a0) uses Op3100 ----------
Op3100:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrh r1,[r7,r1]

  movs r2,r1,lsl #16
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3110] move.w (a0), -(a0) uses Op3110 ----------
Op3110:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3118] move.w (a0)+, -(a0) uses Op3118 ----------
Op3118:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3120] move.w -(a0), -(a0) uses Op3120 ----------
Op3120:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3128] move.w ($3333,a0), -(a0) uses Op3128 ----------
Op3128:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3130] move.w ($33,a0,d3.w*2), -(a0) uses Op3130 ----------
Op3130:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3138] move.w $3333.w, -(a0) uses Op3138 ----------
Op3138:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3139] move.w $33333333.l, -(a0) uses Op3139 ----------
Op3139:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [313a] move.w ($3333,pc), -(a0); =3335 uses Op313a ----------
Op313a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [313b] move.w ($33,pc,d3.w*2), -(a0); =35 uses Op313b ----------
Op313b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [313c] move.w #$3333, -(a0) uses Op313c ----------
Op313c:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:
  movs r1,r1,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3140] move.w d0, ($3333,a0) uses Op3140 ----------
Op3140:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrh r1,[r7,r1]

  movs r2,r1,lsl #16
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3150] move.w (a0), ($3333,a0) uses Op3150 ----------
Op3150:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3158] move.w (a0)+, ($3333,a0) uses Op3158 ----------
Op3158:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3160] move.w -(a0), ($3333,a0) uses Op3160 ----------
Op3160:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3168] move.w ($3333,a0), ($3333,a0) uses Op3168 ----------
Op3168:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3170] move.w ($33,a0,d3.w*2), ($3333,a0) uses Op3170 ----------
Op3170:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3178] move.w $3333.w, ($3333,a0) uses Op3178 ----------
Op3178:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3179] move.w $33333333.l, ($3333,a0) uses Op3179 ----------
Op3179:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [317a] move.w ($3333,pc), ($3333,a0); =3335 uses Op317a ----------
Op317a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [317b] move.w ($33,pc,d3.w*2), ($3333,a0); =35 uses Op317b ----------
Op317b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [317c] move.w #$3333, ($3333,a0) uses Op317c ----------
Op317c:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:
  movs r1,r1,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3190] move.w (a0), ($33,a0,d3.w*2) uses Op3190 ----------
Op3190:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3198] move.w (a0)+, ($33,a0,d3.w*2) uses Op3198 ----------
Op3198:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31a0] move.w -(a0), ($33,a0,d3.w*2) uses Op31a0 ----------
Op31a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31a8] move.w ($3333,a0), ($33,a0,d3.w*2) uses Op31a8 ----------
Op31a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31b0] move.w ($33,a0,d3.w*2), ($33,a0,d3.w*2) uses Op31b0 ----------
Op31b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31b8] move.w $3333.w, ($33,a0,d3.w*2) uses Op31b8 ----------
Op31b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31b9] move.w $33333333.l, ($33,a0,d3.w*2) uses Op31b9 ----------
Op31b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31ba] move.w ($3333,pc), ($33,a0,d3.w*2); =3335 uses Op31ba ----------
Op31ba:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31bb] move.w ($33,pc,d3.w*2), ($33,a0,d3.w*2); =35 uses Op31bb ----------
Op31bb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31bc] move.w #$3333, ($33,a0,d3.w*2) uses Op31bc ----------
Op31bc:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:
  movs r1,r1,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31c0] move.w d0, $3333.w uses Op31c0 ----------
Op31c0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrh r1,[r7,r1]

  movs r2,r1,lsl #16
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31d0] move.w (a0), $3333.w uses Op31d0 ----------
Op31d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31d8] move.w (a0)+, $3333.w uses Op31d8 ----------
Op31d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31e0] move.w -(a0), $3333.w uses Op31e0 ----------
Op31e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31e8] move.w ($3333,a0), $3333.w uses Op31e8 ----------
Op31e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31f0] move.w ($33,a0,d3.w*2), $3333.w uses Op31f0 ----------
Op31f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31f8] move.w $3333.w, $3333.w uses Op31f8 ----------
Op31f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31f9] move.w $33333333.l, $3333.w uses Op31f9 ----------
Op31f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31fa] move.w ($3333,pc), $3333.w; =3335 uses Op31fa ----------
Op31fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31fb] move.w ($33,pc,d3.w*2), $3333.w; =35 uses Op31fb ----------
Op31fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31fc] move.w #$3333, $3333.w uses Op31fc ----------
Op31fc:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:
  movs r1,r1,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33c0] move.w d0, $33333333.l uses Op33c0 ----------
Op33c0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrh r1,[r7,r1]

  movs r2,r1,lsl #16
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33d0] move.w (a0), $33333333.l uses Op33d0 ----------
Op33d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33e0] move.w -(a0), $33333333.l uses Op33e0 ----------
Op33e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33e8] move.w ($3333,a0), $33333333.l uses Op33e8 ----------
Op33e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33f0] move.w ($33,a0,d3.w*2), $33333333.l uses Op33f0 ----------
Op33f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33f8] move.w $3333.w, $33333333.l uses Op33f8 ----------
Op33f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33f9] move.w $33333333.l, $33333333.l uses Op33f9 ----------
Op33f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33fa] move.w ($3333,pc), $33333333.l; =3335 uses Op33fa ----------
Op33fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33fb] move.w ($33,pc,d3.w*2), $33333333.l; =35 uses Op33fb ----------
Op33fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33fc] move.w #$3333, $33333333.l uses Op33fc ----------
Op33fc:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:
  movs r1,r1,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ec0] move.w d0, (a7)+ uses Op3ec0 ----------
Op3ec0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrh r1,[r7,r1]

  movs r2,r1,lsl #16
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ed0] move.w (a0), (a7)+ uses Op3ed0 ----------
Op3ed0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ed8] move.w (a0)+, (a7)+ uses Op3ed8 ----------
Op3ed8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ee0] move.w -(a0), (a7)+ uses Op3ee0 ----------
Op3ee0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ee8] move.w ($3333,a0), (a7)+ uses Op3ee8 ----------
Op3ee8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ef0] move.w ($33,a0,d3.w*2), (a7)+ uses Op3ef0 ----------
Op3ef0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ef8] move.w $3333.w, (a7)+ uses Op3ef8 ----------
Op3ef8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ef9] move.w $33333333.l, (a7)+ uses Op3ef9 ----------
Op3ef9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3efa] move.w ($3333,pc), (a7)+; =3335 uses Op3efa ----------
Op3efa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3efb] move.w ($33,pc,d3.w*2), (a7)+; =35 uses Op3efb ----------
Op3efb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3efc] move.w #$3333, (a7)+ uses Op3efc ----------
Op3efc:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:
  movs r1,r1,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f00] move.w d0, -(a7) uses Op3f00 ----------
Op3f00:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrh r1,[r7,r1]

  movs r2,r1,lsl #16
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f10] move.w (a0), -(a7) uses Op3f10 ----------
Op3f10:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f18] move.w (a0)+, -(a7) uses Op3f18 ----------
Op3f18:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f20] move.w -(a0), -(a7) uses Op3f20 ----------
Op3f20:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f28] move.w ($3333,a0), -(a7) uses Op3f28 ----------
Op3f28:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f30] move.w ($33,a0,d3.w*2), -(a7) uses Op3f30 ----------
Op3f30:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f38] move.w $3333.w, -(a7) uses Op3f38 ----------
Op3f38:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f39] move.w $33333333.l, -(a7) uses Op3f39 ----------
Op3f39:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f3a] move.w ($3333,pc), -(a7); =3335 uses Op3f3a ----------
Op3f3a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f3b] move.w ($33,pc,d3.w*2), -(a7); =35 uses Op3f3b ----------
Op3f3b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f3c] move.w #$3333, -(a7) uses Op3f3c ----------
Op3f3c:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:
  movs r1,r1,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #16
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4000] negx.b d0 uses Op4000 ----------
Op4000:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4010] negx.b (a0) uses Op4010 ----------
Op4010:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4018] negx.b (a0)+ uses Op4018 ----------
Op4018:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [401f] negx.b (a7)+ uses Op401f ----------
Op401f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4020] negx.b -(a0) uses Op4020 ----------
Op4020:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4027] negx.b -(a7) uses Op4027 ----------
Op4027:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4028] negx.b ($3333,a0) uses Op4028 ----------
Op4028:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4030] negx.b ($33,a0,d3.w*2) uses Op4030 ----------
Op4030:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4038] negx.b $3333.w uses Op4038 ----------
Op4038:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4039] negx.b $33333333.l uses Op4039 ----------
Op4039:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4040] negx.w d0 uses Op4040 ----------
Op4040:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4050] negx.w (a0) uses Op4050 ----------
Op4050:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4058] negx.w (a0)+ uses Op4058 ----------
Op4058:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4060] negx.w -(a0) uses Op4060 ----------
Op4060:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4068] negx.w ($3333,a0) uses Op4068 ----------
Op4068:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4070] negx.w ($33,a0,d3.w*2) uses Op4070 ----------
Op4070:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4078] negx.w $3333.w uses Op4078 ----------
Op4078:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4079] negx.w $33333333.l uses Op4079 ----------
Op4079:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4080] negx.l d0 uses Op4080 ----------
Op4080:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4090] negx.l (a0) uses Op4090 ----------
Op4090:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4098] negx.l (a0)+ uses Op4098 ----------
Op4098:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40a0] negx.l -(a0) uses Op40a0 ----------
Op40a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40a8] negx.l ($3333,a0) uses Op40a8 ----------
Op40a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40b0] negx.l ($33,a0,d3.w*2) uses Op40b0 ----------
Op40b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40b8] negx.l $3333.w uses Op40b8 ----------
Op40b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40b9] negx.l $33333333.l uses Op40b9 ----------
Op40b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40c0] move sr, d0 uses Op40c0 ----------
Op40c0:
  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,lsr #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40d0] move sr, (a0) uses Op40d0 ----------
Op40d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,lsr #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40d8] move sr, (a0)+ uses Op40d8 ----------
Op40d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,lsr #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  uxth r1,r1 ;@ zero extend
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40e0] move sr, -(a0) uses Op40e0 ----------
Op40e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,lsr #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40e8] move sr, ($3333,a0) uses Op40e8 ----------
Op40e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,lsr #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40f0] move sr, ($33,a0,d3.w*2) uses Op40f0 ----------
Op40f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,lsr #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  uxth r1,r1 ;@ zero extend
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40f8] move sr, $3333.w uses Op40f8 ----------
Op40f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,lsr #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  uxth r1,r1 ;@ zero extend
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40f9] move sr, $33333333.l uses Op40f9 ----------
Op40f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,lsr #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  uxth r1,r1 ;@ zero extend
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4180] chk d0, a0 uses Op4180 ----------
Op4180:
;@ Get value into r0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap4180
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap4180
;@ old N remains
  orr r10,r10,r3
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap4180: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#50 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4190] chk (a0), a0 uses Op4190 ----------
Op4190:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get value into r0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap4190
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap4190
;@ old N remains
  orr r10,r10,r3
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap4190: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#54 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4198] chk (a0)+, a0 uses Op4198 ----------
Op4198:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get value into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap4198
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap4198
;@ old N remains
  orr r10,r10,r3
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap4198: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#54 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41a0] chk -(a0), a0 uses Op41a0 ----------
Op41a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get value into r0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap41a0
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap41a0
;@ old N remains
  orr r10,r10,r3
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41a0: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#56 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41a8] chk ($3333,a0), a0 uses Op41a8 ----------
Op41a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get value into r0:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap41a8
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap41a8
;@ old N remains
  orr r10,r10,r3
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41a8: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41b0] chk ($33,a0,d3.w*2), a0 uses Op41b0 ----------
Op41b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap41b0
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap41b0
;@ old N remains
  orr r10,r10,r3
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41b0: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#60 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41b8] chk $3333.w, a0 uses Op41b8 ----------
Op41b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get value into r0:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap41b8
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap41b8
;@ old N remains
  orr r10,r10,r3
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41b8: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41b9] chk $33333333.l, a0 uses Op41b9 ----------
Op41b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get value into r0:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap41b9
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap41b9
;@ old N remains
  orr r10,r10,r3
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41b9: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41ba] chk ($3333,pc), a0; =3335 uses Op41ba ----------
Op41ba:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get value into r0:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap41ba
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap41ba
;@ old N remains
  orr r10,r10,r3
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41ba: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41bb] chk ($33,pc,d3.w*2), a0; =35 uses Op41bb ----------
Op41bb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap41bb
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap41bb
;@ old N remains
  orr r10,r10,r3
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41bb: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#60 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41bc] chk #$33, a0 uses Op41bc ----------
Op41bc:
;@ Get value into r0:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap41bc
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap41bc
;@ old N remains
  orr r10,r10,r3
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41bc: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#54 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41d0] lea (a0), a0 uses Op41d0 ----------
Op41d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r1:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r1,[r7,r2,lsl #2]
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41e8] lea ($3333,a0), a0 uses Op41e8 ----------
Op41e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r1:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r1,r0,r2 ;@ Add on offset
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41f8] lea $3333.w, a0 uses Op41f8 ----------
Op41f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch Absolute Short address
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41f9] lea $33333333.l, a0 uses Op41f9 ----------
Op41f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r1:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r1,r0,r2,lsl #16
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41fa] lea ($3333,pc), a0; =3335 uses Op41fa ----------
Op41fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r1:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r1,r2,r0 ;@ ($nn,PC)
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41fb] lea ($33,pc,d3.w*2), a0; =35 uses Op41fb ----------
Op41fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r1:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r1,r2,r0 ;@ r1=Disp+PC+Rn
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4200] clr.b d0 uses Op4200 ----------
Op4200:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4210] clr.b (a0) uses Op4210 ----------
Op4210:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4218] clr.b (a0)+ uses Op4218 ----------
Op4218:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [421f] clr.b (a7)+ uses Op421f ----------
Op421f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4220] clr.b -(a0) uses Op4220 ----------
Op4220:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4227] clr.b -(a7) uses Op4227 ----------
Op4227:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4228] clr.b ($3333,a0) uses Op4228 ----------
Op4228:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4230] clr.b ($33,a0,d3.w*2) uses Op4230 ----------
Op4230:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4238] clr.b $3333.w uses Op4238 ----------
Op4238:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4239] clr.b $33333333.l uses Op4239 ----------
Op4239:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4240] clr.w d0 uses Op4240 ----------
Op4240:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4250] clr.w (a0) uses Op4250 ----------
Op4250:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4258] clr.w (a0)+ uses Op4258 ----------
Op4258:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  uxth r1,r1 ;@ zero extend
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4260] clr.w -(a0) uses Op4260 ----------
Op4260:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4268] clr.w ($3333,a0) uses Op4268 ----------
Op4268:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4270] clr.w ($33,a0,d3.w*2) uses Op4270 ----------
Op4270:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  uxth r1,r1 ;@ zero extend
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4278] clr.w $3333.w uses Op4278 ----------
Op4278:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  uxth r1,r1 ;@ zero extend
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4279] clr.w $33333333.l uses Op4279 ----------
Op4279:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  uxth r1,r1 ;@ zero extend
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4280] clr.l d0 uses Op4280 ----------
Op4280:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4290] clr.l (a0) uses Op4290 ----------
Op4290:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4298] clr.l (a0)+ uses Op4298 ----------
Op4298:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42a0] clr.l -(a0) uses Op42a0 ----------
Op42a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42a8] clr.l ($3333,a0) uses Op42a8 ----------
Op42a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42b0] clr.l ($33,a0,d3.w*2) uses Op42b0 ----------
Op42b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42b8] clr.l $3333.w uses Op42b8 ----------
Op42b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42b9] clr.l $33333333.l uses Op42b9 ----------
Op42b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4400] neg.b d0 uses Op4400 ----------
Op4400:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4410] neg.b (a0) uses Op4410 ----------
Op4410:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4418] neg.b (a0)+ uses Op4418 ----------
Op4418:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [441f] neg.b (a7)+ uses Op441f ----------
Op441f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4420] neg.b -(a0) uses Op4420 ----------
Op4420:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4427] neg.b -(a7) uses Op4427 ----------
Op4427:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4428] neg.b ($3333,a0) uses Op4428 ----------
Op4428:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4430] neg.b ($33,a0,d3.w*2) uses Op4430 ----------
Op4430:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4438] neg.b $3333.w uses Op4438 ----------
Op4438:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4439] neg.b $33333333.l uses Op4439 ----------
Op4439:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4440] neg.w d0 uses Op4440 ----------
Op4440:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4450] neg.w (a0) uses Op4450 ----------
Op4450:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4458] neg.w (a0)+ uses Op4458 ----------
Op4458:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4460] neg.w -(a0) uses Op4460 ----------
Op4460:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4468] neg.w ($3333,a0) uses Op4468 ----------
Op4468:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4470] neg.w ($33,a0,d3.w*2) uses Op4470 ----------
Op4470:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4478] neg.w $3333.w uses Op4478 ----------
Op4478:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4479] neg.w $33333333.l uses Op4479 ----------
Op4479:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4480] neg.l d0 uses Op4480 ----------
Op4480:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Neg:
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4490] neg.l (a0) uses Op4490 ----------
Op4490:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4498] neg.l (a0)+ uses Op4498 ----------
Op4498:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44a0] neg.l -(a0) uses Op44a0 ----------
Op44a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44a8] neg.l ($3333,a0) uses Op44a8 ----------
Op44a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44b0] neg.l ($33,a0,d3.w*2) uses Op44b0 ----------
Op44b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44b8] neg.l $3333.w uses Op44b8 ----------
Op44b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44b9] neg.l $33333333.l uses Op44b9 ----------
Op44b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44c0] move d0, ccr uses Op44c0 ----------
Op44c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44d0] move (a0), ccr uses Op44d0 ----------
Op44d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44d8] move (a0)+, ccr uses Op44d8 ----------
Op44d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44e0] move -(a0), ccr uses Op44e0 ----------
Op44e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44e8] move ($3333,a0), ccr uses Op44e8 ----------
Op44e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44f0] move ($33,a0,d3.w*2), ccr uses Op44f0 ----------
Op44f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44f8] move $3333.w, ccr uses Op44f8 ----------
Op44f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44f9] move $33333333.l, ccr uses Op44f9 ----------
Op44f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44fa] move ($3333,pc), ccr; =3335 uses Op44fa ----------
Op44fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44fb] move ($33,pc,d3.w*2), ccr; =35 uses Op44fb ----------
Op44fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44fc] move #$3333, ccr uses Op44fc ----------
Op44fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4600] not.b d0 uses Op4600 ----------
Op4600:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Not:
  mov r0,r0,asl #24
  mvns r1,r0,asr #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4610] not.b (a0) uses Op4610 ----------
Op4610:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvns r1,r0,asr #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4618] not.b (a0)+ uses Op4618 ----------
Op4618:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvns r1,r0,asr #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [461f] not.b (a7)+ uses Op461f ----------
Op461f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvns r1,r0,asr #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4620] not.b -(a0) uses Op4620 ----------
Op4620:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvns r1,r0,asr #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4627] not.b -(a7) uses Op4627 ----------
Op4627:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvns r1,r0,asr #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4628] not.b ($3333,a0) uses Op4628 ----------
Op4628:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvns r1,r0,asr #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4630] not.b ($33,a0,d3.w*2) uses Op4630 ----------
Op4630:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvns r1,r0,asr #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4638] not.b $3333.w uses Op4638 ----------
Op4638:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvns r1,r0,asr #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4639] not.b $33333333.l uses Op4639 ----------
Op4639:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvns r1,r0,asr #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4640] not.w d0 uses Op4640 ----------
Op4640:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

;@ Not:
  mov r0,r0,asl #16
  mvns r1,r0,asr #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4650] not.w (a0) uses Op4650 ----------
Op4650:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvns r1,r0,asr #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4658] not.w (a0)+ uses Op4658 ----------
Op4658:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvns r1,r0,asr #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4660] not.w -(a0) uses Op4660 ----------
Op4660:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvns r1,r0,asr #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4668] not.w ($3333,a0) uses Op4668 ----------
Op4668:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvns r1,r0,asr #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4670] not.w ($33,a0,d3.w*2) uses Op4670 ----------
Op4670:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvns r1,r0,asr #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4678] not.w $3333.w uses Op4678 ----------
Op4678:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvns r1,r0,asr #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4679] not.w $33333333.l uses Op4679 ----------
Op4679:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvns r1,r0,asr #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4680] not.l d0 uses Op4680 ----------
Op4680:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Not:
  mvns r1,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4690] not.l (a0) uses Op4690 ----------
Op4690:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Not:
  mvns r1,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4698] not.l (a0)+ uses Op4698 ----------
Op4698:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Not:
  mvns r1,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46a0] not.l -(a0) uses Op46a0 ----------
Op46a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Not:
  mvns r1,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46a8] not.l ($3333,a0) uses Op46a8 ----------
Op46a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Not:
  mvns r1,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46b0] not.l ($33,a0,d3.w*2) uses Op46b0 ----------
Op46b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Not:
  mvns r1,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46b8] not.l $3333.w uses Op46b8 ----------
Op46b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Not:
  mvns r1,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46b9] not.l $33333333.l uses Op46b9 ----------
Op46b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Not:
  mvns r1,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46c0] move d0, sr uses Op46c0 ----------
Op46c0:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46c0
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46c0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#12 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [46d0] move (a0), sr uses Op46d0 ----------
Op46d0:
  ldr r11,[r7,#0x44] ;@ Get SR high
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46d0
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46d0:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#16 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [46d8] move (a0)+, sr uses Op46d8 ----------
Op46d8:
  ldr r11,[r7,#0x44] ;@ Get SR high
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46d8
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46d8:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#16 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [46e0] move -(a0), sr uses Op46e0 ----------
Op46e0:
  ldr r11,[r7,#0x44] ;@ Get SR high
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46e0
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46e0:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#18 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [46e8] move ($3333,a0), sr uses Op46e8 ----------
Op46e8:
  ldr r11,[r7,#0x44] ;@ Get SR high
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46e8
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46e8:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#20 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [46f0] move ($33,a0,d3.w*2), sr uses Op46f0 ----------
Op46f0:
  ldr r11,[r7,#0x44] ;@ Get SR high
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46f0
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46f0:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#22 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [46f8] move $3333.w, sr uses Op46f8 ----------
Op46f8:
  ldr r11,[r7,#0x44] ;@ Get SR high
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46f8
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46f8:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#20 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [46f9] move $33333333.l, sr uses Op46f9 ----------
Op46f9:
  ldr r11,[r7,#0x44] ;@ Get SR high
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46f9
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46f9:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#24 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [46fa] move ($3333,pc), sr; =3335 uses Op46fa ----------
Op46fa:
  ldr r11,[r7,#0x44] ;@ Get SR high
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46fa
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46fa:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#20 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [46fb] move ($33,pc,d3.w*2), sr; =35 uses Op46fb ----------
Op46fb:
  ldr r11,[r7,#0x44] ;@ Get SR high
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46fb
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46fb:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#22 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [46fc] move #$3333, sr uses Op46fc ----------
Op46fc:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46fc
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46fc:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#16 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [4800] nbcd d0 uses Op4800 ----------
Op4800:
;@ EaCalc : Get register index into r6:
  and r6,r8,#0x000f
;@ EaRead : Read register[r6] into r0:
  ldr r0,[r7,r6,lsl #2]

  ldr r2,[r7,#0x4c]
  bic r10,r10,#0xb0000000 ;@ clear all flags, except Z
  mov r0,r0,asl #24
  and r2,r2,#0x20000000
  add r2,r0,r2,lsr #5 ;@ add X
  rsb r11,r2,#0x9a000000 ;@ do arithmetic
  cmp r11,#0x9a000000
  beq finish4800

  mvn r3,r11,lsr #31 ;@ Undefined V behavior
  and r2,r11,#0x0f000000
  cmp r2,#0x0a000000
  andeq r11,r11,#0xf0000000
  addeq r11,r11,#0x10000000
  and r3,r3,r11,lsr #31 ;@ Undefined V behavior part II
  movs r1,r11,asr #24
  bicne r10,r10,#0x40000000 ;@ Z
  orr r10,r10,r3,lsl #28 ;@ save V
  orr r10,r10,#0x20000000 ;@ C

;@ EaWrite: r1 into register[r6]:
  strb r1,[r7,r6,lsl #2]

finish4800:
  tst r11,r11
  orrmi r10,r10,#0x80000000 ;@ N
  str r10,[r7,#0x4c] ;@ Save X

  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4810] nbcd (a0) uses Op4810 ----------
Op4810:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r6,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r6) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r6,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r10,r10,#0xb0000000 ;@ clear all flags, except Z
  mov r0,r0,asl #24
  and r2,r2,#0x20000000
  add r2,r0,r2,lsr #5 ;@ add X
  rsb r11,r2,#0x9a000000 ;@ do arithmetic
  cmp r11,#0x9a000000
  beq finish4810

  mvn r3,r11,lsr #31 ;@ Undefined V behavior
  and r2,r11,#0x0f000000
  cmp r2,#0x0a000000
  andeq r11,r11,#0xf0000000
  addeq r11,r11,#0x10000000
  and r3,r3,r11,lsr #31 ;@ Undefined V behavior part II
  movs r1,r11,asr #24
  bicne r10,r10,#0x40000000 ;@ Z
  orr r10,r10,r3,lsl #28 ;@ save V
  orr r10,r10,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '(a0)' (address in r6):
  and r1,r1,#0xff
  bic r0,r6,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

finish4810:
  tst r11,r11
  orrmi r10,r10,#0x80000000 ;@ N
  str r10,[r7,#0x4c] ;@ Save X

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4818] nbcd (a0)+ uses Op4818 ----------
Op4818:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r6:
  and r2,r8,#0x000f
  ldr r6,[r7,r2,lsl #2]
  add r3,r6,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r6) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r6,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r10,r10,#0xb0000000 ;@ clear all flags, except Z
  mov r0,r0,asl #24
  and r2,r2,#0x20000000
  add r2,r0,r2,lsr #5 ;@ add X
  rsb r11,r2,#0x9a000000 ;@ do arithmetic
  cmp r11,#0x9a000000
  beq finish4818

  mvn r3,r11,lsr #31 ;@ Undefined V behavior
  and r2,r11,#0x0f000000
  cmp r2,#0x0a000000
  andeq r11,r11,#0xf0000000
  addeq r11,r11,#0x10000000
  and r3,r3,r11,lsr #31 ;@ Undefined V behavior part II
  movs r1,r11,asr #24
  bicne r10,r10,#0x40000000 ;@ Z
  orr r10,r10,r3,lsl #28 ;@ save V
  orr r10,r10,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '(a0)+' (address in r6):
  and r1,r1,#0xff
  bic r0,r6,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

finish4818:
  tst r11,r11
  orrmi r10,r10,#0x80000000 ;@ N
  str r10,[r7,#0x4c] ;@ Save X

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [481f] nbcd (a7)+ uses Op481f ----------
Op481f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r6:
  ldr r6,[r7,#0x3c] ;@ A7
  add r3,r6,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r6) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r6,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r10,r10,#0xb0000000 ;@ clear all flags, except Z
  mov r0,r0,asl #24
  and r2,r2,#0x20000000
  add r2,r0,r2,lsr #5 ;@ add X
  rsb r11,r2,#0x9a000000 ;@ do arithmetic
  cmp r11,#0x9a000000
  beq finish481f

  mvn r3,r11,lsr #31 ;@ Undefined V behavior
  and r2,r11,#0x0f000000
  cmp r2,#0x0a000000
  andeq r11,r11,#0xf0000000
  addeq r11,r11,#0x10000000
  and r3,r3,r11,lsr #31 ;@ Undefined V behavior part II
  movs r1,r11,asr #24
  bicne r10,r10,#0x40000000 ;@ Z
  orr r10,r10,r3,lsl #28 ;@ save V
  orr r10,r10,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '(a7)+' (address in r6):
  and r1,r1,#0xff
  bic r0,r6,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

finish481f:
  tst r11,r11
  orrmi r10,r10,#0x80000000 ;@ N
  str r10,[r7,#0x4c] ;@ Save X

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4820] nbcd -(a0) uses Op4820 ----------
Op4820:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r6:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r6,[r7,r2,lsl #2]
  sub r6,r6,#1 ;@ Pre-decrement An
  str r6,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r6) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r6,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r10,r10,#0xb0000000 ;@ clear all flags, except Z
  mov r0,r0,asl #24
  and r2,r2,#0x20000000
  add r2,r0,r2,lsr #5 ;@ add X
  rsb r11,r2,#0x9a000000 ;@ do arithmetic
  cmp r11,#0x9a000000
  beq finish4820

  mvn r3,r11,lsr #31 ;@ Undefined V behavior
  and r2,r11,#0x0f000000
  cmp r2,#0x0a000000
  andeq r11,r11,#0xf0000000
  addeq r11,r11,#0x10000000
  and r3,r3,r11,lsr #31 ;@ Undefined V behavior part II
  movs r1,r11,asr #24
  bicne r10,r10,#0x40000000 ;@ Z
  orr r10,r10,r3,lsl #28 ;@ save V
  orr r10,r10,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '-(a0)' (address in r6):
  and r1,r1,#0xff
  bic r0,r6,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

finish4820:
  tst r11,r11
  orrmi r10,r10,#0x80000000 ;@ N
  str r10,[r7,#0x4c] ;@ Save X

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4827] nbcd -(a7) uses Op4827 ----------
Op4827:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r6:
  ldr r6,[r7,#0x3c] ;@ A7
  sub r6,r6,#2 ;@ Pre-decrement An
  str r6,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r6) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r6,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r10,r10,#0xb0000000 ;@ clear all flags, except Z
  mov r0,r0,asl #24
  and r2,r2,#0x20000000
  add r2,r0,r2,lsr #5 ;@ add X
  rsb r11,r2,#0x9a000000 ;@ do arithmetic
  cmp r11,#0x9a000000
  beq finish4827

  mvn r3,r11,lsr #31 ;@ Undefined V behavior
  and r2,r11,#0x0f000000
  cmp r2,#0x0a000000
  andeq r11,r11,#0xf0000000
  addeq r11,r11,#0x10000000
  and r3,r3,r11,lsr #31 ;@ Undefined V behavior part II
  movs r1,r11,asr #24
  bicne r10,r10,#0x40000000 ;@ Z
  orr r10,r10,r3,lsl #28 ;@ save V
  orr r10,r10,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '-(a7)' (address in r6):
  and r1,r1,#0xff
  bic r0,r6,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

finish4827:
  tst r11,r11
  orrmi r10,r10,#0x80000000 ;@ N
  str r10,[r7,#0x4c] ;@ Save X

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4828] nbcd ($3333,a0) uses Op4828 ----------
Op4828:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r6:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r6,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r6) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r6,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r10,r10,#0xb0000000 ;@ clear all flags, except Z
  mov r0,r0,asl #24
  and r2,r2,#0x20000000
  add r2,r0,r2,lsr #5 ;@ add X
  rsb r11,r2,#0x9a000000 ;@ do arithmetic
  cmp r11,#0x9a000000
  beq finish4828

  mvn r3,r11,lsr #31 ;@ Undefined V behavior
  and r2,r11,#0x0f000000
  cmp r2,#0x0a000000
  andeq r11,r11,#0xf0000000
  addeq r11,r11,#0x10000000
  and r3,r3,r11,lsr #31 ;@ Undefined V behavior part II
  movs r1,r11,asr #24
  bicne r10,r10,#0x40000000 ;@ Z
  orr r10,r10,r3,lsl #28 ;@ save V
  orr r10,r10,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '($3333,a0)' (address in r6):
  and r1,r1,#0xff
  bic r0,r6,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

finish4828:
  tst r11,r11
  orrmi r10,r10,#0x80000000 ;@ N
  str r10,[r7,#0x4c] ;@ Save X

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4830] nbcd ($33,a0,d3.w*2) uses Op4830 ----------
Op4830:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r6:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r6,r2,r3 ;@ r6=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r6) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r6,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r10,r10,#0xb0000000 ;@ clear all flags, except Z
  mov r0,r0,asl #24
  and r2,r2,#0x20000000
  add r2,r0,r2,lsr #5 ;@ add X
  rsb r11,r2,#0x9a000000 ;@ do arithmetic
  cmp r11,#0x9a000000
  beq finish4830

  mvn r3,r11,lsr #31 ;@ Undefined V behavior
  and r2,r11,#0x0f000000
  cmp r2,#0x0a000000
  andeq r11,r11,#0xf0000000
  addeq r11,r11,#0x10000000
  and r3,r3,r11,lsr #31 ;@ Undefined V behavior part II
  movs r1,r11,asr #24
  bicne r10,r10,#0x40000000 ;@ Z
  orr r10,r10,r3,lsl #28 ;@ save V
  orr r10,r10,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r6):
  and r1,r1,#0xff
  bic r0,r6,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

finish4830:
  tst r11,r11
  orrmi r10,r10,#0x80000000 ;@ N
  str r10,[r7,#0x4c] ;@ Save X

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4838] nbcd $3333.w uses Op4838 ----------
Op4838:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r6:
  ldrsh r6,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r6) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r6,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r10,r10,#0xb0000000 ;@ clear all flags, except Z
  mov r0,r0,asl #24
  and r2,r2,#0x20000000
  add r2,r0,r2,lsr #5 ;@ add X
  rsb r11,r2,#0x9a000000 ;@ do arithmetic
  cmp r11,#0x9a000000
  beq finish4838

  mvn r3,r11,lsr #31 ;@ Undefined V behavior
  and r2,r11,#0x0f000000
  cmp r2,#0x0a000000
  andeq r11,r11,#0xf0000000
  addeq r11,r11,#0x10000000
  and r3,r3,r11,lsr #31 ;@ Undefined V behavior part II
  movs r1,r11,asr #24
  bicne r10,r10,#0x40000000 ;@ Z
  orr r10,r10,r3,lsl #28 ;@ save V
  orr r10,r10,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '$3333.w' (address in r6):
  and r1,r1,#0xff
  bic r0,r6,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

finish4838:
  tst r11,r11
  orrmi r10,r10,#0x80000000 ;@ N
  str r10,[r7,#0x4c] ;@ Save X

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4839] nbcd $33333333.l uses Op4839 ----------
Op4839:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r6:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r6,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r6) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r6,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r10,r10,#0xb0000000 ;@ clear all flags, except Z
  mov r0,r0,asl #24
  and r2,r2,#0x20000000
  add r2,r0,r2,lsr #5 ;@ add X
  rsb r11,r2,#0x9a000000 ;@ do arithmetic
  cmp r11,#0x9a000000
  beq finish4839

  mvn r3,r11,lsr #31 ;@ Undefined V behavior
  and r2,r11,#0x0f000000
  cmp r2,#0x0a000000
  andeq r11,r11,#0xf0000000
  addeq r11,r11,#0x10000000
  and r3,r3,r11,lsr #31 ;@ Undefined V behavior part II
  movs r1,r11,asr #24
  bicne r10,r10,#0x40000000 ;@ Z
  orr r10,r10,r3,lsl #28 ;@ save V
  orr r10,r10,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '$33333333.l' (address in r6):
  and r1,r1,#0xff
  bic r0,r6,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

finish4839:
  tst r11,r11
  orrmi r10,r10,#0x80000000 ;@ N
  str r10,[r7,#0x4c] ;@ Save X

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4850] pea (a0) uses Op4850 ----------
Op4850:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x3c]
;@ EaCalc : Get '(a0)' into r1:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r1,[r7,r2,lsl #2]

  sub r0,r11,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4868] pea ($3333,a0) uses Op4868 ----------
Op4868:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x3c]
;@ EaCalc : Get '($3333,a0)' into r1:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r1,r0,r2 ;@ Add on offset

  sub r0,r11,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4870] pea ($33,a0,d3.w*2) uses Op4870 ----------
Op4870:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x3c]
;@ EaCalc : Get '($33,a0,d3.w*2)' into r1:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r1,r2,r3 ;@ r1=Disp+An+Rn

  sub r0,r11,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4878] pea $3333.w uses Op4878 ----------
Op4878:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x3c]
;@ EaCalc : Get '$3333.w' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch Absolute Short address

  sub r0,r11,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4879] pea $33333333.l uses Op4879 ----------
Op4879:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x3c]
;@ EaCalc : Get '$33333333.l' into r1:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r1,r0,r2,lsl #16

  sub r0,r11,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [487a] pea ($3333,pc); =3335 uses Op487a ----------
Op487a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x3c]
;@ EaCalc : Get '($3333,pc)' into r1:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r1,r2,r0 ;@ ($nn,PC)

  sub r0,r11,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [487b] pea ($33,pc,d3.w*2); =35 uses Op487b ----------
Op487b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x3c]
;@ EaCalc : Get '($33,pc,d3.w*2)' into r1:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r1,r2,r0 ;@ r1=Disp+PC+Rn

  sub r0,r11,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4880] ext.w d0 uses Op4880 ----------
Op4880:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  movs r0,r0,asl #24
  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r0,asr #24

;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4890] movem.w d0-d1/d4-d5/a0-a1/a4-a5, (a0) uses Op4890 ----------
Op4890:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r6,[r7,r2,lsl #2]
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4890

Movemloop4890:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4890

  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '(a0)' (address in r6):
  uxth r1,r1 ;@ zero extend
  bic r0,r6,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4890

NoRegs4890:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48a0] movem.w d2-d3/d6-d7/a2-a3/a6-a7, -(a0) uses Op48a0 ----------
Op48a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r6,[r7,r2,lsl #2]
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#0x40 ;@ order reversed for -(An)

  tst r11,r11
  beq NoRegs48a0

Movemloop48a0:
  add r4,r4,#-4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48a0

  sub r6,r6,#2 ;@ Pre-decrement address
  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '-(a0)' (address in r6):
  uxth r1,r1 ;@ zero extend
  bic r0,r6,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48a0

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r6 into register[r0]:
  str r6,[r7,r0,lsl #2]

NoRegs48a0:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48a8] movem.w d0-d1/d4-d5/a0-a1/a4-a5, ($3333,a0) uses Op48a8 ----------
Op48a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($3333,a0)' into r6:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r6,r0,r2 ;@ Add on offset
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs48a8

Movemloop48a8:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48a8

  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '($3333,a0)' (address in r6):
  uxth r1,r1 ;@ zero extend
  bic r0,r6,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48a8

NoRegs48a8:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48b0] movem.w d0-d1/d4-d5/a0-a1/a4-a5, ($33,a0,d3.w*2) uses Op48b0 ----------
Op48b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r6:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r6,r2,r3 ;@ r6=Disp+An+Rn
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs48b0

Movemloop48b0:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48b0

  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r6):
  uxth r1,r1 ;@ zero extend
  bic r0,r6,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48b0

NoRegs48b0:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48b8] movem.w d0-d1/d4-d5/a0-a1/a4-a5, $3333.w uses Op48b8 ----------
Op48b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '$3333.w' into r6:
  ldrsh r6,[r4],#2 ;@ Fetch Absolute Short address
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs48b8

Movemloop48b8:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48b8

  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '$3333.w' (address in r6):
  uxth r1,r1 ;@ zero extend
  bic r0,r6,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48b8

NoRegs48b8:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48b9] movem.w d0-d1/d4-d5/a0-a1/a4-a5, $33333333.l uses Op48b9 ----------
Op48b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '$33333333.l' into r6:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r6,r0,r2,lsl #16
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs48b9

Movemloop48b9:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48b9

  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '$33333333.l' (address in r6):
  uxth r1,r1 ;@ zero extend
  bic r0,r6,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48b9

NoRegs48b9:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48c0] ext.l d0 uses Op48c0 ----------
Op48c0:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  movs r0,r0,asl #16
  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48d0] movem.l d0-d1/d4-d5/a0-a1/a4-a5, (a0) uses Op48d0 ----------
Op48d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r6,[r7,r2,lsl #2]
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs48d0

Movemloop48d0:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48d0

  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '(a0)' (address in r6):
  bic r0,r6,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48d0

NoRegs48d0:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48e0] movem.l d2-d3/d6-d7/a2-a3/a6-a7, -(a0) uses Op48e0 ----------
Op48e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r6,[r7,r2,lsl #2]
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#0x40 ;@ order reversed for -(An)

  tst r11,r11
  beq NoRegs48e0

Movemloop48e0:
  add r4,r4,#-4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48e0

  sub r6,r6,#4 ;@ Pre-decrement address
  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
  add r0,r6,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r1,[r7,r4] ;@ Load value from Dn/An
  mov r0,r6
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bic r0,r0,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48e0

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r6 into register[r0]:
  str r6,[r7,r0,lsl #2]

NoRegs48e0:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48e8] movem.l d0-d1/d4-d5/a0-a1/a4-a5, ($3333,a0) uses Op48e8 ----------
Op48e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($3333,a0)' into r6:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r6,r0,r2 ;@ Add on offset
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs48e8

Movemloop48e8:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48e8

  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '($3333,a0)' (address in r6):
  bic r0,r6,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48e8

NoRegs48e8:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48f0] movem.l d0-d1/d4-d5/a0-a1/a4-a5, ($33,a0,d3.w*2) uses Op48f0 ----------
Op48f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r6:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r6,r2,r3 ;@ r6=Disp+An+Rn
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs48f0

Movemloop48f0:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48f0

  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r6):
  bic r0,r6,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48f0

NoRegs48f0:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48f8] movem.l d0-d1/d4-d5/a0-a1/a4-a5, $3333.w uses Op48f8 ----------
Op48f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '$3333.w' into r6:
  ldrsh r6,[r4],#2 ;@ Fetch Absolute Short address
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs48f8

Movemloop48f8:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48f8

  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '$3333.w' (address in r6):
  bic r0,r6,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48f8

NoRegs48f8:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48f9] movem.l d0-d1/d4-d5/a0-a1/a4-a5, $33333333.l uses Op48f9 ----------
Op48f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '$33333333.l' into r6:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r6,r0,r2,lsl #16
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs48f9

Movemloop48f9:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48f9

  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '$33333333.l' (address in r6):
  bic r0,r6,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48f9

NoRegs48f9:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4a00] tst.b d0 uses Op4a00 ----------
Op4a00:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]
  movs r0,r0,asl #24

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a10] tst.b (a0) uses Op4a10 ----------
Op4a10:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r0,r0,asl #24

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a18] tst.b (a0)+ uses Op4a18 ----------
Op4a18:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r0,r0,asl #24

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a1f] tst.b (a7)+ uses Op4a1f ----------
Op4a1f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r0,r0,asl #24

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a20] tst.b -(a0) uses Op4a20 ----------
Op4a20:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r0,r0,asl #24

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a27] tst.b -(a7) uses Op4a27 ----------
Op4a27:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r0,r0,asl #24

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a30] tst.b ($33,a0,d3.w*2) uses Op4a30 ----------
Op4a30:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r0,r0,asl #24

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a40] tst.w d0 uses Op4a40 ----------
Op4a40:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0]
  movs r0,r0,asl #16

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a50] tst.w (a0) uses Op4a50 ----------
Op4a50:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r0,r0,asl #16

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a58] tst.w (a0)+ uses Op4a58 ----------
Op4a58:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r0,r0,asl #16

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a60] tst.w -(a0) uses Op4a60 ----------
Op4a60:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r0,r0,asl #16

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a68] tst.w ($3333,a0) uses Op4a68 ----------
Op4a68:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r0,r0,asl #16

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a70] tst.w ($33,a0,d3.w*2) uses Op4a70 ----------
Op4a70:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r0,r0,asl #16

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a78] tst.w $3333.w uses Op4a78 ----------
Op4a78:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  movs r0,r0,asl #16

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a80] tst.l d0 uses Op4a80 ----------
Op4a80:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]
  tst r0,r0

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a90] tst.l (a0) uses Op4a90 ----------
Op4a90:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  tst r0,r0

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a98] tst.l (a0)+ uses Op4a98 ----------
Op4a98:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  tst r0,r0

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4aa0] tst.l -(a0) uses Op4aa0 ----------
Op4aa0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  tst r0,r0

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4aa8] tst.l ($3333,a0) uses Op4aa8 ----------
Op4aa8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  tst r0,r0

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ab0] tst.l ($33,a0,d3.w*2) uses Op4ab0 ----------
Op4ab0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  tst r0,r0

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ab8] tst.l $3333.w uses Op4ab8 ----------
Op4ab8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  tst r0,r0

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ab9] tst.l $33333333.l uses Op4ab9 ----------
Op4ab9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  tst r0,r0

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ac0] tas d0 uses Op4ac0 ----------
Op4ac0:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsl #2]
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ad0] tas (a0) uses Op4ad0 ----------
Op4ad0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ad8] tas (a0)+ uses Op4ad8 ----------
Op4ad8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4adf] tas (a7)+ uses Op4adf ----------
Op4adf:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ae0] tas -(a0) uses Op4ae0 ----------
Op4ae0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ae7] tas -(a7) uses Op4ae7 ----------
Op4ae7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ae8] tas ($3333,a0) uses Op4ae8 ----------
Op4ae8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4af0] tas ($33,a0,d3.w*2) uses Op4af0 ----------
Op4af0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4af8] tas $3333.w uses Op4af8 ----------
Op4af8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4af9] tas $33333333.l uses Op4af9 ----------
Op4af9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r1:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4c90] movem.w (a0), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4c90 ----------
Op4c90:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r6,[r7,r2,lsl #2]
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4c90

Movemloop4c90:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4c90

  ;@ Copy memory to register:
;@ EaRead : Read '(a0)' (address in r6) into r0:
  bic r0,r6,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  sxth r0,r0 ;@ sign extend

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4c90

NoRegs4c90:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4c98] movem.w (a0)+, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4c98 ----------
Op4c98:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  ldr r6,[r7,r2,lsl #2]
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4c98

Movemloop4c98:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4c98

  ;@ Copy memory to register:
;@ EaRead : Read '(a0)+' (address in r6) into r0:
  bic r0,r6,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  sxth r0,r0 ;@ sign extend

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4c98

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r6 into register[r0]:
  str r6,[r7,r0,lsl #2]

NoRegs4c98:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4ca8] movem.w ($3333,a0), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4ca8 ----------
Op4ca8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($3333,a0)' into r6:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r6,r0,r2 ;@ Add on offset
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4ca8

Movemloop4ca8:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4ca8

  ;@ Copy memory to register:
;@ EaRead : Read '($3333,a0)' (address in r6) into r0:
  bic r0,r6,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  sxth r0,r0 ;@ sign extend

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4ca8

NoRegs4ca8:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cb0] movem.w ($33,a0,d3.w*2), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cb0 ----------
Op4cb0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r6:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r6,r2,r3 ;@ r6=Disp+An+Rn
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cb0

Movemloop4cb0:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cb0

  ;@ Copy memory to register:
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r6) into r0:
  bic r0,r6,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  sxth r0,r0 ;@ sign extend

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cb0

NoRegs4cb0:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cb8] movem.w $3333.w, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cb8 ----------
Op4cb8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '$3333.w' into r6:
  ldrsh r6,[r4],#2 ;@ Fetch Absolute Short address
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cb8

Movemloop4cb8:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cb8

  ;@ Copy memory to register:
;@ EaRead : Read '$3333.w' (address in r6) into r0:
  bic r0,r6,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  sxth r0,r0 ;@ sign extend

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cb8

NoRegs4cb8:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cb9] movem.w $33333333.l, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cb9 ----------
Op4cb9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '$33333333.l' into r6:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r6,r0,r2,lsl #16
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cb9

Movemloop4cb9:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cb9

  ;@ Copy memory to register:
;@ EaRead : Read '$33333333.l' (address in r6) into r0:
  bic r0,r6,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  sxth r0,r0 ;@ sign extend

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cb9

NoRegs4cb9:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cba] movem.w ($3333,pc), d0-d1/d4-d5/a0-a1/a4-a5; =3337 uses Op4cba ----------
Op4cba:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($3333,pc)' into r6:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r6,r2,r0 ;@ ($nn,PC)
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cba

Movemloop4cba:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cba

  ;@ Copy memory to register:
;@ EaRead : Read '($3333,pc)' (address in r6) into r0:
  bic r0,r6,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  sxth r0,r0 ;@ sign extend

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cba

NoRegs4cba:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cbb] movem.w ($33,pc,d3.w*2), d0-d1/d4-d5/a0-a1/a4-a5; =37 uses Op4cbb ----------
Op4cbb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r6:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r6,r2,r0 ;@ r6=Disp+PC+Rn
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cbb

Movemloop4cbb:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cbb

  ;@ Copy memory to register:
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r6) into r0:
  bic r0,r6,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler
  sxth r0,r0 ;@ sign extend

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cbb

NoRegs4cbb:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cd0] movem.l (a0), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cd0 ----------
Op4cd0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r6,[r7,r2,lsl #2]
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cd0

Movemloop4cd0:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cd0

  ;@ Copy memory to register:
;@ EaRead : Read '(a0)' (address in r6) into r0:
  bic r0,r6,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cd0

NoRegs4cd0:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cd8] movem.l (a0)+, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cd8 ----------
Op4cd8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  ldr r6,[r7,r2,lsl #2]
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cd8

Movemloop4cd8:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cd8

  ;@ Copy memory to register:
;@ EaRead : Read '(a0)+' (address in r6) into r0:
  bic r0,r6,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cd8

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r6 into register[r0]:
  str r6,[r7,r0,lsl #2]

NoRegs4cd8:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4ce8] movem.l ($3333,a0), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4ce8 ----------
Op4ce8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($3333,a0)' into r6:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r6,r0,r2 ;@ Add on offset
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4ce8

Movemloop4ce8:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4ce8

  ;@ Copy memory to register:
;@ EaRead : Read '($3333,a0)' (address in r6) into r0:
  bic r0,r6,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4ce8

NoRegs4ce8:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cf0] movem.l ($33,a0,d3.w*2), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cf0 ----------
Op4cf0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r6:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r6,r2,r3 ;@ r6=Disp+An+Rn
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cf0

Movemloop4cf0:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cf0

  ;@ Copy memory to register:
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r6) into r0:
  bic r0,r6,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cf0

NoRegs4cf0:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cf8] movem.l $3333.w, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cf8 ----------
Op4cf8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '$3333.w' into r6:
  ldrsh r6,[r4],#2 ;@ Fetch Absolute Short address
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cf8

Movemloop4cf8:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cf8

  ;@ Copy memory to register:
;@ EaRead : Read '$3333.w' (address in r6) into r0:
  bic r0,r6,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cf8

NoRegs4cf8:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cf9] movem.l $33333333.l, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cf9 ----------
Op4cf9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '$33333333.l' into r6:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r6,r0,r2,lsl #16
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cf9

Movemloop4cf9:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cf9

  ;@ Copy memory to register:
;@ EaRead : Read '$33333333.l' (address in r6) into r0:
  bic r0,r6,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cf9

NoRegs4cf9:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cfa] movem.l ($3333,pc), d0-d1/d4-d5/a0-a1/a4-a5; =3337 uses Op4cfa ----------
Op4cfa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($3333,pc)' into r6:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r6,r2,r0 ;@ ($nn,PC)
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cfa

Movemloop4cfa:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cfa

  ;@ Copy memory to register:
;@ EaRead : Read '($3333,pc)' (address in r6) into r0:
  bic r0,r6,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cfa

NoRegs4cfa:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cfb] movem.l ($33,pc,d3.w*2), d0-d1/d4-d5/a0-a1/a4-a5; =37 uses Op4cfb ----------
Op4cfb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r6:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r6,r2,r0 ;@ r6=Disp+PC+Rn
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cfb

Movemloop4cfb:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cfb

  ;@ Copy memory to register:
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r6) into r0:
  bic r0,r6,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cfb

NoRegs4cfb:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4e40] trap #0 uses Op4e40 ----------
Op4e40:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  and r0,r8,#0xf ;@ Get trap number
  orr r0,r0,#0x20 ;@ 32+n
  bl Exception

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#38 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e50] link a0,#$3333 uses Op4e50 ----------
Op4e50:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get An
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  orr r11,r11,#0x8 ;@ A0-7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsl #2]

  ldr r0,[r7,#0x3c] ;@ Get A7
  sub r0,r0,#4 ;@ A7-=4
  mov r8,r0 ;@ abuse r8

;@ Write An to Stack
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler
;@ Save to An
;@ EaWrite: r8 into register[r11]:
  str r8,[r7,r11,lsl #2]

;@ Get offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  add r8,r8,r0 ;@ Add offset to A7
  str r8,[r7,#0x3c]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e57] link a7,#$3333 uses Op4e57 ----------
Op4e57:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r0,[r7,#0x3c] ;@ Get A7
  sub r0,r0,#4 ;@ A7-=4
  mov r8,r0 ;@ abuse r8
  mov r1,r0

;@ Write An to Stack
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler
;@ Save to An
;@ Get offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  add r8,r8,r0 ;@ Add offset to A7
  str r8,[r7,#0x3c]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e58] unlk a0 uses Op4e58 ----------
Op4e58:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get An
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  add r8,r0,#4 ;@ A7+=4, abuse r8

;@ Pop An from stack:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  str r8,[r7,#0x3c] ;@ Save A7

;@ An = value from stack:
;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e60] move a0, usp uses Op4e60 ----------
Op4e60:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  str r0,[r7,#0x48] ;@ Put in USP

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e68] move usp, a0 uses Op4e68 ----------
Op4e68:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

  ldr r1,[r7,#0x48] ;@ Get from USP

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e70] reset uses Op4e70 ----------
Op4e70:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

  str r4,[r7,#0x40] ;@ Save PC
  mov r1,r10,lsr #28
  strb r1,[r7,#0x46] ;@ Save Flags (NZCV)
  str r5,[r7,#0x5c] ;@ Save Cycles
  ldr r11,[r7,#0x90] ;@ ResetCallback
  tst r11,r11
  movne lr,pc
  bxne r11 ;@ call ResetCallback if it is defined
  ldrb r10,[r7,#0x46] ;@ r10 = Load Flags (NZCV)
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldr r4,[r7,#0x40] ;@ Load PC
  mov r10,r10,lsl #28

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#132 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e72] stop uses Op4e72 ----------
Op4e72:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

  ldrh r0,[r4],#2 ;@ Fetch the immediate
  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r0,r11
  tst r0,#0x20
  beq no_sp_swap4e72
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap4e72:

  ldr r0,[r7,#0x58]
  mov r5,#0 ;@ eat cycles
  orr r0,r0,#1 ;@ stopped
  str r0,[r7,#0x58]


  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e73] rte uses Op4e73 ----------
Op4e73:
  ldr r11,[r7,#0x44] ;@ Get SR high
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ Pop SR:
  ldr r0,[r7,#0x3c]
  add r1,r0,#2 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ Pop PC:
  ldr r0,[r7,#0x3c]
  add r1,r0,#4 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  ldr r1,[r7,#0x60] ;@ Get Memory base
  add r0,r0,r1 ;@ Memory Base+PC

  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  ldr r1,[r7,#0x44] ;@ reload SR high
;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap4e73
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap4e73:
  ldr r1,[r7,#0x58]
  bic r1,r1,#0x0c ;@ clear 'not processing instruction' and 'doing addr error' bits
  str r1,[r7,#0x58]
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#20 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [4e76] trapv uses Op4e76 ----------
Op4e76:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  tst r10,#0x10000000
  subne r5,r5,#34
  movne r0,#7 ;@ TRAPV exception
  blne Exception
  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e77] rtr uses Op4e77 ----------
Op4e77:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Pop SR:
  ldr r0,[r7,#0x3c]
  add r1,r0,#2 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

;@ Pop PC:
  ldr r0,[r7,#0x3c]
  add r1,r0,#4 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  ldr r1,[r7,#0x60] ;@ Get Memory base
  add r0,r0,r1 ;@ Memory Base+PC

  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e90] jsr (a0) uses Op4e90 ----------
Op4e90:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '(a0)' into r12:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r12,[r7,r2,lsl #2]
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl m68k_checkpc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r11 ;@ r1 = Old PC
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ea8] jsr ($3333,a0) uses Op4ea8 ----------
Op4ea8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($3333,a0)' into r12:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r12,r0,r2 ;@ Add on offset
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl m68k_checkpc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r11 ;@ r1 = Old PC
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4eb0] jsr ($33,a0,d3.w*2) uses Op4eb0 ----------
Op4eb0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($33,a0,d3.w*2)' into r12:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r12,r2,r3 ;@ r12=Disp+An+Rn
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl m68k_checkpc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r11 ;@ r1 = Old PC
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4eb8] jsr $3333.w uses Op4eb8 ----------
Op4eb8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '$3333.w' into r12:
  ldrsh r12,[r4],#2 ;@ Fetch Absolute Short address
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl m68k_checkpc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r11 ;@ r1 = Old PC
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4eb9] jsr $33333333.l uses Op4eb9 ----------
Op4eb9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '$33333333.l' into r12:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r12,r0,r2,lsl #16
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl m68k_checkpc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r11 ;@ r1 = Old PC
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4eba] jsr ($3333,pc); =3335 uses Op4eba ----------
Op4eba:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($3333,pc)' into r12:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r12,r2,r0 ;@ ($nn,PC)
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl m68k_checkpc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r11 ;@ r1 = Old PC
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ebb] jsr ($33,pc,d3.w*2); =35 uses Op4ebb ----------
Op4ebb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($33,pc,d3.w*2)' into r12:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r12,r2,r0 ;@ r12=Disp+PC+Rn
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl m68k_checkpc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r11 ;@ r1 = Old PC
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ed0] jmp (a0) uses Op4ed0 ----------
Op4ed0:
  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '(a0)' into r12:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r12,[r7,r2,lsl #2]
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ee8] jmp ($3333,a0) uses Op4ee8 ----------
Op4ee8:
  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($3333,a0)' into r12:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r12,r0,r2 ;@ Add on offset
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ef0] jmp ($33,a0,d3.w*2) uses Op4ef0 ----------
Op4ef0:
  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($33,a0,d3.w*2)' into r12:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r12,r2,r3 ;@ r12=Disp+An+Rn
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ef8] jmp $3333.w uses Op4ef8 ----------
Op4ef8:
  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '$3333.w' into r12:
  ldrsh r12,[r4],#2 ;@ Fetch Absolute Short address
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ef9] jmp $33333333.l uses Op4ef9 ----------
Op4ef9:
  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '$33333333.l' into r12:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r12,r0,r2,lsl #16
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4efa] jmp ($3333,pc); =3335 uses Op4efa ----------
Op4efa:
  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($3333,pc)' into r12:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r12,r2,r0 ;@ ($nn,PC)
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4efb] jmp ($33,pc,d3.w*2); =35 uses Op4efb ----------
Op4efb:
  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($33,pc,d3.w*2)' into r12:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r12,r2,r0 ;@ r12=Disp+PC+Rn
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5000] addq.b #8, d0 uses Op5000 ----------
Op5000:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5010] addq.b #8, (a0) uses Op5010 ----------
Op5010:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5018] addq.b #8, (a0)+ uses Op5018 ----------
Op5018:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [501f] addq.b #8, (a7)+ uses Op501f ----------
Op501f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5020] addq.b #8, -(a0) uses Op5020 ----------
Op5020:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5027] addq.b #8, -(a7) uses Op5027 ----------
Op5027:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5028] addq.b #8, ($3333,a0) uses Op5028 ----------
Op5028:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5030] addq.b #8, ($33,a0,d3.w*2) uses Op5030 ----------
Op5030:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5038] addq.b #8, $3333.w uses Op5038 ----------
Op5038:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5039] addq.b #8, $33333333.l uses Op5039 ----------
Op5039:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5040] addq.w #8, d0 uses Op5040 ----------
Op5040:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5048] addq.w #8, a0 uses Op5048 ----------
Op5048:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  adds r1,r0,#0x0008

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5050] addq.w #8, (a0) uses Op5050 ----------
Op5050:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5058] addq.w #8, (a0)+ uses Op5058 ----------
Op5058:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5060] addq.w #8, -(a0) uses Op5060 ----------
Op5060:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5068] addq.w #8, ($3333,a0) uses Op5068 ----------
Op5068:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5070] addq.w #8, ($33,a0,d3.w*2) uses Op5070 ----------
Op5070:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5078] addq.w #8, $3333.w uses Op5078 ----------
Op5078:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5079] addq.w #8, $33333333.l uses Op5079 ----------
Op5079:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5080] addq.l #8, d0 uses Op5080 ----------
Op5080:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  adds r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5088] addq.l #8, a0 uses Op5088 ----------
Op5088:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  adds r1,r0,#0x0008

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5090] addq.l #8, (a0) uses Op5090 ----------
Op5090:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5098] addq.l #8, (a0)+ uses Op5098 ----------
Op5098:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50a0] addq.l #8, -(a0) uses Op50a0 ----------
Op50a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50a8] addq.l #8, ($3333,a0) uses Op50a8 ----------
Op50a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50b0] addq.l #8, ($33,a0,d3.w*2) uses Op50b0 ----------
Op50b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50b8] addq.l #8, $3333.w uses Op50b8 ----------
Op50b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50b9] addq.l #8, $33333333.l uses Op50b9 ----------
Op50b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50c0] st d0 uses Op50c0 ----------
Op50c0:
  mvn r1,#0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50c8] dbt d0, 3335 uses Op50c8 ----------
Op50c8:
;@ condition true:
DbraTrue:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50d0] st (a0) uses Op50d0 ----------
Op50d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mvn r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50d8] st (a0)+ uses Op50d8 ----------
Op50d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mvn r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50df] st (a7)+ uses Op50df ----------
Op50df:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mvn r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50e0] st -(a0) uses Op50e0 ----------
Op50e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mvn r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50e7] st -(a7) uses Op50e7 ----------
Op50e7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mvn r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50e8] st ($3333,a0) uses Op50e8 ----------
Op50e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mvn r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50f0] st ($33,a0,d3.w*2) uses Op50f0 ----------
Op50f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mvn r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50f8] st $3333.w uses Op50f8 ----------
Op50f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mvn r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50f9] st $33333333.l uses Op50f9 ----------
Op50f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mvn r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5100] subq.b #8, d0 uses Op5100 ----------
Op5100:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5110] subq.b #8, (a0) uses Op5110 ----------
Op5110:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5118] subq.b #8, (a0)+ uses Op5118 ----------
Op5118:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [511f] subq.b #8, (a7)+ uses Op511f ----------
Op511f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5120] subq.b #8, -(a0) uses Op5120 ----------
Op5120:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5127] subq.b #8, -(a7) uses Op5127 ----------
Op5127:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5128] subq.b #8, ($3333,a0) uses Op5128 ----------
Op5128:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5130] subq.b #8, ($33,a0,d3.w*2) uses Op5130 ----------
Op5130:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5138] subq.b #8, $3333.w uses Op5138 ----------
Op5138:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5139] subq.b #8, $33333333.l uses Op5139 ----------
Op5139:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5140] subq.w #8, d0 uses Op5140 ----------
Op5140:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5148] subq.w #8, a0 uses Op5148 ----------
Op5148:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  subs r1,r0,#0x0008

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5150] subq.w #8, (a0) uses Op5150 ----------
Op5150:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5158] subq.w #8, (a0)+ uses Op5158 ----------
Op5158:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5160] subq.w #8, -(a0) uses Op5160 ----------
Op5160:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5168] subq.w #8, ($3333,a0) uses Op5168 ----------
Op5168:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5170] subq.w #8, ($33,a0,d3.w*2) uses Op5170 ----------
Op5170:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5178] subq.w #8, $3333.w uses Op5178 ----------
Op5178:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5179] subq.w #8, $33333333.l uses Op5179 ----------
Op5179:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5180] subq.l #8, d0 uses Op5180 ----------
Op5180:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  subs r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5188] subq.l #8, a0 uses Op5188 ----------
Op5188:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  subs r1,r0,#0x0008

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5190] subq.l #8, (a0) uses Op5190 ----------
Op5190:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5198] subq.l #8, (a0)+ uses Op5198 ----------
Op5198:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51a0] subq.l #8, -(a0) uses Op51a0 ----------
Op51a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51a8] subq.l #8, ($3333,a0) uses Op51a8 ----------
Op51a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51b0] subq.l #8, ($33,a0,d3.w*2) uses Op51b0 ----------
Op51b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51b8] subq.l #8, $3333.w uses Op51b8 ----------
Op51b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51b9] subq.l #8, $33333333.l uses Op51b9 ----------
Op51b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51c0] sf d0 uses Op51c0 ----------
Op51c0:
  mov r1,#0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51d0] sf (a0) uses Op51d0 ----------
Op51d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51d8] sf (a0)+ uses Op51d8 ----------
Op51d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51df] sf (a7)+ uses Op51df ----------
Op51df:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51e0] sf -(a0) uses Op51e0 ----------
Op51e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51e7] sf -(a7) uses Op51e7 ----------
Op51e7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51e8] sf ($3333,a0) uses Op51e8 ----------
Op51e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51f0] sf ($33,a0,d3.w*2) uses Op51f0 ----------
Op51f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51f8] sf $3333.w uses Op51f8 ----------
Op51f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51f9] sf $33333333.l uses Op51f9 ----------
Op51f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52c0] shi d0 uses Op52c0 ----------
Op52c0:
  mov r1,#0
  tst r10,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,#0
  subeq r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52c8] dbhi d0, 3335 uses Op52c8 ----------
Op52c8:
;@ Is the condition true?
  tst r10,#0x60000000 ;@ hi: !C && !Z
;@ If so, don't dbra
  beq DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52d0] shi (a0) uses Op52d0 ----------
Op52d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52d8] shi (a0)+ uses Op52d8 ----------
Op52d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52df] shi (a7)+ uses Op52df ----------
Op52df:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52e0] shi -(a0) uses Op52e0 ----------
Op52e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52e7] shi -(a7) uses Op52e7 ----------
Op52e7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52e8] shi ($3333,a0) uses Op52e8 ----------
Op52e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52f0] shi ($33,a0,d3.w*2) uses Op52f0 ----------
Op52f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52f8] shi $3333.w uses Op52f8 ----------
Op52f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52f9] shi $33333333.l uses Op52f9 ----------
Op52f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53c0] sls d0 uses Op53c0 ----------
Op53c0:
  mov r1,#0
  tst r10,#0x60000000 ;@ ls: C || Z
  mvnne r1,#0
  subne r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53c8] dbls d0, 3335 uses Op53c8 ----------
Op53c8:
;@ Is the condition true?
  tst r10,#0x60000000 ;@ ls: C || Z
;@ If so, don't dbra
  bne DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53d0] sls (a0) uses Op53d0 ----------
Op53d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ ls: C || Z
  mvnne r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53d8] sls (a0)+ uses Op53d8 ----------
Op53d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ ls: C || Z
  mvnne r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53df] sls (a7)+ uses Op53df ----------
Op53df:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ ls: C || Z
  mvnne r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53e0] sls -(a0) uses Op53e0 ----------
Op53e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ ls: C || Z
  mvnne r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53e7] sls -(a7) uses Op53e7 ----------
Op53e7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ ls: C || Z
  mvnne r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53e8] sls ($3333,a0) uses Op53e8 ----------
Op53e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ ls: C || Z
  mvnne r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53f0] sls ($33,a0,d3.w*2) uses Op53f0 ----------
Op53f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ ls: C || Z
  mvnne r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53f8] sls $3333.w uses Op53f8 ----------
Op53f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ ls: C || Z
  mvnne r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53f9] sls $33333333.l uses Op53f9 ----------
Op53f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ ls: C || Z
  mvnne r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54c0] scc d0 uses Op54c0 ----------
Op54c0:
  mov r1,#0
  tst r10,#0x20000000 ;@ cc: !C
  mvneq r1,#0
  subeq r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54c8] dbcc d0, 3335 uses Op54c8 ----------
Op54c8:
;@ Is the condition true?
  tst r10,#0x20000000 ;@ cc: !C
;@ If so, don't dbra
  beq DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54d0] scc (a0) uses Op54d0 ----------
Op54d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cc: !C
  mvneq r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54d8] scc (a0)+ uses Op54d8 ----------
Op54d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cc: !C
  mvneq r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54df] scc (a7)+ uses Op54df ----------
Op54df:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cc: !C
  mvneq r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54e0] scc -(a0) uses Op54e0 ----------
Op54e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cc: !C
  mvneq r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54e7] scc -(a7) uses Op54e7 ----------
Op54e7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cc: !C
  mvneq r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54e8] scc ($3333,a0) uses Op54e8 ----------
Op54e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cc: !C
  mvneq r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54f0] scc ($33,a0,d3.w*2) uses Op54f0 ----------
Op54f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cc: !C
  mvneq r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54f8] scc $3333.w uses Op54f8 ----------
Op54f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cc: !C
  mvneq r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54f9] scc $33333333.l uses Op54f9 ----------
Op54f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cc: !C
  mvneq r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55c0] scs d0 uses Op55c0 ----------
Op55c0:
  mov r1,#0
  tst r10,#0x20000000 ;@ cs: C
  mvnne r1,#0
  subne r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55c8] dbcs d0, 3335 uses Op55c8 ----------
Op55c8:
;@ Is the condition true?
  tst r10,#0x20000000 ;@ cs: C
;@ If so, don't dbra
  bne DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55d0] scs (a0) uses Op55d0 ----------
Op55d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cs: C
  mvnne r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55d8] scs (a0)+ uses Op55d8 ----------
Op55d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cs: C
  mvnne r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55df] scs (a7)+ uses Op55df ----------
Op55df:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cs: C
  mvnne r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55e0] scs -(a0) uses Op55e0 ----------
Op55e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cs: C
  mvnne r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55e7] scs -(a7) uses Op55e7 ----------
Op55e7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cs: C
  mvnne r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55e8] scs ($3333,a0) uses Op55e8 ----------
Op55e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cs: C
  mvnne r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55f0] scs ($33,a0,d3.w*2) uses Op55f0 ----------
Op55f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cs: C
  mvnne r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55f8] scs $3333.w uses Op55f8 ----------
Op55f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cs: C
  mvnne r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55f9] scs $33333333.l uses Op55f9 ----------
Op55f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cs: C
  mvnne r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56c0] sne d0 uses Op56c0 ----------
Op56c0:
  mov r1,#0
  tst r10,#0x40000000 ;@ ne: !Z
  mvneq r1,#0
  subeq r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56c8] dbne d0, 3335 uses Op56c8 ----------
Op56c8:
;@ Is the condition true?
  tst r10,#0x40000000 ;@ ne: !Z
;@ If so, don't dbra
  beq DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56d0] sne (a0) uses Op56d0 ----------
Op56d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ ne: !Z
  mvneq r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56d8] sne (a0)+ uses Op56d8 ----------
Op56d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ ne: !Z
  mvneq r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56df] sne (a7)+ uses Op56df ----------
Op56df:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ ne: !Z
  mvneq r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56e0] sne -(a0) uses Op56e0 ----------
Op56e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ ne: !Z
  mvneq r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56e7] sne -(a7) uses Op56e7 ----------
Op56e7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ ne: !Z
  mvneq r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56e8] sne ($3333,a0) uses Op56e8 ----------
Op56e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ ne: !Z
  mvneq r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56f0] sne ($33,a0,d3.w*2) uses Op56f0 ----------
Op56f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ ne: !Z
  mvneq r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56f8] sne $3333.w uses Op56f8 ----------
Op56f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ ne: !Z
  mvneq r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56f9] sne $33333333.l uses Op56f9 ----------
Op56f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ ne: !Z
  mvneq r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57c0] seq d0 uses Op57c0 ----------
Op57c0:
  mov r1,#0
  tst r10,#0x40000000 ;@ eq: Z
  mvnne r1,#0
  subne r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57c8] dbeq d0, 3335 uses Op57c8 ----------
Op57c8:
;@ Is the condition true?
  tst r10,#0x40000000 ;@ eq: Z
;@ If so, don't dbra
  bne DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57d0] seq (a0) uses Op57d0 ----------
Op57d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ eq: Z
  mvnne r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57d8] seq (a0)+ uses Op57d8 ----------
Op57d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ eq: Z
  mvnne r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57df] seq (a7)+ uses Op57df ----------
Op57df:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ eq: Z
  mvnne r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57e0] seq -(a0) uses Op57e0 ----------
Op57e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ eq: Z
  mvnne r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57e7] seq -(a7) uses Op57e7 ----------
Op57e7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ eq: Z
  mvnne r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57e8] seq ($3333,a0) uses Op57e8 ----------
Op57e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ eq: Z
  mvnne r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57f0] seq ($33,a0,d3.w*2) uses Op57f0 ----------
Op57f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ eq: Z
  mvnne r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57f8] seq $3333.w uses Op57f8 ----------
Op57f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ eq: Z
  mvnne r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57f9] seq $33333333.l uses Op57f9 ----------
Op57f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ eq: Z
  mvnne r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58c0] svc d0 uses Op58c0 ----------
Op58c0:
  mov r1,#0
  tst r10,#0x10000000 ;@ vc: !V
  mvneq r1,#0
  subeq r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58c8] dbvc d0, 3335 uses Op58c8 ----------
Op58c8:
;@ Is the condition true?
  tst r10,#0x10000000 ;@ vc: !V
;@ If so, don't dbra
  beq DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58d0] svc (a0) uses Op58d0 ----------
Op58d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vc: !V
  mvneq r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58d8] svc (a0)+ uses Op58d8 ----------
Op58d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vc: !V
  mvneq r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58df] svc (a7)+ uses Op58df ----------
Op58df:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vc: !V
  mvneq r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58e0] svc -(a0) uses Op58e0 ----------
Op58e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vc: !V
  mvneq r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58e7] svc -(a7) uses Op58e7 ----------
Op58e7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vc: !V
  mvneq r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58e8] svc ($3333,a0) uses Op58e8 ----------
Op58e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vc: !V
  mvneq r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58f0] svc ($33,a0,d3.w*2) uses Op58f0 ----------
Op58f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vc: !V
  mvneq r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58f8] svc $3333.w uses Op58f8 ----------
Op58f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vc: !V
  mvneq r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58f9] svc $33333333.l uses Op58f9 ----------
Op58f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vc: !V
  mvneq r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59c0] svs d0 uses Op59c0 ----------
Op59c0:
  mov r1,#0
  tst r10,#0x10000000 ;@ vs: V
  mvnne r1,#0
  subne r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59c8] dbvs d0, 3335 uses Op59c8 ----------
Op59c8:
;@ Is the condition true?
  tst r10,#0x10000000 ;@ vs: V
;@ If so, don't dbra
  bne DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59d0] svs (a0) uses Op59d0 ----------
Op59d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vs: V
  mvnne r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59d8] svs (a0)+ uses Op59d8 ----------
Op59d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vs: V
  mvnne r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59df] svs (a7)+ uses Op59df ----------
Op59df:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vs: V
  mvnne r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59e0] svs -(a0) uses Op59e0 ----------
Op59e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vs: V
  mvnne r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59e7] svs -(a7) uses Op59e7 ----------
Op59e7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vs: V
  mvnne r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59e8] svs ($3333,a0) uses Op59e8 ----------
Op59e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vs: V
  mvnne r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59f0] svs ($33,a0,d3.w*2) uses Op59f0 ----------
Op59f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vs: V
  mvnne r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59f8] svs $3333.w uses Op59f8 ----------
Op59f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vs: V
  mvnne r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59f9] svs $33333333.l uses Op59f9 ----------
Op59f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vs: V
  mvnne r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ac0] spl d0 uses Op5ac0 ----------
Op5ac0:
  mov r1,#0
  tst r10,r10 ;@ pl: !N
  mvnpl r1,#0
  subpl r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ac8] dbpl d0, 3335 uses Op5ac8 ----------
Op5ac8:
;@ Is the condition true?
  tst r10,r10 ;@ pl: !N
;@ If so, don't dbra
  bpl DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ad0] spl (a0) uses Op5ad0 ----------
Op5ad0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ pl: !N
  mvnpl r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ad8] spl (a0)+ uses Op5ad8 ----------
Op5ad8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ pl: !N
  mvnpl r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5adf] spl (a7)+ uses Op5adf ----------
Op5adf:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ pl: !N
  mvnpl r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ae0] spl -(a0) uses Op5ae0 ----------
Op5ae0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ pl: !N
  mvnpl r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ae7] spl -(a7) uses Op5ae7 ----------
Op5ae7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ pl: !N
  mvnpl r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ae8] spl ($3333,a0) uses Op5ae8 ----------
Op5ae8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ pl: !N
  mvnpl r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5af0] spl ($33,a0,d3.w*2) uses Op5af0 ----------
Op5af0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ pl: !N
  mvnpl r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5af8] spl $3333.w uses Op5af8 ----------
Op5af8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ pl: !N
  mvnpl r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5af9] spl $33333333.l uses Op5af9 ----------
Op5af9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ pl: !N
  mvnpl r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bc0] smi d0 uses Op5bc0 ----------
Op5bc0:
  mov r1,#0
  tst r10,r10 ;@ mi: N
  mvnmi r1,#0
  submi r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bc8] dbmi d0, 3335 uses Op5bc8 ----------
Op5bc8:
;@ Is the condition true?
  tst r10,r10 ;@ mi: N
;@ If so, don't dbra
  bmi DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bd0] smi (a0) uses Op5bd0 ----------
Op5bd0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ mi: N
  mvnmi r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bd8] smi (a0)+ uses Op5bd8 ----------
Op5bd8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ mi: N
  mvnmi r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bdf] smi (a7)+ uses Op5bdf ----------
Op5bdf:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ mi: N
  mvnmi r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5be0] smi -(a0) uses Op5be0 ----------
Op5be0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ mi: N
  mvnmi r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5be7] smi -(a7) uses Op5be7 ----------
Op5be7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ mi: N
  mvnmi r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5be8] smi ($3333,a0) uses Op5be8 ----------
Op5be8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ mi: N
  mvnmi r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bf0] smi ($33,a0,d3.w*2) uses Op5bf0 ----------
Op5bf0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ mi: N
  mvnmi r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bf8] smi $3333.w uses Op5bf8 ----------
Op5bf8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ mi: N
  mvnmi r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bf9] smi $33333333.l uses Op5bf9 ----------
Op5bf9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ mi: N
  mvnmi r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cc0] sge d0 uses Op5cc0 ----------
Op5cc0:
  mov r1,#0
  teq r10,r10,lsl #3 ;@ ge: N == V
  mvnpl r1,#0
  subpl r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cc8] dbge d0, 3335 uses Op5cc8 ----------
Op5cc8:
;@ Is the condition true?
  teq r10,r10,lsl #3 ;@ ge: N == V
;@ If so, don't dbra
  bpl DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cd0] sge (a0) uses Op5cd0 ----------
Op5cd0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ ge: N == V
  mvnpl r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cd8] sge (a0)+ uses Op5cd8 ----------
Op5cd8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ ge: N == V
  mvnpl r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cdf] sge (a7)+ uses Op5cdf ----------
Op5cdf:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ ge: N == V
  mvnpl r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ce0] sge -(a0) uses Op5ce0 ----------
Op5ce0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ ge: N == V
  mvnpl r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ce7] sge -(a7) uses Op5ce7 ----------
Op5ce7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ ge: N == V
  mvnpl r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ce8] sge ($3333,a0) uses Op5ce8 ----------
Op5ce8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ ge: N == V
  mvnpl r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cf0] sge ($33,a0,d3.w*2) uses Op5cf0 ----------
Op5cf0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ ge: N == V
  mvnpl r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cf8] sge $3333.w uses Op5cf8 ----------
Op5cf8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ ge: N == V
  mvnpl r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cf9] sge $33333333.l uses Op5cf9 ----------
Op5cf9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ ge: N == V
  mvnpl r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5dc0] slt d0 uses Op5dc0 ----------
Op5dc0:
  mov r1,#0
  teq r10,r10,lsl #3 ;@ lt: N != V
  mvnmi r1,#0
  submi r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5dc8] dblt d0, 3335 uses Op5dc8 ----------
Op5dc8:
;@ Is the condition true?
  teq r10,r10,lsl #3 ;@ lt: N != V
;@ If so, don't dbra
  bmi DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5dd0] slt (a0) uses Op5dd0 ----------
Op5dd0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ lt: N != V
  mvnmi r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5dd8] slt (a0)+ uses Op5dd8 ----------
Op5dd8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ lt: N != V
  mvnmi r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ddf] slt (a7)+ uses Op5ddf ----------
Op5ddf:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ lt: N != V
  mvnmi r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5de0] slt -(a0) uses Op5de0 ----------
Op5de0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ lt: N != V
  mvnmi r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5de7] slt -(a7) uses Op5de7 ----------
Op5de7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ lt: N != V
  mvnmi r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5de8] slt ($3333,a0) uses Op5de8 ----------
Op5de8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ lt: N != V
  mvnmi r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5df0] slt ($33,a0,d3.w*2) uses Op5df0 ----------
Op5df0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ lt: N != V
  mvnmi r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5df8] slt $3333.w uses Op5df8 ----------
Op5df8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ lt: N != V
  mvnmi r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5df9] slt $33333333.l uses Op5df9 ----------
Op5df9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ lt: N != V
  mvnmi r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e00] addq.b #7, d0 uses Op5e00 ----------
Op5e00:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e10] addq.b #7, (a0) uses Op5e10 ----------
Op5e10:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e18] addq.b #7, (a0)+ uses Op5e18 ----------
Op5e18:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e1f] addq.b #7, (a7)+ uses Op5e1f ----------
Op5e1f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e20] addq.b #7, -(a0) uses Op5e20 ----------
Op5e20:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e27] addq.b #7, -(a7) uses Op5e27 ----------
Op5e27:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e28] addq.b #7, ($3333,a0) uses Op5e28 ----------
Op5e28:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e30] addq.b #7, ($33,a0,d3.w*2) uses Op5e30 ----------
Op5e30:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e38] addq.b #7, $3333.w uses Op5e38 ----------
Op5e38:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e39] addq.b #7, $33333333.l uses Op5e39 ----------
Op5e39:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e48] addq.w #7, a0 uses Op5e48 ----------
Op5e48:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e50] addq.w #7, (a0) uses Op5e50 ----------
Op5e50:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e58] addq.w #7, (a0)+ uses Op5e58 ----------
Op5e58:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e60] addq.w #7, -(a0) uses Op5e60 ----------
Op5e60:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e68] addq.w #7, ($3333,a0) uses Op5e68 ----------
Op5e68:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e70] addq.w #7, ($33,a0,d3.w*2) uses Op5e70 ----------
Op5e70:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e78] addq.w #7, $3333.w uses Op5e78 ----------
Op5e78:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e79] addq.w #7, $33333333.l uses Op5e79 ----------
Op5e79:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e80] addq.l #7, d0 uses Op5e80 ----------
Op5e80:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e88] addq.l #7, a0 uses Op5e88 ----------
Op5e88:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e90] addq.l #7, (a0) uses Op5e90 ----------
Op5e90:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e98] addq.l #7, (a0)+ uses Op5e98 ----------
Op5e98:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ea0] addq.l #7, -(a0) uses Op5ea0 ----------
Op5ea0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ea8] addq.l #7, ($3333,a0) uses Op5ea8 ----------
Op5ea8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5eb0] addq.l #7, ($33,a0,d3.w*2) uses Op5eb0 ----------
Op5eb0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5eb8] addq.l #7, $3333.w uses Op5eb8 ----------
Op5eb8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5eb9] addq.l #7, $33333333.l uses Op5eb9 ----------
Op5eb9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ec0] sgt d0 uses Op5ec0 ----------
Op5ec0:
  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  mvnpl r1,#0
  subpl r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ec8] dbgt d0, 3335 uses Op5ec8 ----------
Op5ec8:
;@ Is the condition true?
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
;@ If so, don't dbra
  bpl DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ed0] sgt (a0) uses Op5ed0 ----------
Op5ed0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  mvnpl r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ed8] sgt (a0)+ uses Op5ed8 ----------
Op5ed8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  mvnpl r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5edf] sgt (a7)+ uses Op5edf ----------
Op5edf:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  mvnpl r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ee0] sgt -(a0) uses Op5ee0 ----------
Op5ee0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  mvnpl r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ee7] sgt -(a7) uses Op5ee7 ----------
Op5ee7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  mvnpl r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ee8] sgt ($3333,a0) uses Op5ee8 ----------
Op5ee8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  mvnpl r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ef0] sgt ($33,a0,d3.w*2) uses Op5ef0 ----------
Op5ef0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  mvnpl r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ef8] sgt $3333.w uses Op5ef8 ----------
Op5ef8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  mvnpl r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ef9] sgt $33333333.l uses Op5ef9 ----------
Op5ef9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  mvnpl r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f00] subq.b #7, d0 uses Op5f00 ----------
Op5f00:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f10] subq.b #7, (a0) uses Op5f10 ----------
Op5f10:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f18] subq.b #7, (a0)+ uses Op5f18 ----------
Op5f18:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f1f] subq.b #7, (a7)+ uses Op5f1f ----------
Op5f1f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f20] subq.b #7, -(a0) uses Op5f20 ----------
Op5f20:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f27] subq.b #7, -(a7) uses Op5f27 ----------
Op5f27:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f28] subq.b #7, ($3333,a0) uses Op5f28 ----------
Op5f28:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f30] subq.b #7, ($33,a0,d3.w*2) uses Op5f30 ----------
Op5f30:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f38] subq.b #7, $3333.w uses Op5f38 ----------
Op5f38:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f39] subq.b #7, $33333333.l uses Op5f39 ----------
Op5f39:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f40] subq.w #7, d0 uses Op5f40 ----------
Op5f40:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f48] subq.w #7, a0 uses Op5f48 ----------
Op5f48:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f50] subq.w #7, (a0) uses Op5f50 ----------
Op5f50:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f58] subq.w #7, (a0)+ uses Op5f58 ----------
Op5f58:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f60] subq.w #7, -(a0) uses Op5f60 ----------
Op5f60:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f68] subq.w #7, ($3333,a0) uses Op5f68 ----------
Op5f68:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f70] subq.w #7, ($33,a0,d3.w*2) uses Op5f70 ----------
Op5f70:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f78] subq.w #7, $3333.w uses Op5f78 ----------
Op5f78:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f79] subq.w #7, $33333333.l uses Op5f79 ----------
Op5f79:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f80] subq.l #7, d0 uses Op5f80 ----------
Op5f80:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f88] subq.l #7, a0 uses Op5f88 ----------
Op5f88:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f90] subq.l #7, (a0) uses Op5f90 ----------
Op5f90:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f98] subq.l #7, (a0)+ uses Op5f98 ----------
Op5f98:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fa0] subq.l #7, -(a0) uses Op5fa0 ----------
Op5fa0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fa8] subq.l #7, ($3333,a0) uses Op5fa8 ----------
Op5fa8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fb0] subq.l #7, ($33,a0,d3.w*2) uses Op5fb0 ----------
Op5fb0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fb8] subq.l #7, $3333.w uses Op5fb8 ----------
Op5fb8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fb9] subq.l #7, $33333333.l uses Op5fb9 ----------
Op5fb9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fc0] sle d0 uses Op5fc0 ----------
Op5fc0:
  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  mvnmi r1,#0
  submi r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fc8] dble d0, 3335 uses Op5fc8 ----------
Op5fc8:
;@ Is the condition true?
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
;@ If so, don't dbra
  bmi DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fd0] sle (a0) uses Op5fd0 ----------
Op5fd0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  mvnmi r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fd8] sle (a0)+ uses Op5fd8 ----------
Op5fd8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  mvnmi r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fdf] sle (a7)+ uses Op5fdf ----------
Op5fdf:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  mvnmi r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fe0] sle -(a0) uses Op5fe0 ----------
Op5fe0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  mvnmi r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fe7] sle -(a7) uses Op5fe7 ----------
Op5fe7:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  mvnmi r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fe8] sle ($3333,a0) uses Op5fe8 ----------
Op5fe8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  mvnmi r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ff0] sle ($33,a0,d3.w*2) uses Op5ff0 ----------
Op5ff0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  mvnmi r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ff8] sle $3333.w uses Op5ff8 ----------
Op5ff8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  mvnmi r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ff9] sle $33333333.l uses Op5ff9 ----------
Op5ff9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  mvnmi r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6000] bra 3335 uses Op6000 ----------
Op6000:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6003] bra 5 uses Op6003 ----------
Op6003:
  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6103] bsr 5 uses Op6103 ----------
Op6103:
  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
;@ Bsr - remember old PC
  ldr r12,[r7,#0x60] ;@ Get Memory base
  ldr r2,[r7,#0x3c]
  sub r1,r4,r12 ;@ r1 = Old PC

;@ Push r1 onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6200] bhi 3335 uses Op6200 ----------
Op6200:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  tst r10,#0x60000000 ;@ hi: !C && !Z
  bne BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6202] bhi 4 uses Op6202 ----------
Op6202:
  tst r10,#0x60000000 ;@ hi: !C && !Z
  bne BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6203] bhi 5 uses Op6203 ----------
Op6203:
  tst r10,#0x60000000 ;@ hi: !C && !Z
  bne BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6300] bls 3335 uses Op6300 ----------
Op6300:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  tst r10,#0x60000000 ;@ ls: C || Z
  beq BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6302] bls 4 uses Op6302 ----------
Op6302:
  tst r10,#0x60000000 ;@ ls: C || Z
  beq BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6303] bls 5 uses Op6303 ----------
Op6303:
  tst r10,#0x60000000 ;@ ls: C || Z
  beq BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6400] bcc 3335 uses Op6400 ----------
Op6400:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  tst r10,#0x20000000 ;@ cc: !C
  bne BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6403] bcc 5 uses Op6403 ----------
Op6403:
  tst r10,#0x20000000 ;@ cc: !C
  bne BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6503] bcs 5 uses Op6503 ----------
Op6503:
  tst r10,#0x20000000 ;@ cs: C
  beq BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6600] bne 3335 uses Op6600 ----------
Op6600:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  tst r10,#0x40000000 ;@ ne: !Z
  bne BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6603] bne 5 uses Op6603 ----------
Op6603:
  tst r10,#0x40000000 ;@ ne: !Z
  bne BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6703] beq 5 uses Op6703 ----------
Op6703:
  tst r10,#0x40000000 ;@ eq: Z
  beq BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6800] bvc 3335 uses Op6800 ----------
Op6800:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  tst r10,#0x10000000 ;@ vc: !V
  bne BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6802] bvc 4 uses Op6802 ----------
Op6802:
  tst r10,#0x10000000 ;@ vc: !V
  bne BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6803] bvc 5 uses Op6803 ----------
Op6803:
  tst r10,#0x10000000 ;@ vc: !V
  bne BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6900] bvs 3335 uses Op6900 ----------
Op6900:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  tst r10,#0x10000000 ;@ vs: V
  beq BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6902] bvs 4 uses Op6902 ----------
Op6902:
  tst r10,#0x10000000 ;@ vs: V
  beq BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6903] bvs 5 uses Op6903 ----------
Op6903:
  tst r10,#0x10000000 ;@ vs: V
  beq BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6a00] bpl 3335 uses Op6a00 ----------
Op6a00:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  tst r10,r10 ;@ pl: !N
  bmi BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6a03] bpl 5 uses Op6a03 ----------
Op6a03:
  tst r10,r10 ;@ pl: !N
  bmi BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6b00] bmi 3335 uses Op6b00 ----------
Op6b00:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  tst r10,r10 ;@ mi: N
  bpl BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6b02] bmi 4 uses Op6b02 ----------
Op6b02:
  tst r10,r10 ;@ mi: N
  bpl BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6b03] bmi 5 uses Op6b03 ----------
Op6b03:
  tst r10,r10 ;@ mi: N
  bpl BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6c00] bge 3335 uses Op6c00 ----------
Op6c00:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  teq r10,r10,lsl #3 ;@ ge: N == V
  bmi BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6c02] bge 4 uses Op6c02 ----------
Op6c02:
  teq r10,r10,lsl #3 ;@ ge: N == V
  bmi BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6c03] bge 5 uses Op6c03 ----------
Op6c03:
  teq r10,r10,lsl #3 ;@ ge: N == V
  bmi BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6d00] blt 3335 uses Op6d00 ----------
Op6d00:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  teq r10,r10,lsl #3 ;@ lt: N != V
  bpl BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6d02] blt 4 uses Op6d02 ----------
Op6d02:
  teq r10,r10,lsl #3 ;@ lt: N != V
  bpl BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6d03] blt 5 uses Op6d03 ----------
Op6d03:
  teq r10,r10,lsl #3 ;@ lt: N != V
  bpl BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6e00] bgt 3335 uses Op6e00 ----------
Op6e00:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  bmi BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6e02] bgt 4 uses Op6e02 ----------
Op6e02:
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  bmi BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6e03] bgt 5 uses Op6e03 ----------
Op6e03:
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  bmi BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6f00] ble 3335 uses Op6f00 ----------
Op6f00:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  bpl BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl m68k_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6f02] ble 4 uses Op6f02 ----------
Op6f02:
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  bpl BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6f03] ble 5 uses Op6f03 ----------
Op6f03:
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  bpl BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8000] or.b d0, d0 uses Op8000 ----------
Op8000:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8010] or.b (a0), d0 uses Op8010 ----------
Op8010:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8018] or.b (a0)+, d0 uses Op8018 ----------
Op8018:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [801f] or.b (a7)+, d0 uses Op801f ----------
Op801f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8020] or.b -(a0), d0 uses Op8020 ----------
Op8020:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8027] or.b -(a7), d0 uses Op8027 ----------
Op8027:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8028] or.b ($3333,a0), d0 uses Op8028 ----------
Op8028:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8030] or.b ($33,a0,d3.w*2), d0 uses Op8030 ----------
Op8030:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8038] or.b $3333.w, d0 uses Op8038 ----------
Op8038:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8039] or.b $33333333.l, d0 uses Op8039 ----------
Op8039:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [803a] or.b ($3333,pc), d0; =3335 uses Op803a ----------
Op803a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [803b] or.b ($33,pc,d3.w*2), d0; =35 uses Op803b ----------
Op803b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [803c] or.b #$33, d0 uses Op803c ----------
Op803c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8040] or.w d0, d0 uses Op8040 ----------
Op8040:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8050] or.w (a0), d0 uses Op8050 ----------
Op8050:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8058] or.w (a0)+, d0 uses Op8058 ----------
Op8058:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8060] or.w -(a0), d0 uses Op8060 ----------
Op8060:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8068] or.w ($3333,a0), d0 uses Op8068 ----------
Op8068:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8070] or.w ($33,a0,d3.w*2), d0 uses Op8070 ----------
Op8070:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8078] or.w $3333.w, d0 uses Op8078 ----------
Op8078:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8079] or.w $33333333.l, d0 uses Op8079 ----------
Op8079:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [807a] or.w ($3333,pc), d0; =3335 uses Op807a ----------
Op807a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [807b] or.w ($33,pc,d3.w*2), d0; =35 uses Op807b ----------
Op807b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [807c] or.w #$3333, d0 uses Op807c ----------
Op807c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8080] or.l d0, d0 uses Op8080 ----------
Op8080:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8090] or.l (a0), d0 uses Op8090 ----------
Op8090:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8098] or.l (a0)+, d0 uses Op8098 ----------
Op8098:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80a0] or.l -(a0), d0 uses Op80a0 ----------
Op80a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80a8] or.l ($3333,a0), d0 uses Op80a8 ----------
Op80a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80b0] or.l ($33,a0,d3.w*2), d0 uses Op80b0 ----------
Op80b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80b8] or.l $3333.w, d0 uses Op80b8 ----------
Op80b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80b9] or.l $33333333.l, d0 uses Op80b9 ----------
Op80b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80ba] or.l ($3333,pc), d0; =3335 uses Op80ba ----------
Op80ba:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80bb] or.l ($33,pc,d3.w*2), d0; =35 uses Op80bb ----------
Op80bb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80bc] or.l #$33333333, d0 uses Op80bc ----------
Op80bc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80c0] divu.w d0, d0 uses Op80c0 ----------
Op80c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80c0 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80c0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80c0

Divide80c0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80c0

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80c0 ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80c0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#140 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80c0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#178 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80d0] divu.w (a0), d0 uses Op80d0 ----------
Op80d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80d0 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80d0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80d0

Divide80d0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80d0

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80d0 ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80d0:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#144 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80d0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#182 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80d8] divu.w (a0)+, d0 uses Op80d8 ----------
Op80d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80d8 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80d8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80d8

Divide80d8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80d8

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80d8 ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80d8:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#144 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80d8:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#182 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80e0] divu.w -(a0), d0 uses Op80e0 ----------
Op80e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80e0 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80e0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80e0

Divide80e0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80e0

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80e0 ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80e0:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#146 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80e0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#184 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80e8] divu.w ($3333,a0), d0 uses Op80e8 ----------
Op80e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80e8 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80e8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80e8

Divide80e8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80e8

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80e8 ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80e8:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#148 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80e8:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#186 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80f0] divu.w ($33,a0,d3.w*2), d0 uses Op80f0 ----------
Op80f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80f0 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80f0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80f0

Divide80f0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80f0

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80f0 ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80f0:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#150 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80f0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#188 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80f8] divu.w $3333.w, d0 uses Op80f8 ----------
Op80f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80f8 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80f8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80f8

Divide80f8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80f8

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80f8 ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80f8:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#148 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80f8:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#186 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80f9] divu.w $33333333.l, d0 uses Op80f9 ----------
Op80f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80f9 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80f9:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80f9

Divide80f9:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80f9

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80f9 ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80f9:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#152 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80f9:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#190 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80fa] divu.w ($3333,pc), d0; =3335 uses Op80fa ----------
Op80fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80fa ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80fa:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80fa

Divide80fa:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80fa

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80fa ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80fa:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#148 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80fa:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#186 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80fb] divu.w ($33,pc,d3.w*2), d0; =35 uses Op80fb ----------
Op80fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80fb ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80fb:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80fb

Divide80fb:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80fb

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80fb ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80fb:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#150 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80fb:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#188 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80fc] divu.w #$3333, d0 uses Op80fc ----------
Op80fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80fc ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80fc:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80fc

Divide80fc:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80fc

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80fc ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80fc:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#144 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80fc:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#182 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [8100] sbcd d0, d0 uses Op8100 ----------
Op8100:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r6:
  and r6,r8,#0x0007
;@ EaRead : Read register[r6] into r6:
  ldr r6,[r7,r6,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsr #7]

  mov r6,r6,asl #24
  mov r1,r0,asl #24

  bic r10,r10,#0xb1000000 ;@ clear all flags except old Z
  ldr r0,[r7,#0x4c] ;@ Get X bit
  mov r3,#0x00f00000
  and r2,r3,r6,lsr #4
  tst r0,#0x20000000
  and r0,r3,r1,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r6,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r10,r10,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r10,r10,#0x40000000 ;@ Z flag
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsr #7]

  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8108] sbcd -(a0), -(a0) uses Op8108 ----------
Op8108:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r1,r0,asl #24

  bic r10,r10,#0xb1000000 ;@ clear all flags except old Z
  ldr r0,[r7,#0x4c] ;@ Get X bit
  mov r3,#0x00f00000
  and r2,r3,r6,lsr #4
  tst r0,#0x20000000
  and r0,r3,r1,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r6,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r10,r10,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r10,r10,#0x40000000 ;@ Z flag
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [810f] sbcd -(a7), -(a0) uses Op810f ----------
Op810f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r6:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r1,r0,asl #24

  bic r10,r10,#0xb1000000 ;@ clear all flags except old Z
  ldr r0,[r7,#0x4c] ;@ Get X bit
  mov r3,#0x00f00000
  and r2,r3,r6,lsr #4
  tst r0,#0x20000000
  and r0,r3,r1,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r6,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r10,r10,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r10,r10,#0x40000000 ;@ Z flag
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8110] or.b d0, (a0) uses Op8110 ----------
Op8110:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8118] or.b d0, (a0)+ uses Op8118 ----------
Op8118:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [811f] or.b d0, (a7)+ uses Op811f ----------
Op811f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8120] or.b d0, -(a0) uses Op8120 ----------
Op8120:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8127] or.b d0, -(a7) uses Op8127 ----------
Op8127:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8128] or.b d0, ($3333,a0) uses Op8128 ----------
Op8128:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8130] or.b d0, ($33,a0,d3.w*2) uses Op8130 ----------
Op8130:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8138] or.b d0, $3333.w uses Op8138 ----------
Op8138:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8139] or.b d0, $33333333.l uses Op8139 ----------
Op8139:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8150] or.w d0, (a0) uses Op8150 ----------
Op8150:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8158] or.w d0, (a0)+ uses Op8158 ----------
Op8158:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8160] or.w d0, -(a0) uses Op8160 ----------
Op8160:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8168] or.w d0, ($3333,a0) uses Op8168 ----------
Op8168:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8170] or.w d0, ($33,a0,d3.w*2) uses Op8170 ----------
Op8170:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8178] or.w d0, $3333.w uses Op8178 ----------
Op8178:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8179] or.w d0, $33333333.l uses Op8179 ----------
Op8179:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8190] or.l d0, (a0) uses Op8190 ----------
Op8190:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8198] or.l d0, (a0)+ uses Op8198 ----------
Op8198:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81a0] or.l d0, -(a0) uses Op81a0 ----------
Op81a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81a8] or.l d0, ($3333,a0) uses Op81a8 ----------
Op81a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81b0] or.l d0, ($33,a0,d3.w*2) uses Op81b0 ----------
Op81b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81b8] or.l d0, $3333.w uses Op81b8 ----------
Op81b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81b9] or.l d0, $33333333.l uses Op81b9 ----------
Op81b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81c0] divs.w d0, d0 uses Op81c0 ----------
Op81c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81c0 ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81c0

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81c0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81c0

Divide81c0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81c0

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81c0 ;@ overflow!

wrendofop81c0:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81c0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#158 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81c0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#196 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81d0] divs.w (a0), d0 uses Op81d0 ----------
Op81d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81d0 ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81d0

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81d0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81d0

Divide81d0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81d0

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81d0 ;@ overflow!

wrendofop81d0:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81d0:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#162 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81d0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#200 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81d8] divs.w (a0)+, d0 uses Op81d8 ----------
Op81d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81d8 ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81d8

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81d8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81d8

Divide81d8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81d8

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81d8 ;@ overflow!

wrendofop81d8:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81d8:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#162 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81d8:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#200 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81e0] divs.w -(a0), d0 uses Op81e0 ----------
Op81e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81e0 ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81e0

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81e0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81e0

Divide81e0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81e0

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81e0 ;@ overflow!

wrendofop81e0:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81e0:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#164 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81e0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#202 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81e8] divs.w ($3333,a0), d0 uses Op81e8 ----------
Op81e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81e8 ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81e8

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81e8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81e8

Divide81e8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81e8

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81e8 ;@ overflow!

wrendofop81e8:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81e8:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#166 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81e8:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#204 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81f0] divs.w ($33,a0,d3.w*2), d0 uses Op81f0 ----------
Op81f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81f0 ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81f0

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81f0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81f0

Divide81f0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81f0

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81f0 ;@ overflow!

wrendofop81f0:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81f0:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#168 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81f0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#206 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81f8] divs.w $3333.w, d0 uses Op81f8 ----------
Op81f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81f8 ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81f8

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81f8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81f8

Divide81f8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81f8

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81f8 ;@ overflow!

wrendofop81f8:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81f8:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#166 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81f8:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#204 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81f9] divs.w $33333333.l, d0 uses Op81f9 ----------
Op81f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81f9 ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81f9

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81f9:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81f9

Divide81f9:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81f9

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81f9 ;@ overflow!

wrendofop81f9:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81f9:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#170 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81f9:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#208 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81fa] divs.w ($3333,pc), d0; =3335 uses Op81fa ----------
Op81fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81fa ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81fa

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81fa:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81fa

Divide81fa:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81fa

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81fa ;@ overflow!

wrendofop81fa:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81fa:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#166 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81fa:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#204 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81fb] divs.w ($33,pc,d3.w*2), d0; =35 uses Op81fb ----------
Op81fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81fb ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81fb

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81fb:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81fb

Divide81fb:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81fb

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81fb ;@ overflow!

wrendofop81fb:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81fb:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#168 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81fb:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#206 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81fc] divs.w #$3333, d0 uses Op81fc ----------
Op81fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81fc ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81fc

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81fc:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81fc

Divide81fc:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81fc

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81fc ;@ overflow!

wrendofop81fc:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81fc:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#162 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81fc:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#200 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [8f08] sbcd -(a0), -(a7) uses Op8f08 ----------
Op8f08:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r1,r0,asl #24

  bic r10,r10,#0xb1000000 ;@ clear all flags except old Z
  ldr r0,[r7,#0x4c] ;@ Get X bit
  mov r3,#0x00f00000
  and r2,r3,r6,lsr #4
  tst r0,#0x20000000
  and r0,r3,r1,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r6,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r10,r10,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r10,r10,#0x40000000 ;@ Z flag
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8f0f] sbcd -(a7), -(a7) uses Op8f0f ----------
Op8f0f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r6:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r1,r0,asl #24

  bic r10,r10,#0xb1000000 ;@ clear all flags except old Z
  ldr r0,[r7,#0x4c] ;@ Get X bit
  mov r3,#0x00f00000
  and r2,r3,r6,lsr #4
  tst r0,#0x20000000
  and r0,r3,r1,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r6,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r10,r10,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r10,r10,#0x40000000 ;@ Z flag
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9000] sub.b d0, d0 uses Op9000 ----------
Op9000:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9010] sub.b (a0), d0 uses Op9010 ----------
Op9010:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9018] sub.b (a0)+, d0 uses Op9018 ----------
Op9018:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [901f] sub.b (a7)+, d0 uses Op901f ----------
Op901f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9020] sub.b -(a0), d0 uses Op9020 ----------
Op9020:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9027] sub.b -(a7), d0 uses Op9027 ----------
Op9027:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9028] sub.b ($3333,a0), d0 uses Op9028 ----------
Op9028:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9030] sub.b ($33,a0,d3.w*2), d0 uses Op9030 ----------
Op9030:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9038] sub.b $3333.w, d0 uses Op9038 ----------
Op9038:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9039] sub.b $33333333.l, d0 uses Op9039 ----------
Op9039:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [903a] sub.b ($3333,pc), d0; =3335 uses Op903a ----------
Op903a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [903b] sub.b ($33,pc,d3.w*2), d0; =35 uses Op903b ----------
Op903b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [903c] sub.b #$33, d0 uses Op903c ----------
Op903c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9040] sub.w d0, d0 uses Op9040 ----------
Op9040:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9050] sub.w (a0), d0 uses Op9050 ----------
Op9050:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9058] sub.w (a0)+, d0 uses Op9058 ----------
Op9058:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9060] sub.w -(a0), d0 uses Op9060 ----------
Op9060:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9068] sub.w ($3333,a0), d0 uses Op9068 ----------
Op9068:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9070] sub.w ($33,a0,d3.w*2), d0 uses Op9070 ----------
Op9070:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9078] sub.w $3333.w, d0 uses Op9078 ----------
Op9078:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9079] sub.w $33333333.l, d0 uses Op9079 ----------
Op9079:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [907a] sub.w ($3333,pc), d0; =3335 uses Op907a ----------
Op907a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [907b] sub.w ($33,pc,d3.w*2), d0; =35 uses Op907b ----------
Op907b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [907c] sub.w #$3333, d0 uses Op907c ----------
Op907c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9080] sub.l d0, d0 uses Op9080 ----------
Op9080:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9090] sub.l (a0), d0 uses Op9090 ----------
Op9090:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9098] sub.l (a0)+, d0 uses Op9098 ----------
Op9098:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90a0] sub.l -(a0), d0 uses Op90a0 ----------
Op90a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90a8] sub.l ($3333,a0), d0 uses Op90a8 ----------
Op90a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90b0] sub.l ($33,a0,d3.w*2), d0 uses Op90b0 ----------
Op90b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90b8] sub.l $3333.w, d0 uses Op90b8 ----------
Op90b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90b9] sub.l $33333333.l, d0 uses Op90b9 ----------
Op90b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90ba] sub.l ($3333,pc), d0; =3335 uses Op90ba ----------
Op90ba:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90bb] sub.l ($33,pc,d3.w*2), d0; =35 uses Op90bb ----------
Op90bb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90bc] sub.l #$33333333, d0 uses Op90bc ----------
Op90bc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90c0] suba.w d0, a0 uses Op90c0 ----------
Op90c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90d0] suba.w (a0), a0 uses Op90d0 ----------
Op90d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90d8] suba.w (a0)+, a0 uses Op90d8 ----------
Op90d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90e0] suba.w -(a0), a0 uses Op90e0 ----------
Op90e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90e8] suba.w ($3333,a0), a0 uses Op90e8 ----------
Op90e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90f0] suba.w ($33,a0,d3.w*2), a0 uses Op90f0 ----------
Op90f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90f8] suba.w $3333.w, a0 uses Op90f8 ----------
Op90f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90f9] suba.w $33333333.l, a0 uses Op90f9 ----------
Op90f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90fa] suba.w ($3333,pc), a0; =3335 uses Op90fa ----------
Op90fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90fb] suba.w ($33,pc,d3.w*2), a0; =35 uses Op90fb ----------
Op90fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90fc] suba.w #$3333, a0 uses Op90fc ----------
Op90fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9100] subx.b d0, d0 uses Op9100 ----------
Op9100:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r6:
  and r6,r8,#0x0007
;@ EaRead : Read register[r6] into r6:
  ldr r6,[r7,r6,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsr #7]

  mov r6,r6,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r6,r0,asl #24
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsr #7]

  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9108] subx.b -(a0), -(a0) uses Op9108 ----------
Op9108:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x1e00
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r6,r0,asl #24
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [910f] subx.b -(a7), -(a0) uses Op910f ----------
Op910f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r6:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x1e00
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r6,r0,asl #24
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9110] sub.b d0, (a0) uses Op9110 ----------
Op9110:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9118] sub.b d0, (a0)+ uses Op9118 ----------
Op9118:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [911f] sub.b d0, (a7)+ uses Op911f ----------
Op911f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9120] sub.b d0, -(a0) uses Op9120 ----------
Op9120:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9127] sub.b d0, -(a7) uses Op9127 ----------
Op9127:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9128] sub.b d0, ($3333,a0) uses Op9128 ----------
Op9128:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9130] sub.b d0, ($33,a0,d3.w*2) uses Op9130 ----------
Op9130:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9138] sub.b d0, $3333.w uses Op9138 ----------
Op9138:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9139] sub.b d0, $33333333.l uses Op9139 ----------
Op9139:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9140] subx.w d0, d0 uses Op9140 ----------
Op9140:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r6:
  and r6,r8,#0x0007
;@ EaRead : Read register[r6] into r6:
  ldr r6,[r7,r6,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r6,r6,asl #16

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r6,r0,asl #16
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #16
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9148] subx.w -(a0), -(a0) uses Op9148 ----------
Op9148:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r6,r0,asl #16

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x1e00
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r6,r0,asl #16
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #16
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9150] sub.w d0, (a0) uses Op9150 ----------
Op9150:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9158] sub.w d0, (a0)+ uses Op9158 ----------
Op9158:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9160] sub.w d0, -(a0) uses Op9160 ----------
Op9160:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9168] sub.w d0, ($3333,a0) uses Op9168 ----------
Op9168:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9170] sub.w d0, ($33,a0,d3.w*2) uses Op9170 ----------
Op9170:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9178] sub.w d0, $3333.w uses Op9178 ----------
Op9178:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9179] sub.w d0, $33333333.l uses Op9179 ----------
Op9179:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9180] subx.l d0, d0 uses Op9180 ----------
Op9180:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r6:
  and r6,r8,#0x0007
;@ EaRead : Read register[r6] into r6:
  ldr r6,[r7,r6,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsr #7]

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r6,r0
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9188] subx.l -(a0), -(a0) uses Op9188 ----------
Op9188:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  mov r6,r0

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x1e00
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r6,r0
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9190] sub.l d0, (a0) uses Op9190 ----------
Op9190:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9198] sub.l d0, (a0)+ uses Op9198 ----------
Op9198:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91a0] sub.l d0, -(a0) uses Op91a0 ----------
Op91a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91a8] sub.l d0, ($3333,a0) uses Op91a8 ----------
Op91a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91b0] sub.l d0, ($33,a0,d3.w*2) uses Op91b0 ----------
Op91b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91b8] sub.l d0, $3333.w uses Op91b8 ----------
Op91b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91b9] sub.l d0, $33333333.l uses Op91b9 ----------
Op91b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91c0] suba.l d0, a0 uses Op91c0 ----------
Op91c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91d0] suba.l (a0), a0 uses Op91d0 ----------
Op91d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91d8] suba.l (a0)+, a0 uses Op91d8 ----------
Op91d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91e0] suba.l -(a0), a0 uses Op91e0 ----------
Op91e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91e8] suba.l ($3333,a0), a0 uses Op91e8 ----------
Op91e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91f0] suba.l ($33,a0,d3.w*2), a0 uses Op91f0 ----------
Op91f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91f8] suba.l $3333.w, a0 uses Op91f8 ----------
Op91f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91f9] suba.l $33333333.l, a0 uses Op91f9 ----------
Op91f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91fa] suba.l ($3333,pc), a0; =3335 uses Op91fa ----------
Op91fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91fb] suba.l ($33,pc,d3.w*2), a0; =35 uses Op91fb ----------
Op91fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91fc] suba.l #$33333333, a0 uses Op91fc ----------
Op91fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9f08] subx.b -(a0), -(a7) uses Op9f08 ----------
Op9f08:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r6,r0,asl #24
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9f0f] subx.b -(a7), -(a7) uses Op9f0f ----------
Op9f0f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r6:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r6,r0,asl #24
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b000] cmp.b d0, d0 uses Opb000 ----------
Opb000:
;@ Get EA into r11 and value into r0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b010] cmp.b (a0), d0 uses Opb010 ----------
Opb010:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b018] cmp.b (a0)+, d0 uses Opb018 ----------
Opb018:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b01f] cmp.b (a7)+, d0 uses Opb01f ----------
Opb01f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b020] cmp.b -(a0), d0 uses Opb020 ----------
Opb020:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b027] cmp.b -(a7), d0 uses Opb027 ----------
Opb027:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b028] cmp.b ($3333,a0), d0 uses Opb028 ----------
Opb028:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b030] cmp.b ($33,a0,d3.w*2), d0 uses Opb030 ----------
Opb030:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b039] cmp.b $33333333.l, d0 uses Opb039 ----------
Opb039:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b03a] cmp.b ($3333,pc), d0; =3335 uses Opb03a ----------
Opb03a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b03b] cmp.b ($33,pc,d3.w*2), d0; =35 uses Opb03b ----------
Opb03b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b03c] cmp.b #$33, d0 uses Opb03c ----------
Opb03c:
;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b040] cmp.w d0, d0 uses Opb040 ----------
Opb040:
;@ Get EA into r11 and value into r0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b050] cmp.w (a0), d0 uses Opb050 ----------
Opb050:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b058] cmp.w (a0)+, d0 uses Opb058 ----------
Opb058:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b060] cmp.w -(a0), d0 uses Opb060 ----------
Opb060:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b068] cmp.w ($3333,a0), d0 uses Opb068 ----------
Opb068:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b070] cmp.w ($33,a0,d3.w*2), d0 uses Opb070 ----------
Opb070:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b078] cmp.w $3333.w, d0 uses Opb078 ----------
Opb078:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b079] cmp.w $33333333.l, d0 uses Opb079 ----------
Opb079:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b07a] cmp.w ($3333,pc), d0; =3335 uses Opb07a ----------
Opb07a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b07b] cmp.w ($33,pc,d3.w*2), d0; =35 uses Opb07b ----------
Opb07b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b07c] cmp.w #$3333, d0 uses Opb07c ----------
Opb07c:
;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b080] cmp.l d0, d0 uses Opb080 ----------
Opb080:
;@ Get EA into r11 and value into r0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b090] cmp.l (a0), d0 uses Opb090 ----------
Opb090:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b098] cmp.l (a0)+, d0 uses Opb098 ----------
Opb098:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0a0] cmp.l -(a0), d0 uses Opb0a0 ----------
Opb0a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0a8] cmp.l ($3333,a0), d0 uses Opb0a8 ----------
Opb0a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0b0] cmp.l ($33,a0,d3.w*2), d0 uses Opb0b0 ----------
Opb0b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0b9] cmp.l $33333333.l, d0 uses Opb0b9 ----------
Opb0b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0ba] cmp.l ($3333,pc), d0; =3335 uses Opb0ba ----------
Opb0ba:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0bb] cmp.l ($33,pc,d3.w*2), d0; =35 uses Opb0bb ----------
Opb0bb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0bc] cmp.l #$33333333, d0 uses Opb0bc ----------
Opb0bc:
;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0c0] cmpa.w d0, a0 uses Opb0c0 ----------
Opb0c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0d0] cmpa.w (a0), a0 uses Opb0d0 ----------
Opb0d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0d8] cmpa.w (a0)+, a0 uses Opb0d8 ----------
Opb0d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0e0] cmpa.w -(a0), a0 uses Opb0e0 ----------
Opb0e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0e8] cmpa.w ($3333,a0), a0 uses Opb0e8 ----------
Opb0e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0f0] cmpa.w ($33,a0,d3.w*2), a0 uses Opb0f0 ----------
Opb0f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0f8] cmpa.w $3333.w, a0 uses Opb0f8 ----------
Opb0f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0f9] cmpa.w $33333333.l, a0 uses Opb0f9 ----------
Opb0f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0fa] cmpa.w ($3333,pc), a0; =3335 uses Opb0fa ----------
Opb0fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0fb] cmpa.w ($33,pc,d3.w*2), a0; =35 uses Opb0fb ----------
Opb0fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0fc] cmpa.w #$3333, a0 uses Opb0fc ----------
Opb0fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b100] eor.b d0, d0 uses Opb100 ----------
Opb100:
;@ Get EA into r11 and value into r0:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eors r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b108] cmpm.b (a0)+, (a0)+ uses Opb108 ----------
Opb108:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src operand into r11:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r11:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  rsbs r0,r11,r0,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b10f] cmpm.b (a7)+, (a0)+ uses Opb10f ----------
Opb10f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src operand into r11:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r11:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  rsbs r0,r11,r0,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b110] eor.b d0, (a0) uses Opb110 ----------
Opb110:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eors r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b118] eor.b d0, (a0)+ uses Opb118 ----------
Opb118:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eors r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b11f] eor.b d0, (a7)+ uses Opb11f ----------
Opb11f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eors r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b120] eor.b d0, -(a0) uses Opb120 ----------
Opb120:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eors r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b127] eor.b d0, -(a7) uses Opb127 ----------
Opb127:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eors r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b128] eor.b d0, ($3333,a0) uses Opb128 ----------
Opb128:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eors r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b130] eor.b d0, ($33,a0,d3.w*2) uses Opb130 ----------
Opb130:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eors r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b138] eor.b d0, $3333.w uses Opb138 ----------
Opb138:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eors r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b139] eor.b d0, $33333333.l uses Opb139 ----------
Opb139:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eors r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b140] eor.w d0, d0 uses Opb140 ----------
Opb140:
;@ Get EA into r11 and value into r0:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eors r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b148] cmpm.w (a0)+, (a0)+ uses Opb148 ----------
Opb148:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src operand into r11:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r11:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get dst operand into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

  rsbs r0,r11,r0,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b150] eor.w d0, (a0) uses Opb150 ----------
Opb150:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eors r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b158] eor.w d0, (a0)+ uses Opb158 ----------
Opb158:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eors r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b160] eor.w d0, -(a0) uses Opb160 ----------
Opb160:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eors r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b168] eor.w d0, ($3333,a0) uses Opb168 ----------
Opb168:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eors r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b170] eor.w d0, ($33,a0,d3.w*2) uses Opb170 ----------
Opb170:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eors r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b178] eor.w d0, $3333.w uses Opb178 ----------
Opb178:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eors r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b179] eor.w d0, $33333333.l uses Opb179 ----------
Opb179:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eors r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b180] eor.l d0, d0 uses Opb180 ----------
Opb180:
;@ Get EA into r11 and value into r0:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eors r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b188] cmpm.l (a0)+, (a0)+ uses Opb188 ----------
Opb188:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src operand into r11:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r11:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  mov r11,r0

;@ Get dst operand into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

  rsbs r0,r11,r0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b190] eor.l d0, (a0) uses Opb190 ----------
Opb190:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eors r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b198] eor.l d0, (a0)+ uses Opb198 ----------
Opb198:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eors r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1a0] eor.l d0, -(a0) uses Opb1a0 ----------
Opb1a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eors r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1a8] eor.l d0, ($3333,a0) uses Opb1a8 ----------
Opb1a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eors r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1b0] eor.l d0, ($33,a0,d3.w*2) uses Opb1b0 ----------
Opb1b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eors r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1b8] eor.l d0, $3333.w uses Opb1b8 ----------
Opb1b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eors r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1b9] eor.l d0, $33333333.l uses Opb1b9 ----------
Opb1b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eors r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1c0] cmpa.l d0, a0 uses Opb1c0 ----------
Opb1c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1d0] cmpa.l (a0), a0 uses Opb1d0 ----------
Opb1d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1d8] cmpa.l (a0)+, a0 uses Opb1d8 ----------
Opb1d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1e0] cmpa.l -(a0), a0 uses Opb1e0 ----------
Opb1e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1e8] cmpa.l ($3333,a0), a0 uses Opb1e8 ----------
Opb1e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1f0] cmpa.l ($33,a0,d3.w*2), a0 uses Opb1f0 ----------
Opb1f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1f8] cmpa.l $3333.w, a0 uses Opb1f8 ----------
Opb1f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1f9] cmpa.l $33333333.l, a0 uses Opb1f9 ----------
Opb1f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1fa] cmpa.l ($3333,pc), a0; =3335 uses Opb1fa ----------
Opb1fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1fb] cmpa.l ($33,pc,d3.w*2), a0; =35 uses Opb1fb ----------
Opb1fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1fc] cmpa.l #$33333333, a0 uses Opb1fc ----------
Opb1fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [bf08] cmpm.b (a0)+, (a7)+ uses Opbf08 ----------
Opbf08:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src operand into r11:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r11:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  rsbs r0,r11,r0,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [bf0f] cmpm.b (a7)+, (a7)+ uses Opbf0f ----------
Opbf0f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src operand into r11:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r11:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  rsbs r0,r11,r0,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c000] and.b d0, d0 uses Opc000 ----------
Opc000:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c010] and.b (a0), d0 uses Opc010 ----------
Opc010:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c018] and.b (a0)+, d0 uses Opc018 ----------
Opc018:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c01f] and.b (a7)+, d0 uses Opc01f ----------
Opc01f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c020] and.b -(a0), d0 uses Opc020 ----------
Opc020:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c027] and.b -(a7), d0 uses Opc027 ----------
Opc027:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c028] and.b ($3333,a0), d0 uses Opc028 ----------
Opc028:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c030] and.b ($33,a0,d3.w*2), d0 uses Opc030 ----------
Opc030:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c038] and.b $3333.w, d0 uses Opc038 ----------
Opc038:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c039] and.b $33333333.l, d0 uses Opc039 ----------
Opc039:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c03a] and.b ($3333,pc), d0; =3335 uses Opc03a ----------
Opc03a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c03b] and.b ($33,pc,d3.w*2), d0; =35 uses Opc03b ----------
Opc03b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c03c] and.b #$33, d0 uses Opc03c ----------
Opc03c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c050] and.w (a0), d0 uses Opc050 ----------
Opc050:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c058] and.w (a0)+, d0 uses Opc058 ----------
Opc058:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c060] and.w -(a0), d0 uses Opc060 ----------
Opc060:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c068] and.w ($3333,a0), d0 uses Opc068 ----------
Opc068:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c070] and.w ($33,a0,d3.w*2), d0 uses Opc070 ----------
Opc070:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c078] and.w $3333.w, d0 uses Opc078 ----------
Opc078:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c079] and.w $33333333.l, d0 uses Opc079 ----------
Opc079:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c07a] and.w ($3333,pc), d0; =3335 uses Opc07a ----------
Opc07a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c07b] and.w ($33,pc,d3.w*2), d0; =35 uses Opc07b ----------
Opc07b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c07c] and.w #$3333, d0 uses Opc07c ----------
Opc07c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c080] and.l d0, d0 uses Opc080 ----------
Opc080:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c090] and.l (a0), d0 uses Opc090 ----------
Opc090:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c098] and.l (a0)+, d0 uses Opc098 ----------
Opc098:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0a0] and.l -(a0), d0 uses Opc0a0 ----------
Opc0a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0a8] and.l ($3333,a0), d0 uses Opc0a8 ----------
Opc0a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0b0] and.l ($33,a0,d3.w*2), d0 uses Opc0b0 ----------
Opc0b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0b8] and.l $3333.w, d0 uses Opc0b8 ----------
Opc0b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0b9] and.l $33333333.l, d0 uses Opc0b9 ----------
Opc0b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0ba] and.l ($3333,pc), d0; =3335 uses Opc0ba ----------
Opc0ba:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0bb] and.l ($33,pc,d3.w*2), d0; =35 uses Opc0bb ----------
Opc0bb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0bc] and.l #$33333333, d0 uses Opc0bc ----------
Opc0bc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0c0] mulu.w d0, d0 uses Opc0c0 ----------
Opc0c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#54 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0d0] mulu.w (a0), d0 uses Opc0d0 ----------
Opc0d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0d8] mulu.w (a0)+, d0 uses Opc0d8 ----------
Opc0d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0e0] mulu.w -(a0), d0 uses Opc0e0 ----------
Opc0e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#60 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0e8] mulu.w ($3333,a0), d0 uses Opc0e8 ----------
Opc0e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0f0] mulu.w ($33,a0,d3.w*2), d0 uses Opc0f0 ----------
Opc0f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#64 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0f8] mulu.w $3333.w, d0 uses Opc0f8 ----------
Opc0f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0f9] mulu.w $33333333.l, d0 uses Opc0f9 ----------
Opc0f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#66 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0fa] mulu.w ($3333,pc), d0; =3335 uses Opc0fa ----------
Opc0fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0fb] mulu.w ($33,pc,d3.w*2), d0; =35 uses Opc0fb ----------
Opc0fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#64 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0fc] mulu.w #$3333, d0 uses Opc0fc ----------
Opc0fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c100] abcd d0, d0 uses Opc100 ----------
Opc100:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r6:
  and r6,r8,#0x0007
;@ EaRead : Read register[r6] into r6:
  ldr r6,[r7,r6,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsr #7]

  mov r6,r6,asl #24
  mov r1,r0,asl #24

  bic r10,r10,#0xb1000000 ;@ clear all flags except old Z
  ldr r0,[r7,#0x4c] ;@ Get X bit
  mov r3,#0x00f00000
  and r2,r3,r1,lsr #4
  tst r0,#0x20000000
  and r0,r3,r6,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r6,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r10,r10,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r10,r10,#0x90000000 ;@ Undefined N+V behavior
  bicne r10,r10,#0x40000000 ;@ Z flag
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsr #7]

  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c108] abcd -(a0), -(a0) uses Opc108 ----------
Opc108:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r1,r0,asl #24

  bic r10,r10,#0xb1000000 ;@ clear all flags except old Z
  ldr r0,[r7,#0x4c] ;@ Get X bit
  mov r3,#0x00f00000
  and r2,r3,r1,lsr #4
  tst r0,#0x20000000
  and r0,r3,r6,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r6,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r10,r10,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r10,r10,#0x90000000 ;@ Undefined N+V behavior
  bicne r10,r10,#0x40000000 ;@ Z flag
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c10f] abcd -(a7), -(a0) uses Opc10f ----------
Opc10f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r6:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r1,r0,asl #24

  bic r10,r10,#0xb1000000 ;@ clear all flags except old Z
  ldr r0,[r7,#0x4c] ;@ Get X bit
  mov r3,#0x00f00000
  and r2,r3,r1,lsr #4
  tst r0,#0x20000000
  and r0,r3,r6,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r6,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r10,r10,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r10,r10,#0x90000000 ;@ Undefined N+V behavior
  bicne r10,r10,#0x40000000 ;@ Z flag
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c110] and.b d0, (a0) uses Opc110 ----------
Opc110:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c118] and.b d0, (a0)+ uses Opc118 ----------
Opc118:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c11f] and.b d0, (a7)+ uses Opc11f ----------
Opc11f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c120] and.b d0, -(a0) uses Opc120 ----------
Opc120:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c127] and.b d0, -(a7) uses Opc127 ----------
Opc127:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c128] and.b d0, ($3333,a0) uses Opc128 ----------
Opc128:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c130] and.b d0, ($33,a0,d3.w*2) uses Opc130 ----------
Opc130:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c138] and.b d0, $3333.w uses Opc138 ----------
Opc138:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c139] and.b d0, $33333333.l uses Opc139 ----------
Opc139:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c140] exg d0, d0 uses Opc140 ----------
Opc140:
  and r2,r8,#0x0e00 ;@ Find T register
  and r3,r8,#0x000f ;@ Find S register

  ldr r0,[r7,r2,lsr #7] ;@ Get T
  ldr r1,[r7,r3,lsl #2] ;@ Get S

  str r0,[r7,r3,lsl #2] ;@ T->S
  str r1,[r7,r2,lsr #7] ;@ S->T

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c148] exg a0, a0 uses Opc148 ----------
Opc148:
  and r2,r8,#0x0e00 ;@ Find T register
  and r3,r8,#0x000f ;@ Find S register
  orr r2,r2,#0x1000 ;@ T is an address register

  ldr r0,[r7,r2,lsr #7] ;@ Get T
  ldr r1,[r7,r3,lsl #2] ;@ Get S

  str r0,[r7,r3,lsl #2] ;@ T->S
  str r1,[r7,r2,lsr #7] ;@ S->T

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c150] and.w d0, (a0) uses Opc150 ----------
Opc150:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c158] and.w d0, (a0)+ uses Opc158 ----------
Opc158:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c160] and.w d0, -(a0) uses Opc160 ----------
Opc160:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c168] and.w d0, ($3333,a0) uses Opc168 ----------
Opc168:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c170] and.w d0, ($33,a0,d3.w*2) uses Opc170 ----------
Opc170:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c178] and.w d0, $3333.w uses Opc178 ----------
Opc178:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c179] and.w d0, $33333333.l uses Opc179 ----------
Opc179:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c188] exg a0, d0 uses Opc188 ----------
Opc188:
  and r2,r8,#0x0e00 ;@ Find T register
  and r3,r8,#0x000f ;@ Find S register

  ldr r0,[r7,r2,lsr #7] ;@ Get T
  ldr r1,[r7,r3,lsl #2] ;@ Get S

  str r0,[r7,r3,lsl #2] ;@ T->S
  str r1,[r7,r2,lsr #7] ;@ S->T

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c190] and.l d0, (a0) uses Opc190 ----------
Opc190:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c198] and.l d0, (a0)+ uses Opc198 ----------
Opc198:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1a0] and.l d0, -(a0) uses Opc1a0 ----------
Opc1a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1a8] and.l d0, ($3333,a0) uses Opc1a8 ----------
Opc1a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1b0] and.l d0, ($33,a0,d3.w*2) uses Opc1b0 ----------
Opc1b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1b8] and.l d0, $3333.w uses Opc1b8 ----------
Opc1b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1b9] and.l d0, $33333333.l uses Opc1b9 ----------
Opc1b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1c0] muls.w d0, d0 uses Opc1c0 ----------
Opc1c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#54 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1d0] muls.w (a0), d0 uses Opc1d0 ----------
Opc1d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1d8] muls.w (a0)+, d0 uses Opc1d8 ----------
Opc1d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1e0] muls.w -(a0), d0 uses Opc1e0 ----------
Opc1e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#60 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1e8] muls.w ($3333,a0), d0 uses Opc1e8 ----------
Opc1e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1f0] muls.w ($33,a0,d3.w*2), d0 uses Opc1f0 ----------
Opc1f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#64 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1f8] muls.w $3333.w, d0 uses Opc1f8 ----------
Opc1f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1f9] muls.w $33333333.l, d0 uses Opc1f9 ----------
Opc1f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#66 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1fa] muls.w ($3333,pc), d0; =3335 uses Opc1fa ----------
Opc1fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1fb] muls.w ($33,pc,d3.w*2), d0; =35 uses Opc1fb ----------
Opc1fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#64 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1fc] muls.w #$3333, d0 uses Opc1fc ----------
Opc1fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [cf08] abcd -(a0), -(a7) uses Opcf08 ----------
Opcf08:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r1,r0,asl #24

  bic r10,r10,#0xb1000000 ;@ clear all flags except old Z
  ldr r0,[r7,#0x4c] ;@ Get X bit
  mov r3,#0x00f00000
  and r2,r3,r1,lsr #4
  tst r0,#0x20000000
  and r0,r3,r6,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r6,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r10,r10,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r10,r10,#0x90000000 ;@ Undefined N+V behavior
  bicne r10,r10,#0x40000000 ;@ Z flag
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [cf0f] abcd -(a7), -(a7) uses Opcf0f ----------
Opcf0f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r6:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

  mov r1,r0,asl #24

  bic r10,r10,#0xb1000000 ;@ clear all flags except old Z
  ldr r0,[r7,#0x4c] ;@ Get X bit
  mov r3,#0x00f00000
  and r2,r3,r1,lsr #4
  tst r0,#0x20000000
  and r0,r3,r6,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r6,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r10,r10,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r10,r10,#0x90000000 ;@ Undefined N+V behavior
  bicne r10,r10,#0x40000000 ;@ Z flag
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d000] add.b d0, d0 uses Opd000 ----------
Opd000:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d010] add.b (a0), d0 uses Opd010 ----------
Opd010:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d018] add.b (a0)+, d0 uses Opd018 ----------
Opd018:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d01f] add.b (a7)+, d0 uses Opd01f ----------
Opd01f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d020] add.b -(a0), d0 uses Opd020 ----------
Opd020:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d027] add.b -(a7), d0 uses Opd027 ----------
Opd027:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d028] add.b ($3333,a0), d0 uses Opd028 ----------
Opd028:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d030] add.b ($33,a0,d3.w*2), d0 uses Opd030 ----------
Opd030:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d038] add.b $3333.w, d0 uses Opd038 ----------
Opd038:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d039] add.b $33333333.l, d0 uses Opd039 ----------
Opd039:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d03a] add.b ($3333,pc), d0; =3335 uses Opd03a ----------
Opd03a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d03b] add.b ($33,pc,d3.w*2), d0; =35 uses Opd03b ----------
Opd03b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d03c] add.b #$33, d0 uses Opd03c ----------
Opd03c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d050] add.w (a0), d0 uses Opd050 ----------
Opd050:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d058] add.w (a0)+, d0 uses Opd058 ----------
Opd058:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d060] add.w -(a0), d0 uses Opd060 ----------
Opd060:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d068] add.w ($3333,a0), d0 uses Opd068 ----------
Opd068:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d070] add.w ($33,a0,d3.w*2), d0 uses Opd070 ----------
Opd070:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d078] add.w $3333.w, d0 uses Opd078 ----------
Opd078:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d079] add.w $33333333.l, d0 uses Opd079 ----------
Opd079:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d07a] add.w ($3333,pc), d0; =3335 uses Opd07a ----------
Opd07a:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d07b] add.w ($33,pc,d3.w*2), d0; =35 uses Opd07b ----------
Opd07b:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d07c] add.w #$3333, d0 uses Opd07c ----------
Opd07c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d080] add.l d0, d0 uses Opd080 ----------
Opd080:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d090] add.l (a0), d0 uses Opd090 ----------
Opd090:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d098] add.l (a0)+, d0 uses Opd098 ----------
Opd098:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0a0] add.l -(a0), d0 uses Opd0a0 ----------
Opd0a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0a8] add.l ($3333,a0), d0 uses Opd0a8 ----------
Opd0a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0b0] add.l ($33,a0,d3.w*2), d0 uses Opd0b0 ----------
Opd0b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0b8] add.l $3333.w, d0 uses Opd0b8 ----------
Opd0b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0b9] add.l $33333333.l, d0 uses Opd0b9 ----------
Opd0b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0ba] add.l ($3333,pc), d0; =3335 uses Opd0ba ----------
Opd0ba:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0bb] add.l ($33,pc,d3.w*2), d0; =35 uses Opd0bb ----------
Opd0bb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0bc] add.l #$33333333, d0 uses Opd0bc ----------
Opd0bc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0c0] adda.w d0, a0 uses Opd0c0 ----------
Opd0c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0d0] adda.w (a0), a0 uses Opd0d0 ----------
Opd0d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0d8] adda.w (a0)+, a0 uses Opd0d8 ----------
Opd0d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0e0] adda.w -(a0), a0 uses Opd0e0 ----------
Opd0e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0e8] adda.w ($3333,a0), a0 uses Opd0e8 ----------
Opd0e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0f0] adda.w ($33,a0,d3.w*2), a0 uses Opd0f0 ----------
Opd0f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0f8] adda.w $3333.w, a0 uses Opd0f8 ----------
Opd0f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0f9] adda.w $33333333.l, a0 uses Opd0f9 ----------
Opd0f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0fa] adda.w ($3333,pc), a0; =3335 uses Opd0fa ----------
Opd0fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0fb] adda.w ($33,pc,d3.w*2), a0; =35 uses Opd0fb ----------
Opd0fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0fc] adda.w #$3333, a0 uses Opd0fc ----------
Opd0fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d100] addx.b d0, d0 uses Opd100 ----------
Opd100:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r6:
  and r6,r8,#0x0007
;@ EaRead : Read register[r6] into r6:
  ldr r6,[r7,r6,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsr #7]

  mov r6,r6,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r6,r6,r2,lsr #8

  adcs r1,r6,r0,asl #24
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsr #7]

  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d108] addx.b -(a0), -(a0) uses Opd108 ----------
Opd108:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x1e00
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r6,r6,r2,lsr #8

  adcs r1,r6,r0,asl #24
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d10f] addx.b -(a7), -(a0) uses Opd10f ----------
Opd10f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r6:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x1e00
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r6,r6,r2,lsr #8

  adcs r1,r6,r0,asl #24
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d110] add.b d0, (a0) uses Opd110 ----------
Opd110:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d118] add.b d0, (a0)+ uses Opd118 ----------
Opd118:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d11f] add.b d0, (a7)+ uses Opd11f ----------
Opd11f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d120] add.b d0, -(a0) uses Opd120 ----------
Opd120:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d127] add.b d0, -(a7) uses Opd127 ----------
Opd127:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d128] add.b d0, ($3333,a0) uses Opd128 ----------
Opd128:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d130] add.b d0, ($33,a0,d3.w*2) uses Opd130 ----------
Opd130:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d138] add.b d0, $3333.w uses Opd138 ----------
Opd138:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d139] add.b d0, $33333333.l uses Opd139 ----------
Opd139:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  and r1,r1,#0xff
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d140] addx.w d0, d0 uses Opd140 ----------
Opd140:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r6:
  and r6,r8,#0x0007
;@ EaRead : Read register[r6] into r6:
  ldr r6,[r7,r6,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r6,r6,asl #16

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r6,r6,r2,lsr #16

  adcs r1,r6,r0,asl #16
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #16
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d148] addx.w -(a0), -(a0) uses Opd148 ----------
Opd148:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r6,r0,asl #16

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x1e00
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r6,r6,r2,lsr #16

  adcs r1,r6,r0,asl #16
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #16
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d150] add.w d0, (a0) uses Opd150 ----------
Opd150:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d158] add.w d0, (a0)+ uses Opd158 ----------
Opd158:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d160] add.w d0, -(a0) uses Opd160 ----------
Opd160:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d168] add.w d0, ($3333,a0) uses Opd168 ----------
Opd168:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d170] add.w d0, ($33,a0,d3.w*2) uses Opd170 ----------
Opd170:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d178] add.w d0, $3333.w uses Opd178 ----------
Opd178:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d179] add.w d0, $33333333.l uses Opd179 ----------
Opd179:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  uxth r1,r1 ;@ zero extend
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d180] addx.l d0, d0 uses Opd180 ----------
Opd180:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r6:
  and r6,r8,#0x0007
;@ EaRead : Read register[r6] into r6:
  ldr r6,[r7,r6,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsr #7]

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  adcs r1,r6,r0
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d188] addx.l -(a0), -(a0) uses Opd188 ----------
Opd188:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler
  mov r6,r0

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x1e00
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  adcs r1,r6,r0
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d190] add.l d0, (a0) uses Opd190 ----------
Opd190:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d198] add.l d0, (a0)+ uses Opd198 ----------
Opd198:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1a0] add.l d0, -(a0) uses Opd1a0 ----------
Opd1a0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1a8] add.l d0, ($3333,a0) uses Opd1a8 ----------
Opd1a8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1b0] add.l d0, ($33,a0,d3.w*2) uses Opd1b0 ----------
Opd1b0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1b8] add.l d0, $3333.w uses Opd1b8 ----------
Opd1b8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1b9] add.l d0, $33333333.l uses Opd1b9 ----------
Opd1b9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  bic r0,r11,#0xff000000
  bl m68k_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1c0] adda.l d0, a0 uses Opd1c0 ----------
Opd1c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1d0] adda.l (a0), a0 uses Opd1d0 ----------
Opd1d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1d8] adda.l (a0)+, a0 uses Opd1d8 ----------
Opd1d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1e0] adda.l -(a0), a0 uses Opd1e0 ----------
Opd1e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1e8] adda.l ($3333,a0), a0 uses Opd1e8 ----------
Opd1e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1f0] adda.l ($33,a0,d3.w*2), a0 uses Opd1f0 ----------
Opd1f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1f8] adda.l $3333.w, a0 uses Opd1f8 ----------
Opd1f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1f9] adda.l $33333333.l, a0 uses Opd1f9 ----------
Opd1f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1fa] adda.l ($3333,pc), a0; =3335 uses Opd1fa ----------
Opd1fa:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1fb] adda.l ($33,pc,d3.w*2), a0; =35 uses Opd1fb ----------
Opd1fb:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1fc] adda.l #$33333333, a0 uses Opd1fc ----------
Opd1fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [df08] addx.b -(a0), -(a7) uses Opdf08 ----------
Opdf08:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r6,r6,r2,lsr #8

  adcs r1,r6,r0,asl #24
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [df0f] addx.b -(a7), -(a7) uses Opdf0f ----------
Opdf0f:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r6:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r0,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  bic r0,r11,#0xff000000
  bl m68k_read8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r6,r6,r2,lsr #8

  adcs r1,r6,r0,asl #24
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  bic r0,r11,#0xff000000
  bl m68k_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e000] asr.b #8, d0 uses Ope000 ----------
Ope000:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #24

;@ Shift register:
  movs r0,r0,asr #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #24

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e008] lsr.b #8, d0 uses Ope008 ----------
Ope008:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #24

;@ Shift register:
  movs r0,r0,lsr #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #24
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e010] roxr.b #8, d0 uses Ope010 ----------
Ope010:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  mov r2,#8
  mov r0,r0,lsr #24 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#8
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e018] ror.b #8, d0 uses Ope018 ----------
Ope018:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #8
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e020] asr.b d0, d0 uses Ope020 ----------
Ope020:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #24

;@ Shift register:
  movs r0,r0,asr r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #24

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e028] lsr.b d0, d0 uses Ope028 ----------
Ope028:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #24

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #24
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e030] roxr.b d0, d0 uses Ope030 ----------
Ope030:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Reduce r2 until <0:
Reduce_e030:
  subs r2,r2,#9
  bpl Reduce_e030
  adds r2,r2,#9 ;@ Now r2=0-8
  beq norotx_e030

  mov r0,r0,lsr #24 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#8
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ if not 0, Save X bit
  b nozeroxe030
norotx_e030:
  ldr r2,[r7,#0x4c]
  adds r0,r0,#0 ;@ Define flags
  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  and r2,r2,#0x20000000
  orr r10,r10,r2 ;@ C = old_X
nozeroxe030:

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e038] ror.b d0, d0 uses Ope038 ----------
Ope038:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e040] asr.w #8, d0 uses Ope040 ----------
Ope040:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e048] lsr.w #8, d0 uses Ope048 ----------
Ope048:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e050] roxr.w #8, d0 uses Ope050 ----------
Ope050:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  mov r2,#8
  mov r0,r0,lsr #16 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#16
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e058] ror.w #8, d0 uses Ope058 ----------
Ope058:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #8
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e060] asr.w d0, d0 uses Ope060 ----------
Ope060:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e068] lsr.w d0, d0 uses Ope068 ----------
Ope068:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e070] roxr.w d0, d0 uses Ope070 ----------
Ope070:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Reduce r2 until <0:
Reduce_e070:
  subs r2,r2,#17
  bpl Reduce_e070
  adds r2,r2,#17 ;@ Now r2=0-16
  beq norotx_e070

  mov r0,r0,lsr #16 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#16
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ if not 0, Save X bit
  b nozeroxe070
norotx_e070:
  ldr r2,[r7,#0x4c]
  adds r0,r0,#0 ;@ Define flags
  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  and r2,r2,#0x20000000
  orr r10,r10,r2 ;@ C = old_X
nozeroxe070:

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e078] ror.w d0, d0 uses Ope078 ----------
Ope078:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e080] asr.l #8, d0 uses Ope080 ----------
Ope080:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Shift register:
  movs r0,r0,asr #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e088] lsr.l #8, d0 uses Ope088 ----------
Ope088:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Shift register:
  movs r0,r0,lsr #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e090] roxr.l #8, d0 uses Ope090 ----------
Ope090:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r2,#8

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#32
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e098] ror.l #8, d0 uses Ope098 ----------
Ope098:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #8
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0a0] asr.l d0, d0 uses Ope0a0 ----------
Ope0a0:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,asr r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0a8] lsr.l d0, d0 uses Ope0a8 ----------
Ope0a8:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0b0] roxr.l d0, d0 uses Ope0b0 ----------
Ope0b0:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  subs r2,r2,#33
  addmis r2,r2,#33 ;@ Now r2=0-32
  beq norotx_e0b0


;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#32
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ if not 0, Save X bit
  b nozeroxe0b0
norotx_e0b0:
  ldr r2,[r7,#0x4c]
  adds r0,r0,#0 ;@ Define flags
  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  and r2,r2,#0x20000000
  orr r10,r10,r2 ;@ C = old_X
nozeroxe0b0:

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0b8] ror.l d0, d0 uses Ope0b8 ----------
Ope0b8:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0d0] asr.w (a0) uses Ope0d0 ----------
Ope0d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '(a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0d8] asr.w (a0)+ uses Ope0d8 ----------
Ope0d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '(a0)+' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0e0] asr.w -(a0) uses Ope0e0 ----------
Ope0e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0e8] asr.w ($3333,a0) uses Ope0e8 ----------
Ope0e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '($3333,a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0f0] asr.w ($33,a0,d3.w*2) uses Ope0f0 ----------
Ope0f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0f8] asr.w $3333.w uses Ope0f8 ----------
Ope0f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '$3333.w' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0f9] asr.w $33333333.l uses Ope0f9 ----------
Ope0f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '$33333333.l' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e100] asl.b #8, d0 uses Ope100 ----------
Ope100:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #8
  cmpne r3,r1,asr #8
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e108] lsl.b #8, d0 uses Ope108 ----------
Ope108:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Shift register:
  movs r0,r0,lsl #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e110] roxl.b #8, d0 uses Ope110 ----------
Ope110:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  mov r2,#1 ;@ Reversed
  mov r0,r0,lsr #24 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#8
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e118] rol.b #8, d0 uses Ope118 ----------
Ope118:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #24
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e120] asl.b d0, d0 uses Ope120 ----------
Ope120:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e128] lsl.b d0, d0 uses Ope128 ----------
Ope128:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e130] roxl.b d0, d0 uses Ope130 ----------
Ope130:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Reduce r2 until <0:
Reduce_e130:
  subs r2,r2,#9
  bpl Reduce_e130
  adds r2,r2,#9 ;@ Now r2=0-8
  beq norotx_e130

  rsb r2,r2,#9 ;@ Reverse direction
  mov r0,r0,lsr #24 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#8
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ if not 0, Save X bit
  b nozeroxe130
norotx_e130:
  ldr r2,[r7,#0x4c]
  adds r0,r0,#0 ;@ Define flags
  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  and r2,r2,#0x20000000
  orr r10,r10,r2 ;@ C = old_X
nozeroxe130:

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e138] rol.b d0, d0 uses Ope138 ----------
Ope138:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  rsb r2,r2,#32
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  cmp r2,#32 ;@ rotating by 0?
  tstne r0,#1 ;@ no, check bit 0
  orrne r10,r10,#0x20000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e140] asl.w #8, d0 uses Ope140 ----------
Ope140:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #8
  cmpne r3,r1,asr #8
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e148] lsl.w #8, d0 uses Ope148 ----------
Ope148:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e150] roxl.w #8, d0 uses Ope150 ----------
Ope150:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  mov r2,#9 ;@ Reversed
  mov r0,r0,lsr #16 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#16
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e158] rol.w #8, d0 uses Ope158 ----------
Ope158:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #24
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e160] asl.w d0, d0 uses Ope160 ----------
Ope160:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e168] lsl.w d0, d0 uses Ope168 ----------
Ope168:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e170] roxl.w d0, d0 uses Ope170 ----------
Ope170:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Reduce r2 until <0:
Reduce_e170:
  subs r2,r2,#17
  bpl Reduce_e170
  adds r2,r2,#17 ;@ Now r2=0-16
  beq norotx_e170

  rsb r2,r2,#17 ;@ Reverse direction
  mov r0,r0,lsr #16 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#16
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ if not 0, Save X bit
  b nozeroxe170
norotx_e170:
  ldr r2,[r7,#0x4c]
  adds r0,r0,#0 ;@ Define flags
  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  and r2,r2,#0x20000000
  orr r10,r10,r2 ;@ C = old_X
nozeroxe170:

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e178] rol.w d0, d0 uses Ope178 ----------
Ope178:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  rsb r2,r2,#32
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  cmp r2,#32 ;@ rotating by 0?
  tstne r0,#1 ;@ no, check bit 0
  orrne r10,r10,#0x20000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e180] asl.l #8, d0 uses Ope180 ----------
Ope180:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #8
  cmpne r3,r1,asr #8
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e188] lsl.l #8, d0 uses Ope188 ----------
Ope188:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Shift register:
  movs r0,r0,lsl #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e190] roxl.l #8, d0 uses Ope190 ----------
Ope190:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r2,#25 ;@ Reversed

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#32
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e198] rol.l #8, d0 uses Ope198 ----------
Ope198:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Rotate register:
  movs r0,r0,ror #24
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1a0] asl.l d0, d0 uses Ope1a0 ----------
Ope1a0:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1a8] lsl.l d0, d0 uses Ope1a8 ----------
Ope1a8:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1b0] roxl.l d0, d0 uses Ope1b0 ----------
Ope1b0:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  subs r2,r2,#33
  addmis r2,r2,#33 ;@ Now r2=0-32
  beq norotx_e1b0

  rsb r2,r2,#33 ;@ Reverse direction

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#32
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ if not 0, Save X bit
  b nozeroxe1b0
norotx_e1b0:
  ldr r2,[r7,#0x4c]
  adds r0,r0,#0 ;@ Define flags
  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  and r2,r2,#0x20000000
  orr r10,r10,r2 ;@ C = old_X
nozeroxe1b0:

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1b8] rol.l d0, d0 uses Ope1b8 ----------
Ope1b8:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register:
  rsb r2,r2,#32
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  cmp r2,#32 ;@ rotating by 0?
  tstne r0,#1 ;@ no, check bit 0
  orrne r10,r10,#0x20000000

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1d0] asl.w (a0) uses Ope1d0 ----------
Ope1d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: Write r0 into '(a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1d8] asl.w (a0)+ uses Ope1d8 ----------
Ope1d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: Write r0 into '(a0)+' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1e0] asl.w -(a0) uses Ope1e0 ----------
Ope1e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1e8] asl.w ($3333,a0) uses Ope1e8 ----------
Ope1e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: Write r0 into '($3333,a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1f0] asl.w ($33,a0,d3.w*2) uses Ope1f0 ----------
Ope1f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1f8] asl.w $3333.w uses Ope1f8 ----------
Ope1f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: Write r0 into '$3333.w' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1f9] asl.w $33333333.l uses Ope1f9 ----------
Ope1f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: Write r0 into '$33333333.l' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e210] roxr.b #1, d0 uses Ope210 ----------
Ope210:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  orr r0,r0,r0,lsr #24
  bic r0,r0,#0x1000000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e250] roxr.w #1, d0 uses Ope250 ----------
Ope250:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e290] roxr.l #1, d0 uses Ope290 ----------
Ope290:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2d0] lsr.w (a0) uses Ope2d0 ----------
Ope2d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '(a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2d8] lsr.w (a0)+ uses Ope2d8 ----------
Ope2d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '(a0)+' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2e0] lsr.w -(a0) uses Ope2e0 ----------
Ope2e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2e8] lsr.w ($3333,a0) uses Ope2e8 ----------
Ope2e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '($3333,a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2f0] lsr.w ($33,a0,d3.w*2) uses Ope2f0 ----------
Ope2f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2f8] lsr.w $3333.w uses Ope2f8 ----------
Ope2f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '$3333.w' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2f9] lsr.w $33333333.l uses Ope2f9 ----------
Ope2f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '$33333333.l' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e310] roxl.b #1, d0 uses Ope310 ----------
Ope310:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x1000000
  bicne r10,r10,#0x40000000 ;@ clear Z in case it got there
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e350] roxl.w #1, d0 uses Ope350 ----------
Ope350:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r10,r10,#0x40000000 ;@ clear Z in case it got there
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e390] roxl.l #1, d0 uses Ope390 ----------
Ope390:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x1
  bicne r10,r10,#0x40000000 ;@ clear Z in case it got there
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3d0] lsl.w (a0) uses Ope3d0 ----------
Ope3d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '(a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3d8] lsl.w (a0)+ uses Ope3d8 ----------
Ope3d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '(a0)+' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3e0] lsl.w -(a0) uses Ope3e0 ----------
Ope3e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3e8] lsl.w ($3333,a0) uses Ope3e8 ----------
Ope3e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '($3333,a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3f0] lsl.w ($33,a0,d3.w*2) uses Ope3f0 ----------
Ope3f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3f8] lsl.w $3333.w uses Ope3f8 ----------
Ope3f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '$3333.w' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3f9] lsl.w $33333333.l uses Ope3f9 ----------
Ope3f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '$33333333.l' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4d0] roxr.w (a0) uses Ope4d0 ----------
Ope4d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '(a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4d8] roxr.w (a0)+ uses Ope4d8 ----------
Ope4d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '(a0)+' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4e0] roxr.w -(a0) uses Ope4e0 ----------
Ope4e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4e8] roxr.w ($3333,a0) uses Ope4e8 ----------
Ope4e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '($3333,a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4f0] roxr.w ($33,a0,d3.w*2) uses Ope4f0 ----------
Ope4f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4f8] roxr.w $3333.w uses Ope4f8 ----------
Ope4f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '$3333.w' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4f9] roxr.w $33333333.l uses Ope4f9 ----------
Ope4f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '$33333333.l' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5d0] roxl.w (a0) uses Ope5d0 ----------
Ope5d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r10,r10,#0x40000000 ;@ clear Z in case it got there
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '(a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5d8] roxl.w (a0)+ uses Ope5d8 ----------
Ope5d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r10,r10,#0x40000000 ;@ clear Z in case it got there
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '(a0)+' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5e0] roxl.w -(a0) uses Ope5e0 ----------
Ope5e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r10,r10,#0x40000000 ;@ clear Z in case it got there
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5e8] roxl.w ($3333,a0) uses Ope5e8 ----------
Ope5e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r10,r10,#0x40000000 ;@ clear Z in case it got there
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '($3333,a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5f0] roxl.w ($33,a0,d3.w*2) uses Ope5f0 ----------
Ope5f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r10,r10,#0x40000000 ;@ clear Z in case it got there
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5f8] roxl.w $3333.w uses Ope5f8 ----------
Ope5f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r10,r10,#0x40000000 ;@ clear Z in case it got there
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '$3333.w' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5f9] roxl.w $33333333.l uses Ope5f9 ----------
Ope5f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r10,r10,#0x40000000 ;@ clear Z in case it got there
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '$33333333.l' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6d0] ror.w (a0) uses Ope6d0 ----------
Ope6d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: Write r0 into '(a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6d8] ror.w (a0)+ uses Ope6d8 ----------
Ope6d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: Write r0 into '(a0)+' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6e0] ror.w -(a0) uses Ope6e0 ----------
Ope6e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6e8] ror.w ($3333,a0) uses Ope6e8 ----------
Ope6e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: Write r0 into '($3333,a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6f0] ror.w ($33,a0,d3.w*2) uses Ope6f0 ----------
Ope6f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6f8] ror.w $3333.w uses Ope6f8 ----------
Ope6f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: Write r0 into '$3333.w' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6f9] ror.w $33333333.l uses Ope6f9 ----------
Ope6f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: Write r0 into '$33333333.l' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7d0] rol.w (a0) uses Ope7d0 ----------
Ope7d0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: Write r0 into '(a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7d8] rol.w (a0)+ uses Ope7d8 ----------
Ope7d8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: Write r0 into '(a0)+' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7e0] rol.w -(a0) uses Ope7e0 ----------
Ope7e0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7e8] rol.w ($3333,a0) uses Ope7e8 ----------
Ope7e8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: Write r0 into '($3333,a0)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7f0] rol.w ($33,a0,d3.w*2) uses Ope7f0 ----------
Ope7f0:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7f8] rol.w $3333.w uses Ope7f8 ----------
Ope7f8:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: Write r0 into '$3333.w' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7f9] rol.w $33333333.l uses Ope7f9 ----------
Ope7f9:
  str r4,[r7,#0x50] ;@ Save prev PC + 2
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  str r4,[r7,#0x40] ;@ Save PC
  bic r0,r11,#0xff000000
  bl m68k_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: Write r0 into '$33333333.l' (address in r11):
  mov r1,r0,lsr #16
  bic r0,r11,#0xff000000
  bl m68k_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee00] asr.b #7, d0 uses Opee00 ----------
Opee00:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #24

;@ Shift register:
  movs r0,r0,asr r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #24

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee08] lsr.b #7, d0 uses Opee08 ----------
Opee08:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #24

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #24
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee10] roxr.b #7, d0 uses Opee10 ----------
Opee10:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  mov r0,r0,lsr #24 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#8
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee18] ror.b #7, d0 uses Opee18 ----------
Opee18:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee40] asr.w #7, d0 uses Opee40 ----------
Opee40:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee48] lsr.w #7, d0 uses Opee48 ----------
Opee48:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee50] roxr.w #7, d0 uses Opee50 ----------
Opee50:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  mov r0,r0,lsr #16 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#16
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee58] ror.w #7, d0 uses Opee58 ----------
Opee58:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee80] asr.l #7, d0 uses Opee80 ----------
Opee80:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,asr r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee88] lsr.l #7, d0 uses Opee88 ----------
Opee88:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee90] roxr.l #7, d0 uses Opee90 ----------
Opee90:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles


;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#32
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee98] ror.l #7, d0 uses Opee98 ----------
Opee98:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef00] asl.b #7, d0 uses Opef00 ----------
Opef00:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef08] lsl.b #7, d0 uses Opef08 ----------
Opef08:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef10] roxl.b #7, d0 uses Opef10 ----------
Opef10:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  rsb r2,r2,#9 ;@ Reverse direction
  mov r0,r0,lsr #24 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#8
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef18] rol.b #7, d0 uses Opef18 ----------
Opef18:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  rsb r2,r2,#32
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef40] asl.w #7, d0 uses Opef40 ----------
Opef40:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef48] lsl.w #7, d0 uses Opef48 ----------
Opef48:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef50] roxl.w #7, d0 uses Opef50 ----------
Opef50:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  rsb r2,r2,#17 ;@ Reverse direction
  mov r0,r0,lsr #16 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#16
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef58] rol.w #7, d0 uses Opef58 ----------
Opef58:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  rsb r2,r2,#32
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef80] asl.l #7, d0 uses Opef80 ----------
Opef80:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef88] lsl.l #7, d0 uses Opef88 ----------
Opef88:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef90] roxl.l #7, d0 uses Opef90 ----------
Opef90:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  rsb r2,r2,#33 ;@ Reverse direction

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#32
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef98] rol.l #7, d0 uses Opef98 ----------
Opef98:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register:
  rsb r2,r2,#32
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ----------
;@ tried execute privileged instruction in user mode
WrongPrivilegeMode:
  ldr r1,[r7,#0x58]
  sub r4,r4,#2 ;@ last opcode wasn't executed - go back
  orr r1,r1,#4 ;@ set activity bit: 'not processing instruction'
  str r1,[r7,#0x58]
  mov r0,#8 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ -------------------------- Jump Table --------------------------
  .data
  .align 4

CycloneJumpTab:
  .rept 0x1400
  .long 0,0,0,0,0,0,0,0
  .endr
  .long Op____,Op__al,Op__fl,Op0000,Op0010,Op0018,Op001f,Op0020 ;@ 0020
  .long Op0027,Op0028,Op0030,Op0038,Op0039,Op003c,Op0040,Op0050 ;@ 0050
  .long Op0058,Op0060,Op0068,Op0070,Op0078,Op0079,Op007c,Op0080 ;@ 0080
  .long Op0090,Op0098,Op00a0,Op00a8,Op00b0,Op00b8,Op00b9,Op0100 ;@ 0100
  .long Op0108,Op0110,Op0118,Op011f,Op0120,Op0127,Op0128,Op0130 ;@ 0130
  .long Op0138,Op0139,Op013a,Op013b,Op013c,Op0140,Op0148,Op0150 ;@ 0150
  .long Op0158,Op015f,Op0160,Op0167,Op0168,Op0170,Op0178,Op0179 ;@ 0179
  .long Op0180,Op0188,Op0190,Op0198,Op019f,Op01a0,Op01a7,Op01a8 ;@ 01a8
  .long Op01b0,Op01b8,Op01b9,Op01c0,Op01c8,Op01d0,Op01d8,Op01df ;@ 01df
  .long Op01e0,Op01e7,Op01e8,Op01f0,Op01f8,Op01f9,Op0200,Op0210 ;@ 0210
  .long Op0218,Op021f,Op0220,Op0227,Op0228,Op0230,Op0238,Op0239 ;@ 0239
  .long Op023c,Op0240,Op0250,Op0258,Op0260,Op0268,Op0270,Op0278 ;@ 0278
  .long Op0279,Op027c,Op0280,Op0290,Op0298,Op02a0,Op02a8,Op02b0 ;@ 02b0
  .long Op02b8,Op02b9,Op0400,Op0410,Op0418,Op041f,Op0420,Op0427 ;@ 0427
  .long Op0428,Op0430,Op0438,Op0439,Op0440,Op0450,Op0458,Op0460 ;@ 0460
  .long Op0468,Op0470,Op0478,Op0479,Op0480,Op0490,Op0498,Op04a0 ;@ 04a0
  .long Op04a8,Op04b0,Op04b8,Op04b9,Op0600,Op0610,Op0618,Op061f ;@ 061f
  .long Op0620,Op0627,Op0628,Op0630,Op0638,Op0639,Op0640,Op0650 ;@ 0650
  .long Op0658,Op0660,Op0668,Op0670,Op0678,Op0679,Op0680,Op0690 ;@ 0690
  .long Op0698,Op06a0,Op06a8,Op06b0,Op06b8,Op06b9,Op0800,Op0810 ;@ 0810
  .long Op0818,Op081f,Op0820,Op0827,Op0828,Op0830,Op0838,Op0839 ;@ 0839
  .long Op083a,Op083b,Op0840,Op0850,Op0858,Op085f,Op0860,Op0867 ;@ 0867
  .long Op0868,Op0870,Op0878,Op0879,Op0880,Op0890,Op0898,Op089f ;@ 089f
  .long Op08a0,Op08a7,Op08a8,Op08b0,Op08b8,Op08b9,Op08c0,Op08d0 ;@ 08d0
  .long Op08d8,Op08df,Op08e0,Op08e7,Op08e8,Op08f0,Op08f8,Op08f9 ;@ 08f9
  .long Op0a00,Op0a10,Op0a18,Op0a1f,Op0a20,Op0a27,Op0a28,Op0a30 ;@ 0a30
  .long Op0a38,Op0a39,Op0a3c,Op0a40,Op0a50,Op0a58,Op0a60,Op0a68 ;@ 0a68
  .long Op0a70,Op0a78,Op0a79,Op0a7c,Op0a80,Op0a90,Op0a98,Op0aa0 ;@ 0aa0
  .long Op0aa8,Op0ab0,Op0ab8,Op0ab9,Op0c00,Op0c10,Op0c18,Op0c1f ;@ 0c1f
  .long Op0c20,Op0c27,Op0c28,Op0c30,Op0c38,Op0c39,Op0c40,Op0c50 ;@ 0c50
  .long Op0c58,Op0c60,Op0c68,Op0c70,Op0c78,Op0c79,Op0c80,Op0c90 ;@ 0c90
  .long Op0c98,Op0ca0,Op0ca8,Op0cb0,Op0cb8,Op0cb9,Op1000,Op1010 ;@ 1010
  .long Op1018,Op101f,Op1020,Op1027,Op1028,Op1030,Op1038,Op1039 ;@ 1039
  .long Op103a,Op103b,Op103c,Op1080,Op1090,Op1098,Op109f,Op10a0 ;@ 10a0
  .long Op10a7,Op10a8,Op10b0,Op10b8,Op10b9,Op10ba,Op10bb,Op10bc ;@ 10bc
  .long Op10c0,Op10d0,Op10d8,Op10df,Op10e0,Op10e7,Op10e8,Op10f0 ;@ 10f0
  .long Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op1100,Op1110,Op1118 ;@ 1118
  .long Op111f,Op1120,Op1127,Op1128,Op1130,Op1138,Op1139,Op113a ;@ 113a
  .long Op113b,Op113c,Op1140,Op1150,Op1158,Op115f,Op1160,Op1167 ;@ 1167
  .long Op1168,Op1170,Op1178,Op1179,Op117a,Op117b,Op117c,Op1180 ;@ 1180
  .long Op1190,Op1198,Op119f,Op11a0,Op11a7,Op11a8,Op11b0,Op11b8 ;@ 11b8
  .long Op11b9,Op11ba,Op11bb,Op11bc,Op11c0,Op11d0,Op11d8,Op11df ;@ 11df
  .long Op11e0,Op11e7,Op11e8,Op11f0,Op11f8,Op11f9,Op11fa,Op11fb ;@ 11fb
  .long Op11fc,Op13c0,Op13d0,Op13d8,Op13df,Op13e0,Op13e7,Op13e8 ;@ 13e8
  .long Op13f0,Op13f8,Op13f9,Op13fa,Op13fb,Op13fc,Op1ec0,Op1ed0 ;@ 1ed0
  .long Op1ed8,Op1edf,Op1ee0,Op1ee7,Op1ee8,Op1ef0,Op1ef8,Op1ef9 ;@ 1ef9
  .long Op1efa,Op1efb,Op1efc,Op1f00,Op1f10,Op1f18,Op1f1f,Op1f20 ;@ 1f20
  .long Op1f27,Op1f28,Op1f30,Op1f38,Op1f39,Op1f3a,Op1f3b,Op1f3c ;@ 1f3c
  .long Op2000,Op2010,Op2018,Op2020,Op2028,Op2030,Op2038,Op2039 ;@ 2039
  .long Op203a,Op203b,Op203c,Op2040,Op2050,Op2058,Op2060,Op2068 ;@ 2068
  .long Op2070,Op2078,Op2079,Op207a,Op207b,Op207c,Op2080,Op2090 ;@ 2090
  .long Op2098,Op20a0,Op20a8,Op20b0,Op20b8,Op20b9,Op20ba,Op20bb ;@ 20bb
  .long Op20bc,Op20c0,Op20d0,Op20d8,Op20e0,Op20e8,Op20f0,Op20f8 ;@ 20f8
  .long Op20f9,Op20fa,Op20fb,Op20fc,Op2100,Op2110,Op2118,Op2120 ;@ 2120
  .long Op2128,Op2130,Op2138,Op2139,Op213a,Op213b,Op213c,Op2140 ;@ 2140
  .long Op2150,Op2158,Op2160,Op2168,Op2170,Op2178,Op2179,Op217a ;@ 217a
  .long Op217b,Op217c,Op2180,Op2190,Op2198,Op21a0,Op21a8,Op21b0 ;@ 21b0
  .long Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op21c0,Op21d0,Op21d8 ;@ 21d8
  .long Op21e0,Op21e8,Op21f0,Op21f8,Op21f9,Op21fa,Op21fb,Op21fc ;@ 21fc
  .long Op23c0,Op23d0,Op23d8,Op23e0,Op23e8,Op23f0,Op23f8,Op23f9 ;@ 23f9
  .long Op23fa,Op23fb,Op23fc,Op2ec0,Op2ed0,Op2ed8,Op2ee0,Op2ee8 ;@ 2ee8
  .long Op2ef0,Op2ef8,Op2ef9,Op2efa,Op2efb,Op2efc,Op2f00,Op2f10 ;@ 2f10
  .long Op2f18,Op2f20,Op2f28,Op2f30,Op2f38,Op2f39,Op2f3a,Op2f3b ;@ 2f3b
  .long Op2f3c,Op3000,Op3010,Op3018,Op3020,Op3028,Op3030,Op3038 ;@ 3038
  .long Op3039,Op303a,Op303b,Op303c,Op3040,Op3050,Op3058,Op3060 ;@ 3060
  .long Op3068,Op3070,Op3078,Op3079,Op307a,Op307b,Op307c,Op3080 ;@ 3080
  .long Op3090,Op3098,Op30a0,Op30a8,Op30b0,Op30b8,Op30b9,Op30ba ;@ 30ba
  .long Op30bb,Op30bc,Op30c0,Op30d0,Op30d8,Op30e0,Op30e8,Op30f0 ;@ 30f0
  .long Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op3100,Op3110,Op3118 ;@ 3118
  .long Op3120,Op3128,Op3130,Op3138,Op3139,Op313a,Op313b,Op313c ;@ 313c
  .long Op3140,Op3150,Op3158,Op3160,Op3168,Op3170,Op3178,Op3179 ;@ 3179
  .long Op317a,Op317b,Op317c,Op3180,Op3190,Op3198,Op31a0,Op31a8 ;@ 31a8
  .long Op31b0,Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op31c0,Op31d0 ;@ 31d0
  .long Op31d8,Op31e0,Op31e8,Op31f0,Op31f8,Op31f9,Op31fa,Op31fb ;@ 31fb
  .long Op31fc,Op33c0,Op33d0,Op33d8,Op33e0,Op33e8,Op33f0,Op33f8 ;@ 33f8
  .long Op33f9,Op33fa,Op33fb,Op33fc,Op3ec0,Op3ed0,Op3ed8,Op3ee0 ;@ 3ee0
  .long Op3ee8,Op3ef0,Op3ef8,Op3ef9,Op3efa,Op3efb,Op3efc,Op3f00 ;@ 3f00
  .long Op3f10,Op3f18,Op3f20,Op3f28,Op3f30,Op3f38,Op3f39,Op3f3a ;@ 3f3a
  .long Op3f3b,Op3f3c,Op4000,Op4010,Op4018,Op401f,Op4020,Op4027 ;@ 4027
  .long Op4028,Op4030,Op4038,Op4039,Op4040,Op4050,Op4058,Op4060 ;@ 4060
  .long Op4068,Op4070,Op4078,Op4079,Op4080,Op4090,Op4098,Op40a0 ;@ 40a0
  .long Op40a8,Op40b0,Op40b8,Op40b9,Op40c0,Op40d0,Op40d8,Op40e0 ;@ 40e0
  .long Op40e8,Op40f0,Op40f8,Op40f9,Op4180,Op4190,Op4198,Op41a0 ;@ 41a0
  .long Op41a8,Op41b0,Op41b8,Op41b9,Op41ba,Op41bb,Op41bc,Op41d0 ;@ 41d0
  .long Op41e8,Op41f0,Op41f8,Op41f9,Op41fa,Op41fb,Op4200,Op4210 ;@ 4210
  .long Op4218,Op421f,Op4220,Op4227,Op4228,Op4230,Op4238,Op4239 ;@ 4239
  .long Op4240,Op4250,Op4258,Op4260,Op4268,Op4270,Op4278,Op4279 ;@ 4279
  .long Op4280,Op4290,Op4298,Op42a0,Op42a8,Op42b0,Op42b8,Op42b9 ;@ 42b9
  .long Op4400,Op4410,Op4418,Op441f,Op4420,Op4427,Op4428,Op4430 ;@ 4430
  .long Op4438,Op4439,Op4440,Op4450,Op4458,Op4460,Op4468,Op4470 ;@ 4470
  .long Op4478,Op4479,Op4480,Op4490,Op4498,Op44a0,Op44a8,Op44b0 ;@ 44b0
  .long Op44b8,Op44b9,Op44c0,Op44d0,Op44d8,Op44e0,Op44e8,Op44f0 ;@ 44f0
  .long Op44f8,Op44f9,Op44fa,Op44fb,Op44fc,Op4600,Op4610,Op4618 ;@ 4618
  .long Op461f,Op4620,Op4627,Op4628,Op4630,Op4638,Op4639,Op4640 ;@ 4640
  .long Op4650,Op4658,Op4660,Op4668,Op4670,Op4678,Op4679,Op4680 ;@ 4680
  .long Op4690,Op4698,Op46a0,Op46a8,Op46b0,Op46b8,Op46b9,Op46c0 ;@ 46c0
  .long Op46d0,Op46d8,Op46e0,Op46e8,Op46f0,Op46f8,Op46f9,Op46fa ;@ 46fa
  .long Op46fb,Op46fc,Op4800,Op4810,Op4818,Op481f,Op4820,Op4827 ;@ 4827
  .long Op4828,Op4830,Op4838,Op4839,Op4840,Op4850,Op4868,Op4870 ;@ 4870
  .long Op4878,Op4879,Op487a,Op487b,Op4880,Op4890,Op48a0,Op48a8 ;@ 48a8
  .long Op48b0,Op48b8,Op48b9,Op48c0,Op48d0,Op48e0,Op48e8,Op48f0 ;@ 48f0
  .long Op48f8,Op48f9,Op4a00,Op4a10,Op4a18,Op4a1f,Op4a20,Op4a27 ;@ 4a27
  .long Op4a28,Op4a30,Op4a38,Op4a39,Op4a40,Op4a50,Op4a58,Op4a60 ;@ 4a60
  .long Op4a68,Op4a70,Op4a78,Op4a79,Op4a80,Op4a90,Op4a98,Op4aa0 ;@ 4aa0
  .long Op4aa8,Op4ab0,Op4ab8,Op4ab9,Op4ac0,Op4ad0,Op4ad8,Op4adf ;@ 4adf
  .long Op4ae0,Op4ae7,Op4ae8,Op4af0,Op4af8,Op4af9,Op4c90,Op4c98 ;@ 4c98
  .long Op4ca8,Op4cb0,Op4cb8,Op4cb9,Op4cba,Op4cbb,Op4cd0,Op4cd8 ;@ 4cd8
  .long Op4ce8,Op4cf0,Op4cf8,Op4cf9,Op4cfa,Op4cfb,Op4e40,Op4e50 ;@ 4e50
  .long Op4e57,Op4e58,Op4e60,Op4e68,Op4e70,Op4e71,Op4e72,Op4e73 ;@ 4e73
  .long Op4e75,Op4e76,Op4e77,Op4e90,Op4ea8,Op4eb0,Op4eb8,Op4eb9 ;@ 4eb9
  .long Op4eba,Op4ebb,Op4ed0,Op4ee8,Op4ef0,Op4ef8,Op4ef9,Op4efa ;@ 4efa
  .long Op4efb,Op5000,Op5010,Op5018,Op501f,Op5020,Op5027,Op5028 ;@ 5028
  .long Op5030,Op5038,Op5039,Op5040,Op5048,Op5050,Op5058,Op5060 ;@ 5060
  .long Op5068,Op5070,Op5078,Op5079,Op5080,Op5088,Op5090,Op5098 ;@ 5098
  .long Op50a0,Op50a8,Op50b0,Op50b8,Op50b9,Op50c0,Op50c8,Op50d0 ;@ 50d0
  .long Op50d8,Op50df,Op50e0,Op50e7,Op50e8,Op50f0,Op50f8,Op50f9 ;@ 50f9
  .long Op5100,Op5110,Op5118,Op511f,Op5120,Op5127,Op5128,Op5130 ;@ 5130
  .long Op5138,Op5139,Op5140,Op5148,Op5150,Op5158,Op5160,Op5168 ;@ 5168
  .long Op5170,Op5178,Op5179,Op5180,Op5188,Op5190,Op5198,Op51a0 ;@ 51a0
  .long Op51a8,Op51b0,Op51b8,Op51b9,Op51c0,Op51c8,Op51d0,Op51d8 ;@ 51d8
  .long Op51df,Op51e0,Op51e7,Op51e8,Op51f0,Op51f8,Op51f9,Op5e00 ;@ 5200
  .long Op5e10,Op5e18,Op5e1f,Op5e20,Op5e27,Op5e28,Op5e30,Op5e38 ;@ 5238
  .long Op5e39,Op5e40,Op5e48,Op5e50,Op5e58,Op5e60,Op5e68,Op5e70 ;@ 5270
  .long Op5e78,Op5e79,Op5e80,Op5e88,Op5e90,Op5e98,Op5ea0,Op5ea8 ;@ 52a8
  .long Op5eb0,Op5eb8,Op5eb9,Op52c0,Op52c8,Op52d0,Op52d8,Op52df ;@ 52df
  .long Op52e0,Op52e7,Op52e8,Op52f0,Op52f8,Op52f9,Op5f00,Op5f10 ;@ 5310
  .long Op5f18,Op5f1f,Op5f20,Op5f27,Op5f28,Op5f30,Op5f38,Op5f39 ;@ 5339
  .long Op5f40,Op5f48,Op5f50,Op5f58,Op5f60,Op5f68,Op5f70,Op5f78 ;@ 5378
  .long Op5f79,Op5f80,Op5f88,Op5f90,Op5f98,Op5fa0,Op5fa8,Op5fb0 ;@ 53b0
  .long Op5fb8,Op5fb9,Op53c0,Op53c8,Op53d0,Op53d8,Op53df,Op53e0 ;@ 53e0
  .long Op53e7,Op53e8,Op53f0,Op53f8,Op53f9,Op54c0,Op54c8,Op54d0 ;@ 54d0
  .long Op54d8,Op54df,Op54e0,Op54e7,Op54e8,Op54f0,Op54f8,Op54f9 ;@ 54f9
  .long Op55c0,Op55c8,Op55d0,Op55d8,Op55df,Op55e0,Op55e7,Op55e8 ;@ 55e8
  .long Op55f0,Op55f8,Op55f9,Op56c0,Op56c8,Op56d0,Op56d8,Op56df ;@ 56df
  .long Op56e0,Op56e7,Op56e8,Op56f0,Op56f8,Op56f9,Op57c0,Op57c8 ;@ 57c8
  .long Op57d0,Op57d8,Op57df,Op57e0,Op57e7,Op57e8,Op57f0,Op57f8 ;@ 57f8
  .long Op57f9,Op58c0,Op58c8,Op58d0,Op58d8,Op58df,Op58e0,Op58e7 ;@ 58e7
  .long Op58e8,Op58f0,Op58f8,Op58f9,Op59c0,Op59c8,Op59d0,Op59d8 ;@ 59d8
  .long Op59df,Op59e0,Op59e7,Op59e8,Op59f0,Op59f8,Op59f9,Op5ac0 ;@ 5ac0
  .long Op5ac8,Op5ad0,Op5ad8,Op5adf,Op5ae0,Op5ae7,Op5ae8,Op5af0 ;@ 5af0
  .long Op5af8,Op5af9,Op5bc0,Op5bc8,Op5bd0,Op5bd8,Op5bdf,Op5be0 ;@ 5be0
  .long Op5be7,Op5be8,Op5bf0,Op5bf8,Op5bf9,Op5cc0,Op5cc8,Op5cd0 ;@ 5cd0
  .long Op5cd8,Op5cdf,Op5ce0,Op5ce7,Op5ce8,Op5cf0,Op5cf8,Op5cf9 ;@ 5cf9
  .long Op5dc0,Op5dc8,Op5dd0,Op5dd8,Op5ddf,Op5de0,Op5de7,Op5de8 ;@ 5de8
  .long Op5df0,Op5df8,Op5df9,Op5ec0,Op5ec8,Op5ed0,Op5ed8,Op5edf ;@ 5edf
  .long Op5ee0,Op5ee7,Op5ee8,Op5ef0,Op5ef8,Op5ef9,Op5fc0,Op5fc8 ;@ 5fc8
  .long Op5fd0,Op5fd8,Op5fdf,Op5fe0,Op5fe7,Op5fe8,Op5ff0,Op5ff8 ;@ 5ff8
  .long Op5ff9,Op6000,Op6003,Op6002,Op6100,Op6103,Op6102,Op6200 ;@ 6200
  .long Op6203,Op6202,Op6300,Op6303,Op6302,Op6400,Op6403,Op6402 ;@ 6402
  .long Op6500,Op6503,Op6502,Op6600,Op6603,Op6602,Op6700,Op6703 ;@ 6701
  .long Op6702,Op6800,Op6803,Op6802,Op6900,Op6903,Op6902,Op6a00 ;@ 6a00
  .long Op6a03,Op6a02,Op6b00,Op6b03,Op6b02,Op6c00,Op6c03,Op6c02 ;@ 6c02
  .long Op6d00,Op6d03,Op6d02,Op6e00,Op6e03,Op6e02,Op6f00,Op6f03 ;@ 6f01
  .long Op6f02,Op7000,Op8000,Op8010,Op8018,Op801f,Op8020,Op8027 ;@ 8027
  .long Op8028,Op8030,Op8038,Op8039,Op803a,Op803b,Op803c,Op8040 ;@ 8040
  .long Op8050,Op8058,Op8060,Op8068,Op8070,Op8078,Op8079,Op807a ;@ 807a
  .long Op807b,Op807c,Op8080,Op8090,Op8098,Op80a0,Op80a8,Op80b0 ;@ 80b0
  .long Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op80c0,Op80d0,Op80d8 ;@ 80d8
  .long Op80e0,Op80e8,Op80f0,Op80f8,Op80f9,Op80fa,Op80fb,Op80fc ;@ 80fc
  .long Op8100,Op8108,Op810f,Op8110,Op8118,Op811f,Op8120,Op8127 ;@ 8127
  .long Op8128,Op8130,Op8138,Op8139,Op8150,Op8158,Op8160,Op8168 ;@ 8168
  .long Op8170,Op8178,Op8179,Op8190,Op8198,Op81a0,Op81a8,Op81b0 ;@ 81b0
  .long Op81b8,Op81b9,Op81c0,Op81d0,Op81d8,Op81e0,Op81e8,Op81f0 ;@ 81f0
  .long Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op8f08,Op8f0f,Op9000 ;@ 9000
  .long Op9010,Op9018,Op901f,Op9020,Op9027,Op9028,Op9030,Op9038 ;@ 9038
  .long Op9039,Op903a,Op903b,Op903c,Op9040,Op9050,Op9058,Op9060 ;@ 9060
  .long Op9068,Op9070,Op9078,Op9079,Op907a,Op907b,Op907c,Op9080 ;@ 9080
  .long Op9090,Op9098,Op90a0,Op90a8,Op90b0,Op90b8,Op90b9,Op90ba ;@ 90ba
  .long Op90bb,Op90bc,Op90c0,Op90d0,Op90d8,Op90e0,Op90e8,Op90f0 ;@ 90f0
  .long Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op9100,Op9108,Op910f ;@ 910f
  .long Op9110,Op9118,Op911f,Op9120,Op9127,Op9128,Op9130,Op9138 ;@ 9138
  .long Op9139,Op9140,Op9148,Op9150,Op9158,Op9160,Op9168,Op9170 ;@ 9170
  .long Op9178,Op9179,Op9180,Op9188,Op9190,Op9198,Op91a0,Op91a8 ;@ 91a8
  .long Op91b0,Op91b8,Op91b9,Op91c0,Op91d0,Op91d8,Op91e0,Op91e8 ;@ 91e8
  .long Op91f0,Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op9f08,Op9f0f ;@ 9f0f
  .long Opb000,Opb010,Opb018,Opb01f,Opb020,Opb027,Opb028,Opb030 ;@ b030
  .long Opb038,Opb039,Opb03a,Opb03b,Opb03c,Opb040,Opb050,Opb058 ;@ b058
  .long Opb060,Opb068,Opb070,Opb078,Opb079,Opb07a,Opb07b,Opb07c ;@ b07c
  .long Opb080,Opb090,Opb098,Opb0a0,Opb0a8,Opb0b0,Opb0b8,Opb0b9 ;@ b0b9
  .long Opb0ba,Opb0bb,Opb0bc,Opb0c0,Opb0d0,Opb0d8,Opb0e0,Opb0e8 ;@ b0e8
  .long Opb0f0,Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Opb100,Opb108 ;@ b108
  .long Opb10f,Opb110,Opb118,Opb11f,Opb120,Opb127,Opb128,Opb130 ;@ b130
  .long Opb138,Opb139,Opb140,Opb148,Opb150,Opb158,Opb160,Opb168 ;@ b168
  .long Opb170,Opb178,Opb179,Opb180,Opb188,Opb190,Opb198,Opb1a0 ;@ b1a0
  .long Opb1a8,Opb1b0,Opb1b8,Opb1b9,Opb1c0,Opb1d0,Opb1d8,Opb1e0 ;@ b1e0
  .long Opb1e8,Opb1f0,Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Opbf08 ;@ bf08
  .long Opbf0f,Opc000,Opc010,Opc018,Opc01f,Opc020,Opc027,Opc028 ;@ c028
  .long Opc030,Opc038,Opc039,Opc03a,Opc03b,Opc03c,Opc040,Opc050 ;@ c050
  .long Opc058,Opc060,Opc068,Opc070,Opc078,Opc079,Opc07a,Opc07b ;@ c07b
  .long Opc07c,Opc080,Opc090,Opc098,Opc0a0,Opc0a8,Opc0b0,Opc0b8 ;@ c0b8
  .long Opc0b9,Opc0ba,Opc0bb,Opc0bc,Opc0c0,Opc0d0,Opc0d8,Opc0e0 ;@ c0e0
  .long Opc0e8,Opc0f0,Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Opc100 ;@ c100
  .long Opc108,Opc10f,Opc110,Opc118,Opc11f,Opc120,Opc127,Opc128 ;@ c128
  .long Opc130,Opc138,Opc139,Opc140,Opc148,Opc150,Opc158,Opc160 ;@ c160
  .long Opc168,Opc170,Opc178,Opc179,Opc188,Opc190,Opc198,Opc1a0 ;@ c1a0
  .long Opc1a8,Opc1b0,Opc1b8,Opc1b9,Opc1c0,Opc1d0,Opc1d8,Opc1e0 ;@ c1e0
  .long Opc1e8,Opc1f0,Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Opcf08 ;@ cf08
  .long Opcf0f,Opd000,Opd010,Opd018,Opd01f,Opd020,Opd027,Opd028 ;@ d028
  .long Opd030,Opd038,Opd039,Opd03a,Opd03b,Opd03c,Opd040,Opd050 ;@ d050
  .long Opd058,Opd060,Opd068,Opd070,Opd078,Opd079,Opd07a,Opd07b ;@ d07b
  .long Opd07c,Opd080,Opd090,Opd098,Opd0a0,Opd0a8,Opd0b0,Opd0b8 ;@ d0b8
  .long Opd0b9,Opd0ba,Opd0bb,Opd0bc,Opd0c0,Opd0d0,Opd0d8,Opd0e0 ;@ d0e0
  .long Opd0e8,Opd0f0,Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Opd100 ;@ d100
  .long Opd108,Opd10f,Opd110,Opd118,Opd11f,Opd120,Opd127,Opd128 ;@ d128
  .long Opd130,Opd138,Opd139,Opd140,Opd148,Opd150,Opd158,Opd160 ;@ d160
  .long Opd168,Opd170,Opd178,Opd179,Opd180,Opd188,Opd190,Opd198 ;@ d198
  .long Opd1a0,Opd1a8,Opd1b0,Opd1b8,Opd1b9,Opd1c0,Opd1d0,Opd1d8 ;@ d1d8
  .long Opd1e0,Opd1e8,Opd1f0,Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc ;@ d1fc
  .long Opdf08,Opdf0f,Ope000,Ope008,Ope010,Ope018,Ope020,Ope028 ;@ e028
  .long Ope030,Ope038,Ope040,Ope048,Ope050,Ope058,Ope060,Ope068 ;@ e068
  .long Ope070,Ope078,Ope080,Ope088,Ope090,Ope098,Ope0a0,Ope0a8 ;@ e0a8
  .long Ope0b0,Ope0b8,Ope0d0,Ope0d8,Ope0e0,Ope0e8,Ope0f0,Ope0f8 ;@ e0f8
  .long Ope0f9,Ope100,Ope108,Ope110,Ope118,Ope120,Ope128,Ope130 ;@ e130
  .long Ope138,Ope140,Ope148,Ope150,Ope158,Ope160,Ope168,Ope170 ;@ e170
  .long Ope178,Ope180,Ope188,Ope190,Ope198,Ope1a0,Ope1a8,Ope1b0 ;@ e1b0
  .long Ope1b8,Ope1d0,Ope1d8,Ope1e0,Ope1e8,Ope1f0,Ope1f8,Ope1f9 ;@ e1f9
  .long Opee00,Opee08,Ope210,Opee18,Opee40,Opee48,Ope250,Opee58 ;@ e258
  .long Opee80,Opee88,Ope290,Opee98,Ope2d0,Ope2d8,Ope2e0,Ope2e8 ;@ e2e8
  .long Ope2f0,Ope2f8,Ope2f9,Opef00,Opef08,Ope310,Opef18,Opef40 ;@ e340
  .long Opef48,Ope350,Opef58,Opef80,Opef88,Ope390,Opef98,Ope3d0 ;@ e3d0
  .long Ope3d8,Ope3e0,Ope3e8,Ope3f0,Ope3f8,Ope3f9,Opee10,Opee50 ;@ e450
  .long Opee90,Ope4d0,Ope4d8,Ope4e0,Ope4e8,Ope4f0,Ope4f8,Ope4f9 ;@ e4f9
  .long Opef10,Opef50,Opef90,Ope5d0,Ope5d8,Ope5e0,Ope5e8,Ope5f0 ;@ e5f0
  .long Ope5f8,Ope5f9,Ope6d0,Ope6d8,Ope6e0,Ope6e8,Ope6f0,Ope6f8 ;@ e6f8
  .long Ope6f9,Ope7d0,Ope7d8,Ope7e0,Ope7e8,Ope7f0,Ope7f8,Ope7f9 ;@ e7f9
  .rept 0x71f
  .long 0,0,0,0,0,0,0,0
  .endr
  .hword 0x0038,0x0008,0x0048,0x0057,0x0061,0x0077,0x0081,0x0098
  .hword 0x00a8,0x00b1,0x00c1,0x0002,0x00d1,0x0003,0x00e8,0x0008
  .hword 0x00f8,0x0108,0x0118,0x0128,0x0138,0x0141,0x0151,0x0002
  .hword 0x0161,0x0003,0x0178,0x0008,0x0188,0x0198,0x01a8,0x01b8
  .hword 0x01c8,0x01d1,0x01e1,0x0000,0x0046,0x01f8,0x0208,0x0218
  .hword 0x0227,0x0231,0x0247,0x0251,0x0268,0x0278,0x0281,0x0291
  .hword 0x02a1,0x02b1,0x02c1,0x0003,0x02d8,0x02e8,0x02f8,0x0307
  .hword 0x0311,0x0327,0x0331,0x0348,0x0358,0x0361,0x0371,0x0006
  .hword 0x0388,0x0398,0x03a8,0x03b7,0x03c1,0x03d7,0x03e1,0x03f8
  .hword 0x0408,0x0411,0x0421,0x0006,0x0438,0x0448,0x0458,0x0467
  .hword 0x0471,0x0487,0x0491,0x04a8,0x04b8,0x04c1,0x04d1,0x0006
  .hword 0x04e8,0x0008,0x04f8,0x0507,0x0511,0x0527,0x0531,0x0548
  .hword 0x0558,0x0561,0x0571,0x0002,0x0581,0x0003,0x0598,0x0008
  .hword 0x05a8,0x05b8,0x05c8,0x05d8,0x05e8,0x05f1,0x0601,0x0002
  .hword 0x0611,0x0003,0x0628,0x0008,0x0638,0x0648,0x0658,0x0668
  .hword 0x0678,0x0681,0x0691,0x0000,0x0046,0x01f8,0x0208,0x0218
  .hword 0x0227,0x0231,0x0247,0x0251,0x0268,0x0278,0x0281,0x0291
  .hword 0x02a1,0x02b1,0x02c1,0x0003,0x02d8,0x02e8,0x02f8,0x0307
  .hword 0x0311,0x0327,0x0331,0x0348,0x0358,0x0361,0x0371,0x0006
  .hword 0x0388,0x0398,0x03a8,0x03b7,0x03c1,0x03d7,0x03e1,0x03f8
  .hword 0x0408,0x0411,0x0421,0x0006,0x0438,0x0448,0x0458,0x0467
  .hword 0x0471,0x0487,0x0491,0x04a8,0x04b8,0x04c1,0x04d1,0x0006
  .hword 0x06a8,0x0008,0x06b8,0x06c7,0x06d1,0x06e7,0x06f1,0x0708
  .hword 0x0718,0x0721,0x0731,0x0006,0x0748,0x0008,0x0758,0x0768
  .hword 0x0778,0x0788,0x0798,0x07a1,0x07b1,0x0006,0x07c8,0x0008
  .hword 0x07d8,0x07e8,0x07f8,0x0808,0x0818,0x0821,0x0831,0x0000
  .hword 0x0046,0x01f8,0x0208,0x0218,0x0227,0x0231,0x0247,0x0251
  .hword 0x0268,0x0278,0x0281,0x0291,0x02a1,0x02b1,0x02c1,0x0003
  .hword 0x02d8,0x02e8,0x02f8,0x0307,0x0311,0x0327,0x0331,0x0348
  .hword 0x0358,0x0361,0x0371,0x0006,0x0388,0x0398,0x03a8,0x03b7
  .hword 0x03c1,0x03d7,0x03e1,0x03f8,0x0408,0x0411,0x0421,0x0006
  .hword 0x0438,0x0448,0x0458,0x0467,0x0471,0x0487,0x0491,0x04a8
  .hword 0x04b8,0x04c1,0x04d1,0x0006,0x0848,0x0008,0x0858,0x0867
  .hword 0x0871,0x0887,0x0891,0x08a8,0x08b8,0x08c1,0x08d1,0x0006
  .hword 0x08e8,0x0008,0x08f8,0x0908,0x0918,0x0928,0x0938,0x0941
  .hword 0x0951,0x0006,0x0968,0x0008,0x0978,0x0988,0x0998,0x09a8
  .hword 0x09b8,0x09c1,0x09d1,0x0000,0x0046,0x01f8,0x0208,0x0218
  .hword 0x0227,0x0231,0x0247,0x0251,0x0268,0x0278,0x0281,0x0291
  .hword 0x02a1,0x02b1,0x02c1,0x0003,0x02d8,0x02e8,0x02f8,0x0307
  .hword 0x0311,0x0327,0x0331,0x0348,0x0358,0x0361,0x0371,0x0006
  .hword 0x0388,0x0398,0x03a8,0x03b7,0x03c1,0x03d7,0x03e1,0x03f8
  .hword 0x0408,0x0411,0x0421,0x0006,0x0438,0x0448,0x0458,0x0467
  .hword 0x0471,0x0487,0x0491,0x04a8,0x04b8,0x04c1,0x04d1,0x0006
  .hword 0x09e8,0x0008,0x09f8,0x0a07,0x0a11,0x0a27,0x0a31,0x0a48
  .hword 0x0a58,0x0a61,0x0a71,0x0a81,0x0a91,0x0004,0x0aa8,0x0008
  .hword 0x0ab8,0x0ac7,0x0ad1,0x0ae7,0x0af1,0x0b08,0x0b18,0x0b21
  .hword 0x0b31,0x0006,0x0b48,0x0008,0x0b58,0x0b67,0x0b71,0x0b87
  .hword 0x0b91,0x0ba8,0x0bb8,0x0bc1,0x0bd1,0x0006,0x0be8,0x0008
  .hword 0x0bf8,0x0c07,0x0c11,0x0c27,0x0c31,0x0c48,0x0c58,0x0c61
  .hword 0x0c71,0x0006,0x01f8,0x0208,0x0218,0x0227,0x0231,0x0247
  .hword 0x0251,0x0268,0x0278,0x0281,0x0291,0x02a1,0x02b1,0x02c1
  .hword 0x0003,0x02d8,0x02e8,0x02f8,0x0307,0x0311,0x0327,0x0331
  .hword 0x0348,0x0358,0x0361,0x0371,0x0006,0x0388,0x0398,0x03a8
  .hword 0x03b7,0x03c1,0x03d7,0x03e1,0x03f8,0x0408,0x0411,0x0421
  .hword 0x0006,0x0438,0x0448,0x0458,0x0467,0x0471,0x0487,0x0491
  .hword 0x04a8,0x04b8,0x04c1,0x04d1,0x0006,0x0c88,0x0008,0x0c98
  .hword 0x0ca7,0x0cb1,0x0cc7,0x0cd1,0x0ce8,0x0cf8,0x0d01,0x0d11
  .hword 0x0002,0x0d21,0x0003,0x0d38,0x0008,0x0d48,0x0d58,0x0d68
  .hword 0x0d78,0x0d88,0x0d91,0x0da1,0x0002,0x0db1,0x0003,0x0dc8
  .hword 0x0008,0x0dd8,0x0de8,0x0df8,0x0e08,0x0e18,0x0e21,0x0e31
  .hword 0x0000,0x0046,0x01f8,0x0208,0x0218,0x0227,0x0231,0x0247
  .hword 0x0251,0x0268,0x0278,0x0281,0x0291,0x02a1,0x02b1,0x02c1
  .hword 0x0003,0x02d8,0x02e8,0x02f8,0x0307,0x0311,0x0327,0x0331
  .hword 0x0348,0x0358,0x0361,0x0371,0x0006,0x0388,0x0398,0x03a8
  .hword 0x03b7,0x03c1,0x03d7,0x03e1,0x03f8,0x0408,0x0411,0x0421
  .hword 0x0006,0x0438,0x0448,0x0458,0x0467,0x0471,0x0487,0x0491
  .hword 0x04a8,0x04b8,0x04c1,0x04d1,0x0006,0x0e48,0x0008,0x0e58
  .hword 0x0e67,0x0e71,0x0e87,0x0e91,0x0ea8,0x0eb8,0x0ec1,0x0ed1
  .hword 0x0006,0x0ee8,0x0008,0x0ef8,0x0f08,0x0f18,0x0f28,0x0f38
  .hword 0x0f41,0x0f51,0x0006,0x0f68,0x0008,0x0f78,0x0f88,0x0f98
  .hword 0x0fa8,0x0fb8,0x0fc1,0x0fd1,0x0000,0x0046,0x01f8,0x0208
  .hword 0x0218,0x0227,0x0231,0x0247,0x0251,0x0268,0x0278,0x0281
  .hword 0x0291,0x02a1,0x02b1,0x02c1,0x0003,0x02d8,0x02e8,0x02f8
  .hword 0x0307,0x0311,0x0327,0x0331,0x0348,0x0358,0x0361,0x0371
  .hword 0x0006,0x0388,0x0398,0x03a8,0x03b7,0x03c1,0x03d7,0x03e1
  .hword 0x03f8,0x0408,0x0411,0x0421,0x0006,0x0438,0x0448,0x0458
  .hword 0x0467,0x0471,0x0487,0x0491,0x04a8,0x04b8,0x04c1,0x04d1
  .hword 0x0000,0x0106,0x01f8,0x0208,0x0218,0x0227,0x0231,0x0247
  .hword 0x0251,0x0268,0x0278,0x0281,0x0291,0x02a1,0x02b1,0x02c1
  .hword 0x0003,0x02d8,0x02e8,0x02f8,0x0307,0x0311,0x0327,0x0331
  .hword 0x0348,0x0358,0x0361,0x0371,0x0006,0x0388,0x0398,0x03a8
  .hword 0x03b7,0x03c1,0x03d7,0x03e1,0x03f8,0x0408,0x0411,0x0421
  .hword 0x0006,0x0438,0x0448,0x0458,0x0467,0x0471,0x0487,0x0491
  .hword 0x04a8,0x04b8,0x04c1,0x04d1,0x0006,0x0fe8,0x0008,0x0ff8
  .hword 0x1007,0x1011,0x1027,0x1031,0x1048,0x1058,0x1061,0x1071
  .hword 0x1081,0x1091,0x10a1,0x0000,0x0043,0x10b8,0x0008,0x10c8
  .hword 0x10d7,0x10e1,0x10f7,0x1101,0x1118,0x1128,0x1131,0x1141
  .hword 0x1151,0x1161,0x1171,0x0003,0x1188,0x0008,0x1198,0x11a7
  .hword 0x11b1,0x11c7,0x11d1,0x11e8,0x11f8,0x1201,0x1211,0x1221
  .hword 0x1231,0x1241,0x0003,0x1258,0x0008,0x1268,0x1277,0x1281
  .hword 0x1297,0x12a1,0x12b8,0x12c8,0x12d1,0x12e1,0x12f1,0x1301
  .hword 0x1311,0x0003,0x1328,0x0008,0x1338,0x1347,0x1351,0x1367
  .hword 0x1371,0x1388,0x1398,0x13a1,0x13b1,0x13c1,0x13d1,0x13e1
  .hword 0x0003,0x13f8,0x0008,0x1408,0x1417,0x1421,0x1437,0x1441
  .hword 0x1458,0x1468,0x1471,0x1481,0x1491,0x14a1,0x14b1,0x0003
  .hword 0x14c8,0x0008,0x14d8,0x14e7,0x14f1,0x1507,0x1511,0x1528
  .hword 0x1538,0x1541,0x1551,0x1561,0x1571,0x1581,0x0003,0x0fe8
  .hword 0x0008,0x0ff8,0x1007,0x1011,0x1027,0x1031,0x1048,0x1058
  .hword 0x1061,0x1071,0x1081,0x1091,0x10a1,0x0000,0x0043,0x10b8
  .hword 0x0008,0x10c8,0x10d7,0x10e1,0x10f7,0x1101,0x1118,0x1128
  .hword 0x1131,0x1141,0x1151,0x1161,0x1171,0x0003,0x1188,0x0008
  .hword 0x1198,0x11a7,0x11b1,0x11c7,0x11d1,0x11e8,0x11f8,0x1201
  .hword 0x1211,0x1221,0x1231,0x1241,0x0003,0x1258,0x0008,0x1268
  .hword 0x1277,0x1281,0x1297,0x12a1,0x12b8,0x12c8,0x12d1,0x12e1
  .hword 0x12f1,0x1301,0x1311,0x0003,0x1328,0x0008,0x1338,0x1347
  .hword 0x1351,0x1367,0x1371,0x1388,0x1398,0x13a1,0x13b1,0x13c1
  .hword 0x13d1,0x13e1,0x0003,0x13f8,0x0008,0x1408,0x1417,0x1421
  .hword 0x1437,0x1441,0x1458,0x1468,0x1471,0x1481,0x1491,0x14a1
  .hword 0x14b1,0x0003,0x1598,0x0008,0x15a8,0x15b7,0x15c1,0x15d7
  .hword 0x15e1,0x15f8,0x1608,0x1611,0x1621,0x1631,0x1641,0x1651
  .hword 0x0003,0x0fe8,0x0008,0x0ff8,0x1007,0x1011,0x1027,0x1031
  .hword 0x1048,0x1058,0x1061,0x1071,0x1081,0x1091,0x10a1,0x0000
  .hword 0x0043,0x10b8,0x0008,0x10c8,0x10d7,0x10e1,0x10f7,0x1101
  .hword 0x1118,0x1128,0x1131,0x1141,0x1151,0x1161,0x1171,0x0003
  .hword 0x1188,0x0008,0x1198,0x11a7,0x11b1,0x11c7,0x11d1,0x11e8
  .hword 0x11f8,0x1201,0x1211,0x1221,0x1231,0x1241,0x0003,0x1258
  .hword 0x0008,0x1268,0x1277,0x1281,0x1297,0x12a1,0x12b8,0x12c8
  .hword 0x12d1,0x12e1,0x12f1,0x1301,0x1311,0x0003,0x1328,0x0008
  .hword 0x1338,0x1347,0x1351,0x1367,0x1371,0x1388,0x1398,0x13a1
  .hword 0x13b1,0x13c1,0x13d1,0x13e1,0x0003,0x13f8,0x0008,0x1408
  .hword 0x1417,0x1421,0x1437,0x1441,0x1458,0x1468,0x1471,0x1481
  .hword 0x1491,0x14a1,0x14b1,0x0000,0x0043,0x0fe8,0x0008,0x0ff8
  .hword 0x1007,0x1011,0x1027,0x1031,0x1048,0x1058,0x1061,0x1071
  .hword 0x1081,0x1091,0x10a1,0x0000,0x0043,0x10b8,0x0008,0x10c8
  .hword 0x10d7,0x10e1,0x10f7,0x1101,0x1118,0x1128,0x1131,0x1141
  .hword 0x1151,0x1161,0x1171,0x0003,0x1188,0x0008,0x1198,0x11a7
  .hword 0x11b1,0x11c7,0x11d1,0x11e8,0x11f8,0x1201,0x1211,0x1221
  .hword 0x1231,0x1241,0x0003,0x1258,0x0008,0x1268,0x1277,0x1281
  .hword 0x1297,0x12a1,0x12b8,0x12c8,0x12d1,0x12e1,0x12f1,0x1301
  .hword 0x1311,0x0003,0x1328,0x0008,0x1338,0x1347,0x1351,0x1367
  .hword 0x1371,0x1388,0x1398,0x13a1,0x13b1,0x13c1,0x13d1,0x13e1
  .hword 0x0003,0x13f8,0x0008,0x1408,0x1417,0x1421,0x1437,0x1441
  .hword 0x1458,0x1468,0x1471,0x1481,0x1491,0x14a1,0x14b1,0x0000
  .hword 0x0043,0x0fe8,0x0008,0x0ff8,0x1007,0x1011,0x1027,0x1031
  .hword 0x1048,0x1058,0x1061,0x1071,0x1081,0x1091,0x10a1,0x0000
  .hword 0x0043,0x10b8,0x0008,0x10c8,0x10d7,0x10e1,0x10f7,0x1101
  .hword 0x1118,0x1128,0x1131,0x1141,0x1151,0x1161,0x1171,0x0003
  .hword 0x1188,0x0008,0x1198,0x11a7,0x11b1,0x11c7,0x11d1,0x11e8
  .hword 0x11f8,0x1201,0x1211,0x1221,0x1231,0x1241,0x0003,0x1258
  .hword 0x0008,0x1268,0x1277,0x1281,0x1297,0x12a1,0x12b8,0x12c8
  .hword 0x12d1,0x12e1,0x12f1,0x1301,0x1311,0x0003,0x1328,0x0008
  .hword 0x1338,0x1347,0x1351,0x1367,0x1371,0x1388,0x1398,0x13a1
  .hword 0x13b1,0x13c1,0x13d1,0x13e1,0x0003,0x13f8,0x0008,0x1408
  .hword 0x1417,0x1421,0x1437,0x1441,0x1458,0x1468,0x1471,0x1481
  .hword 0x1491,0x14a1,0x14b1,0x0000,0x0043,0x0fe8,0x0008,0x0ff8
  .hword 0x1007,0x1011,0x1027,0x1031,0x1048,0x1058,0x1061,0x1071
  .hword 0x1081,0x1091,0x10a1,0x0000,0x0043,0x10b8,0x0008,0x10c8
  .hword 0x10d7,0x10e1,0x10f7,0x1101,0x1118,0x1128,0x1131,0x1141
  .hword 0x1151,0x1161,0x1171,0x0003,0x1188,0x0008,0x1198,0x11a7
  .hword 0x11b1,0x11c7,0x11d1,0x11e8,0x11f8,0x1201,0x1211,0x1221
  .hword 0x1231,0x1241,0x0003,0x1258,0x0008,0x1268,0x1277,0x1281
  .hword 0x1297,0x12a1,0x12b8,0x12c8,0x12d1,0x12e1,0x12f1,0x1301
  .hword 0x1311,0x0003,0x1328,0x0008,0x1338,0x1347,0x1351,0x1367
  .hword 0x1371,0x1388,0x1398,0x13a1,0x13b1,0x13c1,0x13d1,0x13e1
  .hword 0x0003,0x13f8,0x0008,0x1408,0x1417,0x1421,0x1437,0x1441
  .hword 0x1458,0x1468,0x1471,0x1481,0x1491,0x14a1,0x14b1,0x0000
  .hword 0x0043,0x0fe8,0x0008,0x0ff8,0x1007,0x1011,0x1027,0x1031
  .hword 0x1048,0x1058,0x1061,0x1071,0x1081,0x1091,0x10a1,0x0000
  .hword 0x0043,0x10b8,0x0008,0x10c8,0x10d7,0x10e1,0x10f7,0x1101
  .hword 0x1118,0x1128,0x1131,0x1141,0x1151,0x1161,0x1171,0x0003
  .hword 0x1188,0x0008,0x1198,0x11a7,0x11b1,0x11c7,0x11d1,0x11e8
  .hword 0x11f8,0x1201,0x1211,0x1221,0x1231,0x1241,0x0003,0x1258
  .hword 0x0008,0x1268,0x1277,0x1281,0x1297,0x12a1,0x12b8,0x12c8
  .hword 0x12d1,0x12e1,0x12f1,0x1301,0x1311,0x0003,0x1328,0x0008
  .hword 0x1338,0x1347,0x1351,0x1367,0x1371,0x1388,0x1398,0x13a1
  .hword 0x13b1,0x13c1,0x13d1,0x13e1,0x0003,0x13f8,0x0008,0x1408
  .hword 0x1417,0x1421,0x1437,0x1441,0x1458,0x1468,0x1471,0x1481
  .hword 0x1491,0x14a1,0x14b1,0x0000,0x0043,0x0fe8,0x0008,0x0ff8
  .hword 0x1007,0x1011,0x1027,0x1031,0x1048,0x1058,0x1061,0x1071
  .hword 0x1081,0x1091,0x10a1,0x0000,0x0043,0x10b8,0x0008,0x10c8
  .hword 0x10d7,0x10e1,0x10f7,0x1101,0x1118,0x1128,0x1131,0x1141
  .hword 0x1151,0x1161,0x1171,0x0003,0x1668,0x0008,0x1678,0x1687
  .hword 0x1691,0x16a7,0x16b1,0x16c8,0x16d8,0x16e1,0x16f1,0x1701
  .hword 0x1711,0x1721,0x0003,0x1738,0x0008,0x1748,0x1757,0x1761
  .hword 0x1777,0x1781,0x1798,0x17a8,0x17b1,0x17c1,0x17d1,0x17e1
  .hword 0x17f1,0x0003,0x1328,0x0008,0x1338,0x1347,0x1351,0x1367
  .hword 0x1371,0x1388,0x1398,0x13a1,0x13b1,0x13c1,0x13d1,0x13e1
  .hword 0x0003,0x13f8,0x0008,0x1408,0x1417,0x1421,0x1437,0x1441
  .hword 0x1458,0x1468,0x1471,0x1481,0x1491,0x14a1,0x14b1,0x0000
  .hword 0x0043,0x180f,0x1818,0x1828,0x1838,0x1848,0x1858,0x1861
  .hword 0x1871,0x1881,0x1891,0x18a1,0x0003,0x18bf,0x18c8,0x18d8
  .hword 0x18e8,0x18f8,0x1908,0x1911,0x1921,0x1931,0x1941,0x1951
  .hword 0x0003,0x196f,0x1978,0x1988,0x1998,0x19a8,0x19b8,0x19c1
  .hword 0x19d1,0x19e1,0x19f1,0x1a01,0x0003,0x1a1f,0x1a28,0x1a38
  .hword 0x1a48,0x1a58,0x1a68,0x1a71,0x1a81,0x1a91,0x1aa1,0x1ab1
  .hword 0x0003,0x1acf,0x1ad8,0x1ae8,0x1af8,0x1b08,0x1b18,0x1b21
  .hword 0x1b31,0x1b41,0x1b51,0x1b61,0x0003,0x1b7f,0x1b88,0x1b98
  .hword 0x1ba8,0x1bb8,0x1bc8,0x1bd1,0x1be1,0x1bf1,0x1c01,0x1c11
  .hword 0x0003,0x1c2f,0x1c38,0x1c48,0x1c58,0x1c68,0x1c78,0x1c81
  .hword 0x1c91,0x1ca1,0x1cb1,0x1cc1,0x0003,0x1cdf,0x1ce8,0x1cf8
  .hword 0x1d08,0x1d18,0x1d28,0x1d31,0x1d41,0x1d51,0x1d61,0x1d71
  .hword 0x0003,0x180f,0x1818,0x1828,0x1838,0x1848,0x1858,0x1861
  .hword 0x1871,0x1881,0x1891,0x18a1,0x0003,0x18bf,0x18c8,0x18d8
  .hword 0x18e8,0x18f8,0x1908,0x1911,0x1921,0x1931,0x1941,0x1951
  .hword 0x0003,0x196f,0x1978,0x1988,0x1998,0x19a8,0x19b8,0x19c1
  .hword 0x19d1,0x19e1,0x19f1,0x1a01,0x0003,0x1a1f,0x1a28,0x1a38
  .hword 0x1a48,0x1a58,0x1a68,0x1a71,0x1a81,0x1a91,0x1aa1,0x1ab1
  .hword 0x0003,0x1acf,0x1ad8,0x1ae8,0x1af8,0x1b08,0x1b18,0x1b21
  .hword 0x1b31,0x1b41,0x1b51,0x1b61,0x0003,0x1b7f,0x1b88,0x1b98
  .hword 0x1ba8,0x1bb8,0x1bc8,0x1bd1,0x1be1,0x1bf1,0x1c01,0x1c11
  .hword 0x0003,0x1c2f,0x1c38,0x1c48,0x1c58,0x1c68,0x1c78,0x1c81
  .hword 0x1c91,0x1ca1,0x1cb1,0x1cc1,0x0003,0x1d8f,0x1d98,0x1da8
  .hword 0x1db8,0x1dc8,0x1dd8,0x1de1,0x1df1,0x1e01,0x1e11,0x1e21
  .hword 0x0003,0x180f,0x1818,0x1828,0x1838,0x1848,0x1858,0x1861
  .hword 0x1871,0x1881,0x1891,0x18a1,0x0003,0x18bf,0x18c8,0x18d8
  .hword 0x18e8,0x18f8,0x1908,0x1911,0x1921,0x1931,0x1941,0x1951
  .hword 0x0003,0x196f,0x1978,0x1988,0x1998,0x19a8,0x19b8,0x19c1
  .hword 0x19d1,0x19e1,0x19f1,0x1a01,0x0003,0x1a1f,0x1a28,0x1a38
  .hword 0x1a48,0x1a58,0x1a68,0x1a71,0x1a81,0x1a91,0x1aa1,0x1ab1
  .hword 0x0003,0x1acf,0x1ad8,0x1ae8,0x1af8,0x1b08,0x1b18,0x1b21
  .hword 0x1b31,0x1b41,0x1b51,0x1b61,0x0003,0x1b7f,0x1b88,0x1b98
  .hword 0x1ba8,0x1bb8,0x1bc8,0x1bd1,0x1be1,0x1bf1,0x1c01,0x1c11
  .hword 0x0003,0x1c2f,0x1c38,0x1c48,0x1c58,0x1c68,0x1c78,0x1c81
  .hword 0x1c91,0x1ca1,0x1cb1,0x1cc1,0x0000,0x0043,0x180f,0x1818
  .hword 0x1828,0x1838,0x1848,0x1858,0x1861,0x1871,0x1881,0x1891
  .hword 0x18a1,0x0003,0x18bf,0x18c8,0x18d8,0x18e8,0x18f8,0x1908
  .hword 0x1911,0x1921,0x1931,0x1941,0x1951,0x0003,0x196f,0x1978
  .hword 0x1988,0x1998,0x19a8,0x19b8,0x19c1,0x19d1,0x19e1,0x19f1
  .hword 0x1a01,0x0003,0x1a1f,0x1a28,0x1a38,0x1a48,0x1a58,0x1a68
  .hword 0x1a71,0x1a81,0x1a91,0x1aa1,0x1ab1,0x0003,0x1acf,0x1ad8
  .hword 0x1ae8,0x1af8,0x1b08,0x1b18,0x1b21,0x1b31,0x1b41,0x1b51
  .hword 0x1b61,0x0003,0x1b7f,0x1b88,0x1b98,0x1ba8,0x1bb8,0x1bc8
  .hword 0x1bd1,0x1be1,0x1bf1,0x1c01,0x1c11,0x0003,0x1c2f,0x1c38
  .hword 0x1c48,0x1c58,0x1c68,0x1c78,0x1c81,0x1c91,0x1ca1,0x1cb1
  .hword 0x1cc1,0x0000,0x0043,0x180f,0x1818,0x1828,0x1838,0x1848
  .hword 0x1858,0x1861,0x1871,0x1881,0x1891,0x18a1,0x0003,0x18bf
  .hword 0x18c8,0x18d8,0x18e8,0x18f8,0x1908,0x1911,0x1921,0x1931
  .hword 0x1941,0x1951,0x0003,0x196f,0x1978,0x1988,0x1998,0x19a8
  .hword 0x19b8,0x19c1,0x19d1,0x19e1,0x19f1,0x1a01,0x0003,0x1a1f
  .hword 0x1a28,0x1a38,0x1a48,0x1a58,0x1a68,0x1a71,0x1a81,0x1a91
  .hword 0x1aa1,0x1ab1,0x0003,0x1acf,0x1ad8,0x1ae8,0x1af8,0x1b08
  .hword 0x1b18,0x1b21,0x1b31,0x1b41,0x1b51,0x1b61,0x0003,0x1b7f
  .hword 0x1b88,0x1b98,0x1ba8,0x1bb8,0x1bc8,0x1bd1,0x1be1,0x1bf1
  .hword 0x1c01,0x1c11,0x0003,0x1c2f,0x1c38,0x1c48,0x1c58,0x1c68
  .hword 0x1c78,0x1c81,0x1c91,0x1ca1,0x1cb1,0x1cc1,0x0000,0x0043
  .hword 0x180f,0x1818,0x1828,0x1838,0x1848,0x1858,0x1861,0x1871
  .hword 0x1881,0x1891,0x18a1,0x0003,0x18bf,0x18c8,0x18d8,0x18e8
  .hword 0x18f8,0x1908,0x1911,0x1921,0x1931,0x1941,0x1951,0x0003
  .hword 0x196f,0x1978,0x1988,0x1998,0x19a8,0x19b8,0x19c1,0x19d1
  .hword 0x19e1,0x19f1,0x1a01,0x0003,0x1a1f,0x1a28,0x1a38,0x1a48
  .hword 0x1a58,0x1a68,0x1a71,0x1a81,0x1a91,0x1aa1,0x1ab1,0x0003
  .hword 0x1acf,0x1ad8,0x1ae8,0x1af8,0x1b08,0x1b18,0x1b21,0x1b31
  .hword 0x1b41,0x1b51,0x1b61,0x0003,0x1b7f,0x1b88,0x1b98,0x1ba8
  .hword 0x1bb8,0x1bc8,0x1bd1,0x1be1,0x1bf1,0x1c01,0x1c11,0x0003
  .hword 0x1c2f,0x1c38,0x1c48,0x1c58,0x1c68,0x1c78,0x1c81,0x1c91
  .hword 0x1ca1,0x1cb1,0x1cc1,0x0000,0x0043,0x180f,0x1818,0x1828
  .hword 0x1838,0x1848,0x1858,0x1861,0x1871,0x1881,0x1891,0x18a1
  .hword 0x0003,0x18bf,0x18c8,0x18d8,0x18e8,0x18f8,0x1908,0x1911
  .hword 0x1921,0x1931,0x1941,0x1951,0x0003,0x196f,0x1978,0x1988
  .hword 0x1998,0x19a8,0x19b8,0x19c1,0x19d1,0x19e1,0x19f1,0x1a01
  .hword 0x0003,0x1a1f,0x1a28,0x1a38,0x1a48,0x1a58,0x1a68,0x1a71
  .hword 0x1a81,0x1a91,0x1aa1,0x1ab1,0x0003,0x1acf,0x1ad8,0x1ae8
  .hword 0x1af8,0x1b08,0x1b18,0x1b21,0x1b31,0x1b41,0x1b51,0x1b61
  .hword 0x0003,0x1b7f,0x1b88,0x1b98,0x1ba8,0x1bb8,0x1bc8,0x1bd1
  .hword 0x1be1,0x1bf1,0x1c01,0x1c11,0x0003,0x1c2f,0x1c38,0x1c48
  .hword 0x1c58,0x1c68,0x1c78,0x1c81,0x1c91,0x1ca1,0x1cb1,0x1cc1
  .hword 0x0000,0x0043,0x180f,0x1818,0x1828,0x1838,0x1848,0x1858
  .hword 0x1861,0x1871,0x1881,0x1891,0x18a1,0x0003,0x18bf,0x18c8
  .hword 0x18d8,0x18e8,0x18f8,0x1908,0x1911,0x1921,0x1931,0x1941
  .hword 0x1951,0x0003,0x196f,0x1978,0x1988,0x1998,0x19a8,0x19b8
  .hword 0x19c1,0x19d1,0x19e1,0x19f1,0x1a01,0x0003,0x1e3f,0x1e48
  .hword 0x1e58,0x1e68,0x1e78,0x1e88,0x1e91,0x1ea1,0x1eb1,0x1ec1
  .hword 0x1ed1,0x0003,0x1eef,0x1ef8,0x1f08,0x1f18,0x1f28,0x1f38
  .hword 0x1f41,0x1f51,0x1f61,0x1f71,0x1f81,0x0003,0x1b7f,0x1b88
  .hword 0x1b98,0x1ba8,0x1bb8,0x1bc8,0x1bd1,0x1be1,0x1bf1,0x1c01
  .hword 0x1c11,0x0003,0x1c2f,0x1c38,0x1c48,0x1c58,0x1c68,0x1c78
  .hword 0x1c81,0x1c91,0x1ca1,0x1cb1,0x1cc1,0x0000,0x0043,0x1f9f
  .hword 0x1fa8,0x1fb8,0x1fc8,0x1fd8,0x1fe8,0x1ff1,0x2001,0x2011
  .hword 0x2021,0x2031,0x0003,0x204f,0x2058,0x2068,0x2078,0x2088
  .hword 0x2098,0x20a1,0x20b1,0x20c1,0x20d1,0x20e1,0x0003,0x20ff
  .hword 0x2108,0x2118,0x2128,0x2138,0x2148,0x2151,0x2161,0x2171
  .hword 0x2181,0x2191,0x0003,0x21af,0x21b8,0x21c8,0x21d8,0x21e8
  .hword 0x21f8,0x2201,0x2211,0x2221,0x2231,0x2241,0x0003,0x225f
  .hword 0x2268,0x2278,0x2288,0x2298,0x22a8,0x22b1,0x22c1,0x22d1
  .hword 0x22e1,0x22f1,0x0003,0x230f,0x2318,0x2328,0x2338,0x2348
  .hword 0x2358,0x2361,0x2371,0x2381,0x2391,0x23a1,0x0003,0x23bf
  .hword 0x23c8,0x23d8,0x23e8,0x23f8,0x2408,0x2411,0x2421,0x2431
  .hword 0x2441,0x2451,0x0003,0x246f,0x2478,0x2488,0x2498,0x24a8
  .hword 0x24b8,0x24c1,0x24d1,0x24e1,0x24f1,0x2501,0x0003,0x1f9f
  .hword 0x1fa8,0x1fb8,0x1fc8,0x1fd8,0x1fe8,0x1ff1,0x2001,0x2011
  .hword 0x2021,0x2031,0x0003,0x204f,0x2058,0x2068,0x2078,0x2088
  .hword 0x2098,0x20a1,0x20b1,0x20c1,0x20d1,0x20e1,0x0003,0x20ff
  .hword 0x2108,0x2118,0x2128,0x2138,0x2148,0x2151,0x2161,0x2171
  .hword 0x2181,0x2191,0x0003,0x21af,0x21b8,0x21c8,0x21d8,0x21e8
  .hword 0x21f8,0x2201,0x2211,0x2221,0x2231,0x2241,0x0003,0x225f
  .hword 0x2268,0x2278,0x2288,0x2298,0x22a8,0x22b1,0x22c1,0x22d1
  .hword 0x22e1,0x22f1,0x0003,0x230f,0x2318,0x2328,0x2338,0x2348
  .hword 0x2358,0x2361,0x2371,0x2381,0x2391,0x23a1,0x0003,0x23bf
  .hword 0x23c8,0x23d8,0x23e8,0x23f8,0x2408,0x2411,0x2421,0x2431
  .hword 0x2441,0x2451,0x0003,0x251f,0x2528,0x2538,0x2548,0x2558
  .hword 0x2568,0x2571,0x2581,0x2591,0x25a1,0x25b1,0x0003,0x1f9f
  .hword 0x1fa8,0x1fb8,0x1fc8,0x1fd8,0x1fe8,0x1ff1,0x2001,0x2011
  .hword 0x2021,0x2031,0x0003,0x204f,0x2058,0x2068,0x2078,0x2088
  .hword 0x2098,0x20a1,0x20b1,0x20c1,0x20d1,0x20e1,0x0003,0x20ff
  .hword 0x2108,0x2118,0x2128,0x2138,0x2148,0x2151,0x2161,0x2171
  .hword 0x2181,0x2191,0x0003,0x21af,0x21b8,0x21c8,0x21d8,0x21e8
  .hword 0x21f8,0x2201,0x2211,0x2221,0x2231,0x2241,0x0003,0x225f
  .hword 0x2268,0x2278,0x2288,0x2298,0x22a8,0x22b1,0x22c1,0x22d1
  .hword 0x22e1,0x22f1,0x0003,0x230f,0x2318,0x2328,0x2338,0x2348
  .hword 0x2358,0x2361,0x2371,0x2381,0x2391,0x23a1,0x0003,0x23bf
  .hword 0x23c8,0x23d8,0x23e8,0x23f8,0x2408,0x2411,0x2421,0x2431
  .hword 0x2441,0x2451,0x0000,0x0043,0x1f9f,0x1fa8,0x1fb8,0x1fc8
  .hword 0x1fd8,0x1fe8,0x1ff1,0x2001,0x2011,0x2021,0x2031,0x0003
  .hword 0x204f,0x2058,0x2068,0x2078,0x2088,0x2098,0x20a1,0x20b1
  .hword 0x20c1,0x20d1,0x20e1,0x0003,0x20ff,0x2108,0x2118,0x2128
  .hword 0x2138,0x2148,0x2151,0x2161,0x2171,0x2181,0x2191,0x0003
  .hword 0x21af,0x21b8,0x21c8,0x21d8,0x21e8,0x21f8,0x2201,0x2211
  .hword 0x2221,0x2231,0x2241,0x0003,0x225f,0x2268,0x2278,0x2288
  .hword 0x2298,0x22a8,0x22b1,0x22c1,0x22d1,0x22e1,0x22f1,0x0003
  .hword 0x230f,0x2318,0x2328,0x2338,0x2348,0x2358,0x2361,0x2371
  .hword 0x2381,0x2391,0x23a1,0x0003,0x23bf,0x23c8,0x23d8,0x23e8
  .hword 0x23f8,0x2408,0x2411,0x2421,0x2431,0x2441,0x2451,0x0000
  .hword 0x0043,0x1f9f,0x1fa8,0x1fb8,0x1fc8,0x1fd8,0x1fe8,0x1ff1
  .hword 0x2001,0x2011,0x2021,0x2031,0x0003,0x204f,0x2058,0x2068
  .hword 0x2078,0x2088,0x2098,0x20a1,0x20b1,0x20c1,0x20d1,0x20e1
  .hword 0x0003,0x20ff,0x2108,0x2118,0x2128,0x2138,0x2148,0x2151
  .hword 0x2161,0x2171,0x2181,0x2191,0x0003,0x21af,0x21b8,0x21c8
  .hword 0x21d8,0x21e8,0x21f8,0x2201,0x2211,0x2221,0x2231,0x2241
  .hword 0x0003,0x225f,0x2268,0x2278,0x2288,0x2298,0x22a8,0x22b1
  .hword 0x22c1,0x22d1,0x22e1,0x22f1,0x0003,0x230f,0x2318,0x2328
  .hword 0x2338,0x2348,0x2358,0x2361,0x2371,0x2381,0x2391,0x23a1
  .hword 0x0003,0x23bf,0x23c8,0x23d8,0x23e8,0x23f8,0x2408,0x2411
  .hword 0x2421,0x2431,0x2441,0x2451,0x0000,0x0043,0x1f9f,0x1fa8
  .hword 0x1fb8,0x1fc8,0x1fd8,0x1fe8,0x1ff1,0x2001,0x2011,0x2021
  .hword 0x2031,0x0003,0x204f,0x2058,0x2068,0x2078,0x2088,0x2098
  .hword 0x20a1,0x20b1,0x20c1,0x20d1,0x20e1,0x0003,0x20ff,0x2108
  .hword 0x2118,0x2128,0x2138,0x2148,0x2151,0x2161,0x2171,0x2181
  .hword 0x2191,0x0003,0x21af,0x21b8,0x21c8,0x21d8,0x21e8,0x21f8
  .hword 0x2201,0x2211,0x2221,0x2231,0x2241,0x0003,0x225f,0x2268
  .hword 0x2278,0x2288,0x2298,0x22a8,0x22b1,0x22c1,0x22d1,0x22e1
  .hword 0x22f1,0x0003,0x230f,0x2318,0x2328,0x2338,0x2348,0x2358
  .hword 0x2361,0x2371,0x2381,0x2391,0x23a1,0x0003,0x23bf,0x23c8
  .hword 0x23d8,0x23e8,0x23f8,0x2408,0x2411,0x2421,0x2431,0x2441
  .hword 0x2451,0x0000,0x0043,0x1f9f,0x1fa8,0x1fb8,0x1fc8,0x1fd8
  .hword 0x1fe8,0x1ff1,0x2001,0x2011,0x2021,0x2031,0x0003,0x204f
  .hword 0x2058,0x2068,0x2078,0x2088,0x2098,0x20a1,0x20b1,0x20c1
  .hword 0x20d1,0x20e1,0x0003,0x20ff,0x2108,0x2118,0x2128,0x2138
  .hword 0x2148,0x2151,0x2161,0x2171,0x2181,0x2191,0x0003,0x21af
  .hword 0x21b8,0x21c8,0x21d8,0x21e8,0x21f8,0x2201,0x2211,0x2221
  .hword 0x2231,0x2241,0x0003,0x225f,0x2268,0x2278,0x2288,0x2298
  .hword 0x22a8,0x22b1,0x22c1,0x22d1,0x22e1,0x22f1,0x0003,0x230f
  .hword 0x2318,0x2328,0x2338,0x2348,0x2358,0x2361,0x2371,0x2381
  .hword 0x2391,0x23a1,0x0003,0x23bf,0x23c8,0x23d8,0x23e8,0x23f8
  .hword 0x2408,0x2411,0x2421,0x2431,0x2441,0x2451,0x0000,0x0043
  .hword 0x1f9f,0x1fa8,0x1fb8,0x1fc8,0x1fd8,0x1fe8,0x1ff1,0x2001
  .hword 0x2011,0x2021,0x2031,0x0003,0x204f,0x2058,0x2068,0x2078
  .hword 0x2088,0x2098,0x20a1,0x20b1,0x20c1,0x20d1,0x20e1,0x0003
  .hword 0x20ff,0x2108,0x2118,0x2128,0x2138,0x2148,0x2151,0x2161
  .hword 0x2171,0x2181,0x2191,0x0003,0x25cf,0x25d8,0x25e8,0x25f8
  .hword 0x2608,0x2618,0x2621,0x2631,0x2641,0x2651,0x2661,0x0003
  .hword 0x267f,0x2688,0x2698,0x26a8,0x26b8,0x26c8,0x26d1,0x26e1
  .hword 0x26f1,0x2701,0x2711,0x0003,0x230f,0x2318,0x2328,0x2338
  .hword 0x2348,0x2358,0x2361,0x2371,0x2381,0x2391,0x23a1,0x0003
  .hword 0x23bf,0x23c8,0x23d8,0x23e8,0x23f8,0x2408,0x2411,0x2421
  .hword 0x2431,0x2441,0x2451,0x0000,0x0043,0x2728,0x0008,0x2738
  .hword 0x2747,0x2751,0x2767,0x2771,0x2788,0x2798,0x27a1,0x27b1
  .hword 0x0006,0x27c8,0x0008,0x27d8,0x27e8,0x27f8,0x2808,0x2818
  .hword 0x2821,0x2831,0x0006,0x2848,0x0008,0x2858,0x2868,0x2878
  .hword 0x2888,0x2898,0x28a1,0x28b1,0x0006,0x28c8,0x0008,0x28d8
  .hword 0x28e8,0x28f8,0x2908,0x2918,0x2921,0x2931,0x0000,0x0086
  .hword 0x2948,0x0008,0x2958,0x2968,0x2978,0x2988,0x2998,0x29a1
  .hword 0x29b1,0x29c1,0x29d1,0x29e1,0x0000,0x0013,0x29f8,0x000f
  .hword 0x2a08,0x2a18,0x2a21,0x2a31,0x2a41,0x2a51,0x0004,0x2a68
  .hword 0x0008,0x2a78,0x2a87,0x2a91,0x2aa7,0x2ab1,0x2ac8,0x2ad8
  .hword 0x2ae1,0x2af1,0x0006,0x2b08,0x0008,0x2b18,0x2b28,0x2b38
  .hword 0x2b48,0x2b58,0x2b61,0x2b71,0x0006,0x2b88,0x0008,0x2b98
  .hword 0x2ba8,0x2bb8,0x2bc8,0x2bd8,0x2be1,0x2bf1,0x0000,0x00c6
  .hword 0x2948,0x0008,0x2958,0x2968,0x2978,0x2988,0x2998,0x29a1
  .hword 0x29b1,0x29c1,0x29d1,0x29e1,0x0000,0x0013,0x29f8,0x000f
  .hword 0x2a08,0x2a18,0x2a21,0x2a31,0x2a41,0x2a51,0x0004,0x2c08
  .hword 0x0008,0x2c18,0x2c27,0x2c31,0x2c47,0x2c51,0x2c68,0x2c78
  .hword 0x2c81,0x2c91,0x0006,0x2ca8,0x0008,0x2cb8,0x2cc8,0x2cd8
  .hword 0x2ce8,0x2cf8,0x2d01,0x2d11,0x0006,0x2d28,0x0008,0x2d38
  .hword 0x2d48,0x2d58,0x2d68,0x2d78,0x2d81,0x2d91,0x0006,0x2da8
  .hword 0x0008,0x2db8,0x2dc8,0x2dd8,0x2de8,0x2df8,0x2e01,0x2e11
  .hword 0x2e21,0x2e31,0x2e41,0x0000,0x0083,0x2948,0x0008,0x2958
  .hword 0x2968,0x2978,0x2988,0x2998,0x29a1,0x29b1,0x29c1,0x29d1
  .hword 0x29e1,0x0000,0x0013,0x29f8,0x000f,0x2a08,0x2a18,0x2a21
  .hword 0x2a31,0x2a41,0x2a51,0x0004,0x2e58,0x0008,0x2e68,0x2e77
  .hword 0x2e81,0x2e97,0x2ea1,0x2eb8,0x2ec8,0x2ed1,0x2ee1,0x0006
  .hword 0x2ef8,0x0008,0x2f08,0x2f18,0x2f28,0x2f38,0x2f48,0x2f51
  .hword 0x2f61,0x0006,0x2f78,0x0008,0x2f88,0x2f98,0x2fa8,0x2fb8
  .hword 0x2fc8,0x2fd1,0x2fe1,0x0006,0x2ff8,0x0008,0x3008,0x3018
  .hword 0x3028,0x3038,0x3048,0x3051,0x3061,0x3071,0x3081,0x3091
  .hword 0x0000,0x0083,0x2948,0x0008,0x2958,0x2968,0x2978,0x2988
  .hword 0x2998,0x29a1,0x29b1,0x29c1,0x29d1,0x29e1,0x0000,0x0013
  .hword 0x29f8,0x000f,0x2a08,0x2a18,0x2a21,0x2a31,0x2a41,0x2a51
  .hword 0x0004,0x30a8,0x0008,0x30b8,0x30c7,0x30d1,0x30e7,0x30f1
  .hword 0x3108,0x3118,0x3121,0x3131,0x0006,0x3148,0x0008,0x3158
  .hword 0x000f,0x3168,0x3178,0x3181,0x3191,0x31a1,0x31b1,0x0004
  .hword 0x31c8,0x0008,0x31d8,0x0008,0x31e8,0x31f8,0x3208,0x3211
  .hword 0x3221,0x0006,0x3238,0x0008,0x3248,0x0008,0x3258,0x3268
  .hword 0x3278,0x3281,0x3291,0x0000,0x0086,0x2948,0x0008,0x2958
  .hword 0x2968,0x2978,0x2988,0x2998,0x29a1,0x29b1,0x29c1,0x29d1
  .hword 0x29e1,0x0000,0x0013,0x29f8,0x000f,0x2a08,0x2a18,0x2a21
  .hword 0x2a31,0x2a41,0x2a51,0x0004,0x32a8,0x0008,0x32b8,0x32c7
  .hword 0x32d1,0x32e7,0x32f1,0x3308,0x3318,0x3321,0x3331,0x0006
  .hword 0x3348,0x0008,0x3358,0x3368,0x3378,0x3388,0x3398,0x33a1
  .hword 0x33b1,0x0006,0x33c8,0x0008,0x33d8,0x33e8,0x33f8,0x3408
  .hword 0x3418,0x3421,0x3431,0x0006,0x3448,0x0008,0x3458,0x3467
  .hword 0x3471,0x3487,0x3491,0x34a8,0x34b8,0x34c1,0x34d1,0x0000
  .hword 0x0086,0x2948,0x0008,0x2958,0x2968,0x2978,0x2988,0x2998
  .hword 0x29a1,0x29b1,0x29c1,0x29d1,0x29e1,0x0000,0x0013,0x29f8
  .hword 0x000f,0x2a08,0x2a18,0x2a21,0x2a31,0x2a41,0x2a51,0x0000
  .hword 0x0094,0x34e8,0x34f8,0x0008,0x3508,0x3518,0x3521,0x3531
  .hword 0x3541,0x3551,0x0000,0x0014,0x3568,0x3578,0x0008,0x3588
  .hword 0x3598,0x35a1,0x35b1,0x35c1,0x35d1,0x0000,0x0084,0x2948
  .hword 0x0008,0x2958,0x2968,0x2978,0x2988,0x2998,0x29a1,0x29b1
  .hword 0x29c1,0x29d1,0x29e1,0x0000,0x0013,0x29f8,0x000f,0x2a08
  .hword 0x2a18,0x2a21,0x2a31,0x2a41,0x2a51,0x0000,0x0044,0x35ef
  .hword 0x35f7,0x3601,0x3618,0x3628,0x3638,0x3641,0x3651,0x3661
  .hword 0x3671,0x0001,0x3681,0x3691,0x36a1,0x0000,0x0018,0x36b8
  .hword 0x000f,0x36c8,0x36d8,0x36e1,0x36f1,0x3701,0x3711,0x0000
  .hword 0x0014,0x3728,0x000f,0x3738,0x3748,0x3751,0x3761,0x3771
  .hword 0x3781,0x0000,0x0084,0x2948,0x0008,0x2958,0x2968,0x2978
  .hword 0x2988,0x2998,0x29a1,0x29b1,0x29c1,0x29d1,0x29e1,0x0000
  .hword 0x0013,0x29f8,0x000f,0x2a08,0x2a18,0x2a21,0x2a31,0x2a41
  .hword 0x2a51,0x0004,0x3798,0x0008,0x37a8,0x37b7,0x37c1,0x37d7
  .hword 0x37e1,0x37f8,0x3808,0x3811,0x3821,0x0006,0x3838,0x3848
  .hword 0x3858,0x3868,0x3878,0x3888,0x3898,0x38a1,0x38b1,0x0006
  .hword 0x38c8,0x38d8,0x38e8,0x38f8,0x3908,0x3918,0x3928,0x3931
  .hword 0x3941,0x0006,0x3958,0x3968,0x3978,0x3987,0x3991,0x39a7
  .hword 0x39b1,0x39c8,0x39d8,0x39e1,0x39f1,0x0006,0x3a08,0x0008
  .hword 0x3a18,0x3a27,0x3a31,0x3a47,0x3a51,0x3a68,0x3a78,0x3a81
  .hword 0x3a91,0x0006,0x3aa8,0x3ab8,0x3ac8,0x3ad8,0x3ae8,0x3af8
  .hword 0x3b08,0x3b11,0x3b21,0x0006,0x3b38,0x3b48,0x3b58,0x3b68
  .hword 0x3b78,0x3b88,0x3b98,0x3ba1,0x3bb1,0x0006,0x3bc8,0x3bd8
  .hword 0x3be8,0x3bf7,0x3c01,0x3c17,0x3c21,0x3c38,0x3c48,0x3c51
  .hword 0x3c61,0x0006,0x3c78,0x0008,0x3c88,0x3c97,0x3ca1,0x3cb7
  .hword 0x3cc1,0x3cd8,0x3ce8,0x3cf1,0x3d01,0x0006,0x3d18,0x3d28
  .hword 0x3d38,0x3d48,0x3d58,0x3d68,0x3d78,0x3d81,0x3d91,0x0006
  .hword 0x3da8,0x3db8,0x3dc8,0x3dd8,0x3de8,0x3df8,0x3e08,0x3e11
  .hword 0x3e21,0x0006,0x3e38,0x3e48,0x3e58,0x3e67,0x3e71,0x3e87
  .hword 0x3e91,0x3ea8,0x3eb8,0x3ec1,0x3ed1,0x0006,0x3ee8,0x0008
  .hword 0x3ef8,0x3f07,0x3f11,0x3f27,0x3f31,0x3f48,0x3f58,0x3f61
  .hword 0x3f71,0x0006,0x3f88,0x3f98,0x3fa8,0x3fb8,0x3fc8,0x3fd8
  .hword 0x3fe8,0x3ff1,0x4001,0x0006,0x4018,0x4028,0x4038,0x4048
  .hword 0x4058,0x4068,0x4078,0x4081,0x4091,0x0006,0x40a8,0x40b8
  .hword 0x40c8,0x40d7,0x40e1,0x40f7,0x4101,0x4118,0x4128,0x4131
  .hword 0x4141,0x0006,0x3c78,0x0008,0x3c88,0x3c97,0x3ca1,0x3cb7
  .hword 0x3cc1,0x3cd8,0x3ce8,0x3cf1,0x3d01,0x0006,0x3d18,0x3d28
  .hword 0x3d38,0x3d48,0x3d58,0x3d68,0x3d78,0x3d81,0x3d91,0x0006
  .hword 0x3da8,0x3db8,0x3dc8,0x3dd8,0x3de8,0x3df8,0x3e08,0x3e11
  .hword 0x3e21,0x0006,0x4158,0x4168,0x4178,0x4187,0x4191,0x41a7
  .hword 0x41b1,0x41c8,0x41d8,0x41e1,0x41f1,0x0006,0x3ee8,0x0008
  .hword 0x3ef8,0x3f07,0x3f11,0x3f27,0x3f31,0x3f48,0x3f58,0x3f61
  .hword 0x3f71,0x0006,0x3f88,0x3f98,0x3fa8,0x3fb8,0x3fc8,0x3fd8
  .hword 0x3fe8,0x3ff1,0x4001,0x0006,0x4018,0x4028,0x4038,0x4048
  .hword 0x4058,0x4068,0x4078,0x4081,0x4091,0x0006,0x4208,0x4218
  .hword 0x4228,0x4237,0x4241,0x4257,0x4261,0x4278,0x4288,0x4291
  .hword 0x42a1,0x0006,0x3c78,0x0008,0x3c88,0x3c97,0x3ca1,0x3cb7
  .hword 0x3cc1,0x3cd8,0x3ce8,0x3cf1,0x3d01,0x0006,0x3d18,0x3d28
  .hword 0x3d38,0x3d48,0x3d58,0x3d68,0x3d78,0x3d81,0x3d91,0x0006
  .hword 0x3da8,0x3db8,0x3dc8,0x3dd8,0x3de8,0x3df8,0x3e08,0x3e11
  .hword 0x3e21,0x0006,0x42b8,0x42c8,0x42d8,0x42e7,0x42f1,0x4307
  .hword 0x4311,0x4328,0x4338,0x4341,0x4351,0x0006,0x3ee8,0x0008
  .hword 0x3ef8,0x3f07,0x3f11,0x3f27,0x3f31,0x3f48,0x3f58,0x3f61
  .hword 0x3f71,0x0006,0x3f88,0x3f98,0x3fa8,0x3fb8,0x3fc8,0x3fd8
  .hword 0x3fe8,0x3ff1,0x4001,0x0006,0x4018,0x4028,0x4038,0x4048
  .hword 0x4058,0x4068,0x4078,0x4081,0x4091,0x0006,0x4368,0x4378
  .hword 0x4388,0x4397,0x43a1,0x43b7,0x43c1,0x43d8,0x43e8,0x43f1
  .hword 0x4401,0x0006,0x3c78,0x0008,0x3c88,0x3c97,0x3ca1,0x3cb7
  .hword 0x3cc1,0x3cd8,0x3ce8,0x3cf1,0x3d01,0x0006,0x3d18,0x3d28
  .hword 0x3d38,0x3d48,0x3d58,0x3d68,0x3d78,0x3d81,0x3d91,0x0006
  .hword 0x3da8,0x3db8,0x3dc8,0x3dd8,0x3de8,0x3df8,0x3e08,0x3e11
  .hword 0x3e21,0x0006,0x4418,0x4428,0x4438,0x4447,0x4451,0x4467
  .hword 0x4471,0x4488,0x4498,0x44a1,0x44b1,0x0006,0x3ee8,0x0008
  .hword 0x3ef8,0x3f07,0x3f11,0x3f27,0x3f31,0x3f48,0x3f58,0x3f61
  .hword 0x3f71,0x0006,0x3f88,0x3f98,0x3fa8,0x3fb8,0x3fc8,0x3fd8
  .hword 0x3fe8,0x3ff1,0x4001,0x0006,0x4018,0x4028,0x4038,0x4048
  .hword 0x4058,0x4068,0x4078,0x4081,0x4091,0x0006,0x44c8,0x44d8
  .hword 0x44e8,0x44f7,0x4501,0x4517,0x4521,0x4538,0x4548,0x4551
  .hword 0x4561,0x0006,0x3c78,0x0008,0x3c88,0x3c97,0x3ca1,0x3cb7
  .hword 0x3cc1,0x3cd8,0x3ce8,0x3cf1,0x3d01,0x0006,0x3d18,0x3d28
  .hword 0x3d38,0x3d48,0x3d58,0x3d68,0x3d78,0x3d81,0x3d91,0x0006
  .hword 0x3da8,0x3db8,0x3dc8,0x3dd8,0x3de8,0x3df8,0x3e08,0x3e11
  .hword 0x3e21,0x0006,0x4578,0x4588,0x4598,0x45a7,0x45b1,0x45c7
  .hword 0x45d1,0x45e8,0x45f8,0x4601,0x4611,0x0006,0x3ee8,0x0008
  .hword 0x3ef8,0x3f07,0x3f11,0x3f27,0x3f31,0x3f48,0x3f58,0x3f61
  .hword 0x3f71,0x0006,0x3f88,0x3f98,0x3fa8,0x3fb8,0x3fc8,0x3fd8
  .hword 0x3fe8,0x3ff1,0x4001,0x0006,0x4018,0x4028,0x4038,0x4048
  .hword 0x4058,0x4068,0x4078,0x4081,0x4091,0x0006,0x4628,0x4638
  .hword 0x4648,0x4657,0x4661,0x4677,0x4681,0x4698,0x46a8,0x46b1
  .hword 0x46c1,0x0006,0x3c78,0x0008,0x3c88,0x3c97,0x3ca1,0x3cb7
  .hword 0x3cc1,0x3cd8,0x3ce8,0x3cf1,0x3d01,0x0006,0x3d18,0x3d28
  .hword 0x3d38,0x3d48,0x3d58,0x3d68,0x3d78,0x3d81,0x3d91,0x0006
  .hword 0x3da8,0x3db8,0x3dc8,0x3dd8,0x3de8,0x3df8,0x3e08,0x3e11
  .hword 0x3e21,0x0006,0x46d8,0x46e8,0x46f8,0x4707,0x4711,0x4727
  .hword 0x4731,0x4748,0x4758,0x4761,0x4771,0x0006,0x3ee8,0x0008
  .hword 0x3ef8,0x3f07,0x3f11,0x3f27,0x3f31,0x3f48,0x3f58,0x3f61
  .hword 0x3f71,0x0006,0x3f88,0x3f98,0x3fa8,0x3fb8,0x3fc8,0x3fd8
  .hword 0x3fe8,0x3ff1,0x4001,0x0006,0x4018,0x4028,0x4038,0x4048
  .hword 0x4058,0x4068,0x4078,0x4081,0x4091,0x0006,0x4788,0x4798
  .hword 0x47a8,0x47b7,0x47c1,0x47d7,0x47e1,0x47f8,0x4808,0x4811
  .hword 0x4821,0x0006,0x3c78,0x0008,0x3c88,0x3c97,0x3ca1,0x3cb7
  .hword 0x3cc1,0x3cd8,0x3ce8,0x3cf1,0x3d01,0x0006,0x3d18,0x3d28
  .hword 0x3d38,0x3d48,0x3d58,0x3d68,0x3d78,0x3d81,0x3d91,0x0006
  .hword 0x3da8,0x3db8,0x3dc8,0x3dd8,0x3de8,0x3df8,0x3e08,0x3e11
  .hword 0x3e21,0x0006,0x4838,0x4848,0x4858,0x4867,0x4871,0x4887
  .hword 0x4891,0x48a8,0x48b8,0x48c1,0x48d1,0x0006,0x3ee8,0x0008
  .hword 0x3ef8,0x3f07,0x3f11,0x3f27,0x3f31,0x3f48,0x3f58,0x3f61
  .hword 0x3f71,0x0006,0x3f88,0x3f98,0x3fa8,0x3fb8,0x3fc8,0x3fd8
  .hword 0x3fe8,0x3ff1,0x4001,0x0006,0x4018,0x4028,0x4038,0x4048
  .hword 0x4058,0x4068,0x4078,0x4081,0x4091,0x0006,0x48e8,0x48f8
  .hword 0x4908,0x4917,0x4921,0x4937,0x4941,0x4958,0x4968,0x4971
  .hword 0x4981,0x0006,0x4991,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1,0x49b1,0x49a1
  .hword 0x49b1,0x49a1,0x49c1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1,0x49e1,0x49d1
  .hword 0x49e1,0x49d1,0x49f1,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01,0x4a11,0x4a01
  .hword 0x4a11,0x4a01,0x4a21,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31,0x4a41,0x4a31
  .hword 0x4a41,0x4a31,0x4a51,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61,0x4a71,0x4a61
  .hword 0x4a71,0x4a61,0x4a81,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91,0x4aa1,0x4a91
  .hword 0x4aa1,0x4a91,0x4ab1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1,0x4ad1,0x4ac1
  .hword 0x4ad1,0x4ac1,0x4ae1,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1,0x4b01,0x4af1
  .hword 0x4b01,0x4af1,0x4b11,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21,0x4b31,0x4b21
  .hword 0x4b31,0x4b21,0x4b41,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51,0x4b61,0x4b51
  .hword 0x4b61,0x4b51,0x4b71,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81,0x4b91,0x4b81
  .hword 0x4b91,0x4b81,0x4ba1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1,0x4bc1,0x4bb1
  .hword 0x4bc1,0x4bb1,0x4bd1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1,0x4bf1,0x4be1
  .hword 0x4bf1,0x4be1,0x4c01,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11,0x4c21,0x4c11
  .hword 0x4c21,0x4c11,0x4c31,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41,0x4c51,0x4c41
  .hword 0x4c51,0x4c41,0x4c61,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71,0x4c81,0x4c71
  .hword 0x4c81,0x4c71,0x4c90,0x0100,0x0000,0x0100,0x4c90,0x0100
  .hword 0x0000,0x0100,0x4c90,0x0100,0x0000,0x0100,0x4c90,0x0100
  .hword 0x0000,0x0100,0x4c90,0x0100,0x0000,0x0100,0x4c90,0x0100
  .hword 0x0000,0x0100,0x4c90,0x0100,0x0000,0x0100,0x4c90,0x0100
  .hword 0x0000,0x0100,0x4ca8,0x0008,0x4cb8,0x4cc7,0x4cd1,0x4ce7
  .hword 0x4cf1,0x4d08,0x4d18,0x4d21,0x4d31,0x4d41,0x4d51,0x4d61
  .hword 0x0003,0x4d78,0x0008,0x4d88,0x4d98,0x4da8,0x4db8,0x4dc8
  .hword 0x4dd1,0x4de1,0x4df1,0x4e01,0x4e11,0x0003,0x4e28,0x0008
  .hword 0x4e38,0x4e48,0x4e58,0x4e68,0x4e78,0x4e81,0x4e91,0x4ea1
  .hword 0x4eb1,0x4ec1,0x0003,0x4ed8,0x0008,0x4ee8,0x4ef8,0x4f08
  .hword 0x4f18,0x4f28,0x4f31,0x4f41,0x4f51,0x4f61,0x4f71,0x0003
  .hword 0x4f88,0x4f97,0x4fa1,0x4fb8,0x4fc7,0x4fd1,0x4fe7,0x4ff1
  .hword 0x5008,0x5018,0x5021,0x5031,0x0000,0x0016,0x5048,0x5058
  .hword 0x5068,0x5078,0x5088,0x5091,0x50a1,0x0000,0x0016,0x50b8
  .hword 0x50c8,0x50d8,0x50e8,0x50f8,0x5101,0x5111,0x0006,0x5128
  .hword 0x0008,0x5138,0x5148,0x5158,0x5168,0x5178,0x5181,0x5191
  .hword 0x51a1,0x51b1,0x51c1,0x0003,0x4ca8,0x0008,0x4cb8,0x4cc7
  .hword 0x4cd1,0x4ce7,0x4cf1,0x4d08,0x4d18,0x4d21,0x4d31,0x4d41
  .hword 0x4d51,0x4d61,0x0003,0x4d78,0x0008,0x4d88,0x4d98,0x4da8
  .hword 0x4db8,0x4dc8,0x4dd1,0x4de1,0x4df1,0x4e01,0x4e11,0x0003
  .hword 0x4e28,0x0008,0x4e38,0x4e48,0x4e58,0x4e68,0x4e78,0x4e81
  .hword 0x4e91,0x4ea1,0x4eb1,0x4ec1,0x0003,0x4ed8,0x0008,0x4ee8
  .hword 0x4ef8,0x4f08,0x4f18,0x4f28,0x4f31,0x4f41,0x4f51,0x4f61
  .hword 0x4f71,0x0003,0x4f88,0x4f97,0x4fa1,0x4fb8,0x4fc7,0x4fd1
  .hword 0x4fe7,0x4ff1,0x5008,0x5018,0x5021,0x5031,0x0000,0x0016
  .hword 0x5048,0x5058,0x5068,0x5078,0x5088,0x5091,0x50a1,0x0000
  .hword 0x0016,0x50b8,0x50c8,0x50d8,0x50e8,0x50f8,0x5101,0x5111
  .hword 0x0006,0x5128,0x0008,0x5138,0x5148,0x5158,0x5168,0x5178
  .hword 0x5181,0x5191,0x51a1,0x51b1,0x51c1,0x0003,0x4ca8,0x0008
  .hword 0x4cb8,0x4cc7,0x4cd1,0x4ce7,0x4cf1,0x4d08,0x4d18,0x4d21
  .hword 0x4d31,0x4d41,0x4d51,0x4d61,0x0003,0x4d78,0x0008,0x4d88
  .hword 0x4d98,0x4da8,0x4db8,0x4dc8,0x4dd1,0x4de1,0x4df1,0x4e01
  .hword 0x4e11,0x0003,0x4e28,0x0008,0x4e38,0x4e48,0x4e58,0x4e68
  .hword 0x4e78,0x4e81,0x4e91,0x4ea1,0x4eb1,0x4ec1,0x0003,0x4ed8
  .hword 0x0008,0x4ee8,0x4ef8,0x4f08,0x4f18,0x4f28,0x4f31,0x4f41
  .hword 0x4f51,0x4f61,0x4f71,0x0003,0x4f88,0x4f97,0x4fa1,0x4fb8
  .hword 0x4fc7,0x4fd1,0x4fe7,0x4ff1,0x5008,0x5018,0x5021,0x5031
  .hword 0x0000,0x0016,0x5048,0x5058,0x5068,0x5078,0x5088,0x5091
  .hword 0x50a1,0x0000,0x0016,0x50b8,0x50c8,0x50d8,0x50e8,0x50f8
  .hword 0x5101,0x5111,0x0006,0x5128,0x0008,0x5138,0x5148,0x5158
  .hword 0x5168,0x5178,0x5181,0x5191,0x51a1,0x51b1,0x51c1,0x0003
  .hword 0x4ca8,0x0008,0x4cb8,0x4cc7,0x4cd1,0x4ce7,0x4cf1,0x4d08
  .hword 0x4d18,0x4d21,0x4d31,0x4d41,0x4d51,0x4d61,0x0003,0x4d78
  .hword 0x0008,0x4d88,0x4d98,0x4da8,0x4db8,0x4dc8,0x4dd1,0x4de1
  .hword 0x4df1,0x4e01,0x4e11,0x0003,0x4e28,0x0008,0x4e38,0x4e48
  .hword 0x4e58,0x4e68,0x4e78,0x4e81,0x4e91,0x4ea1,0x4eb1,0x4ec1
  .hword 0x0003,0x4ed8,0x0008,0x4ee8,0x4ef8,0x4f08,0x4f18,0x4f28
  .hword 0x4f31,0x4f41,0x4f51,0x4f61,0x4f71,0x0003,0x4f88,0x4f97
  .hword 0x4fa1,0x4fb8,0x4fc7,0x4fd1,0x4fe7,0x4ff1,0x5008,0x5018
  .hword 0x5021,0x5031,0x0000,0x0016,0x5048,0x5058,0x5068,0x5078
  .hword 0x5088,0x5091,0x50a1,0x0000,0x0016,0x50b8,0x50c8,0x50d8
  .hword 0x50e8,0x50f8,0x5101,0x5111,0x0006,0x5128,0x0008,0x5138
  .hword 0x5148,0x5158,0x5168,0x5178,0x5181,0x5191,0x51a1,0x51b1
  .hword 0x51c1,0x0003,0x4ca8,0x0008,0x4cb8,0x4cc7,0x4cd1,0x4ce7
  .hword 0x4cf1,0x4d08,0x4d18,0x4d21,0x4d31,0x4d41,0x4d51,0x4d61
  .hword 0x0003,0x4d78,0x0008,0x4d88,0x4d98,0x4da8,0x4db8,0x4dc8
  .hword 0x4dd1,0x4de1,0x4df1,0x4e01,0x4e11,0x0003,0x4e28,0x0008
  .hword 0x4e38,0x4e48,0x4e58,0x4e68,0x4e78,0x4e81,0x4e91,0x4ea1
  .hword 0x4eb1,0x4ec1,0x0003,0x4ed8,0x0008,0x4ee8,0x4ef8,0x4f08
  .hword 0x4f18,0x4f28,0x4f31,0x4f41,0x4f51,0x4f61,0x4f71,0x0003
  .hword 0x4f88,0x4f97,0x4fa1,0x4fb8,0x4fc7,0x4fd1,0x4fe7,0x4ff1
  .hword 0x5008,0x5018,0x5021,0x5031,0x0000,0x0016,0x5048,0x5058
  .hword 0x5068,0x5078,0x5088,0x5091,0x50a1,0x0000,0x0016,0x50b8
  .hword 0x50c8,0x50d8,0x50e8,0x50f8,0x5101,0x5111,0x0006,0x5128
  .hword 0x0008,0x5138,0x5148,0x5158,0x5168,0x5178,0x5181,0x5191
  .hword 0x51a1,0x51b1,0x51c1,0x0003,0x4ca8,0x0008,0x4cb8,0x4cc7
  .hword 0x4cd1,0x4ce7,0x4cf1,0x4d08,0x4d18,0x4d21,0x4d31,0x4d41
  .hword 0x4d51,0x4d61,0x0003,0x4d78,0x0008,0x4d88,0x4d98,0x4da8
  .hword 0x4db8,0x4dc8,0x4dd1,0x4de1,0x4df1,0x4e01,0x4e11,0x0003
  .hword 0x4e28,0x0008,0x4e38,0x4e48,0x4e58,0x4e68,0x4e78,0x4e81
  .hword 0x4e91,0x4ea1,0x4eb1,0x4ec1,0x0003,0x4ed8,0x0008,0x4ee8
  .hword 0x4ef8,0x4f08,0x4f18,0x4f28,0x4f31,0x4f41,0x4f51,0x4f61
  .hword 0x4f71,0x0003,0x4f88,0x4f97,0x4fa1,0x4fb8,0x4fc7,0x4fd1
  .hword 0x4fe7,0x4ff1,0x5008,0x5018,0x5021,0x5031,0x0000,0x0016
  .hword 0x5048,0x5058,0x5068,0x5078,0x5088,0x5091,0x50a1,0x0000
  .hword 0x0016,0x50b8,0x50c8,0x50d8,0x50e8,0x50f8,0x5101,0x5111
  .hword 0x0006,0x5128,0x0008,0x5138,0x5148,0x5158,0x5168,0x5178
  .hword 0x5181,0x5191,0x51a1,0x51b1,0x51c1,0x0003,0x4ca8,0x0008
  .hword 0x4cb8,0x4cc7,0x4cd1,0x4ce7,0x4cf1,0x4d08,0x4d18,0x4d21
  .hword 0x4d31,0x4d41,0x4d51,0x4d61,0x0003,0x4d78,0x0008,0x4d88
  .hword 0x4d98,0x4da8,0x4db8,0x4dc8,0x4dd1,0x4de1,0x4df1,0x4e01
  .hword 0x4e11,0x0003,0x4e28,0x0008,0x4e38,0x4e48,0x4e58,0x4e68
  .hword 0x4e78,0x4e81,0x4e91,0x4ea1,0x4eb1,0x4ec1,0x0003,0x4ed8
  .hword 0x0008,0x4ee8,0x4ef8,0x4f08,0x4f18,0x4f28,0x4f31,0x4f41
  .hword 0x4f51,0x4f61,0x4f71,0x0003,0x4f88,0x4f97,0x4fa1,0x4fb8
  .hword 0x4fc7,0x4fd1,0x4fe7,0x4ff1,0x5008,0x5018,0x5021,0x5031
  .hword 0x0000,0x0016,0x5048,0x5058,0x5068,0x5078,0x5088,0x5091
  .hword 0x50a1,0x0000,0x0016,0x50b8,0x50c8,0x50d8,0x50e8,0x50f8
  .hword 0x5101,0x5111,0x0006,0x5128,0x0008,0x5138,0x5148,0x5158
  .hword 0x5168,0x5178,0x5181,0x5191,0x51a1,0x51b1,0x51c1,0x0003
  .hword 0x4ca8,0x0008,0x4cb8,0x4cc7,0x4cd1,0x4ce7,0x4cf1,0x4d08
  .hword 0x4d18,0x4d21,0x4d31,0x4d41,0x4d51,0x4d61,0x0003,0x4d78
  .hword 0x0008,0x4d88,0x4d98,0x4da8,0x4db8,0x4dc8,0x4dd1,0x4de1
  .hword 0x4df1,0x4e01,0x4e11,0x0003,0x4e28,0x0008,0x4e38,0x4e48
  .hword 0x4e58,0x4e68,0x4e78,0x4e81,0x4e91,0x4ea1,0x4eb1,0x4ec1
  .hword 0x0003,0x4ed8,0x0008,0x4ee8,0x4ef8,0x4f08,0x4f18,0x4f28
  .hword 0x4f31,0x4f41,0x4f51,0x4f61,0x4f71,0x0003,0x4f88,0x51d7
  .hword 0x51e1,0x4fb8,0x4fc7,0x4fd1,0x4fe7,0x4ff1,0x5008,0x5018
  .hword 0x5021,0x5031,0x0000,0x0016,0x5048,0x5058,0x5068,0x5078
  .hword 0x5088,0x5091,0x50a1,0x0000,0x0016,0x50b8,0x50c8,0x50d8
  .hword 0x50e8,0x50f8,0x5101,0x5111,0x0006,0x5128,0x0008,0x5138
  .hword 0x5148,0x5158,0x5168,0x5178,0x5181,0x5191,0x51a1,0x51b1
  .hword 0x51c1,0x0003,0x51f8,0x0008,0x5208,0x5217,0x5221,0x5237
  .hword 0x5241,0x5258,0x5268,0x5271,0x5281,0x5291,0x52a1,0x52b1
  .hword 0x0003,0x52cf,0x52d8,0x52e8,0x52f8,0x5308,0x5318,0x5321
  .hword 0x5331,0x5341,0x5351,0x5361,0x0003,0x537f,0x5388,0x5398
  .hword 0x53a8,0x53b8,0x53c8,0x53d1,0x53e1,0x53f1,0x5401,0x5411
  .hword 0x0003,0x542f,0x5438,0x5448,0x5458,0x5468,0x5478,0x5481
  .hword 0x5491,0x54a1,0x54b1,0x54c1,0x0003,0x54d8,0x54e7,0x54f1
  .hword 0x5508,0x5517,0x5521,0x5537,0x5541,0x5558,0x5568,0x5571
  .hword 0x5581,0x0006,0x5598,0x55a8,0x55b8,0x55c8,0x55d8,0x55e8
  .hword 0x55f8,0x5601,0x5611,0x0006,0x5628,0x5638,0x5648,0x5658
  .hword 0x5668,0x5678,0x5688,0x5691,0x56a1,0x0006,0x56bf,0x56c8
  .hword 0x56d8,0x56e8,0x56f8,0x5708,0x5711,0x5721,0x5731,0x5741
  .hword 0x5751,0x0003,0x51f8,0x0008,0x5208,0x5217,0x5221,0x5237
  .hword 0x5241,0x5258,0x5268,0x5271,0x5281,0x5291,0x52a1,0x52b1
  .hword 0x0003,0x52cf,0x52d8,0x52e8,0x52f8,0x5308,0x5318,0x5321
  .hword 0x5331,0x5341,0x5351,0x5361,0x0003,0x537f,0x5388,0x5398
  .hword 0x53a8,0x53b8,0x53c8,0x53d1,0x53e1,0x53f1,0x5401,0x5411
  .hword 0x0003,0x542f,0x5438,0x5448,0x5458,0x5468,0x5478,0x5481
  .hword 0x5491,0x54a1,0x54b1,0x54c1,0x0003,0x54d8,0x54e7,0x54f1
  .hword 0x5508,0x5517,0x5521,0x5537,0x5541,0x5558,0x5568,0x5571
  .hword 0x5581,0x0006,0x5598,0x55a8,0x55b8,0x55c8,0x55d8,0x55e8
  .hword 0x55f8,0x5601,0x5611,0x0006,0x5628,0x5638,0x5648,0x5658
  .hword 0x5668,0x5678,0x5688,0x5691,0x56a1,0x0006,0x56bf,0x56c8
  .hword 0x56d8,0x56e8,0x56f8,0x5708,0x5711,0x5721,0x5731,0x5741
  .hword 0x5751,0x0003,0x51f8,0x0008,0x5208,0x5217,0x5221,0x5237
  .hword 0x5241,0x5258,0x5268,0x5271,0x5281,0x5291,0x52a1,0x52b1
  .hword 0x0003,0x52cf,0x52d8,0x52e8,0x52f8,0x5308,0x5318,0x5321
  .hword 0x5331,0x5341,0x5351,0x5361,0x0003,0x537f,0x5388,0x5398
  .hword 0x53a8,0x53b8,0x53c8,0x53d1,0x53e1,0x53f1,0x5401,0x5411
  .hword 0x0003,0x542f,0x5438,0x5448,0x5458,0x5468,0x5478,0x5481
  .hword 0x5491,0x54a1,0x54b1,0x54c1,0x0003,0x54d8,0x54e7,0x54f1
  .hword 0x5508,0x5517,0x5521,0x5537,0x5541,0x5558,0x5568,0x5571
  .hword 0x5581,0x0006,0x5598,0x55a8,0x55b8,0x55c8,0x55d8,0x55e8
  .hword 0x55f8,0x5601,0x5611,0x0006,0x5628,0x5638,0x5648,0x5658
  .hword 0x5668,0x5678,0x5688,0x5691,0x56a1,0x0006,0x56bf,0x56c8
  .hword 0x56d8,0x56e8,0x56f8,0x5708,0x5711,0x5721,0x5731,0x5741
  .hword 0x5751,0x0003,0x51f8,0x0008,0x5208,0x5217,0x5221,0x5237
  .hword 0x5241,0x5258,0x5268,0x5271,0x5281,0x5291,0x52a1,0x52b1
  .hword 0x0003,0x52cf,0x52d8,0x52e8,0x52f8,0x5308,0x5318,0x5321
  .hword 0x5331,0x5341,0x5351,0x5361,0x0003,0x537f,0x5388,0x5398
  .hword 0x53a8,0x53b8,0x53c8,0x53d1,0x53e1,0x53f1,0x5401,0x5411
  .hword 0x0003,0x542f,0x5438,0x5448,0x5458,0x5468,0x5478,0x5481
  .hword 0x5491,0x54a1,0x54b1,0x54c1,0x0003,0x54d8,0x54e7,0x54f1
  .hword 0x5508,0x5517,0x5521,0x5537,0x5541,0x5558,0x5568,0x5571
  .hword 0x5581,0x0006,0x5598,0x55a8,0x55b8,0x55c8,0x55d8,0x55e8
  .hword 0x55f8,0x5601,0x5611,0x0006,0x5628,0x5638,0x5648,0x5658
  .hword 0x5668,0x5678,0x5688,0x5691,0x56a1,0x0006,0x56bf,0x56c8
  .hword 0x56d8,0x56e8,0x56f8,0x5708,0x5711,0x5721,0x5731,0x5741
  .hword 0x5751,0x0003,0x51f8,0x0008,0x5208,0x5217,0x5221,0x5237
  .hword 0x5241,0x5258,0x5268,0x5271,0x5281,0x5291,0x52a1,0x52b1
  .hword 0x0003,0x52cf,0x52d8,0x52e8,0x52f8,0x5308,0x5318,0x5321
  .hword 0x5331,0x5341,0x5351,0x5361,0x0003,0x537f,0x5388,0x5398
  .hword 0x53a8,0x53b8,0x53c8,0x53d1,0x53e1,0x53f1,0x5401,0x5411
  .hword 0x0003,0x542f,0x5438,0x5448,0x5458,0x5468,0x5478,0x5481
  .hword 0x5491,0x54a1,0x54b1,0x54c1,0x0003,0x54d8,0x54e7,0x54f1
  .hword 0x5508,0x5517,0x5521,0x5537,0x5541,0x5558,0x5568,0x5571
  .hword 0x5581,0x0006,0x5598,0x55a8,0x55b8,0x55c8,0x55d8,0x55e8
  .hword 0x55f8,0x5601,0x5611,0x0006,0x5628,0x5638,0x5648,0x5658
  .hword 0x5668,0x5678,0x5688,0x5691,0x56a1,0x0006,0x56bf,0x56c8
  .hword 0x56d8,0x56e8,0x56f8,0x5708,0x5711,0x5721,0x5731,0x5741
  .hword 0x5751,0x0003,0x51f8,0x0008,0x5208,0x5217,0x5221,0x5237
  .hword 0x5241,0x5258,0x5268,0x5271,0x5281,0x5291,0x52a1,0x52b1
  .hword 0x0003,0x52cf,0x52d8,0x52e8,0x52f8,0x5308,0x5318,0x5321
  .hword 0x5331,0x5341,0x5351,0x5361,0x0003,0x537f,0x5388,0x5398
  .hword 0x53a8,0x53b8,0x53c8,0x53d1,0x53e1,0x53f1,0x5401,0x5411
  .hword 0x0003,0x542f,0x5438,0x5448,0x5458,0x5468,0x5478,0x5481
  .hword 0x5491,0x54a1,0x54b1,0x54c1,0x0003,0x54d8,0x54e7,0x54f1
  .hword 0x5508,0x5517,0x5521,0x5537,0x5541,0x5558,0x5568,0x5571
  .hword 0x5581,0x0006,0x5598,0x55a8,0x55b8,0x55c8,0x55d8,0x55e8
  .hword 0x55f8,0x5601,0x5611,0x0006,0x5628,0x5638,0x5648,0x5658
  .hword 0x5668,0x5678,0x5688,0x5691,0x56a1,0x0006,0x56bf,0x56c8
  .hword 0x56d8,0x56e8,0x56f8,0x5708,0x5711,0x5721,0x5731,0x5741
  .hword 0x5751,0x0003,0x51f8,0x0008,0x5208,0x5217,0x5221,0x5237
  .hword 0x5241,0x5258,0x5268,0x5271,0x5281,0x5291,0x52a1,0x52b1
  .hword 0x0003,0x52cf,0x52d8,0x52e8,0x52f8,0x5308,0x5318,0x5321
  .hword 0x5331,0x5341,0x5351,0x5361,0x0003,0x537f,0x5388,0x5398
  .hword 0x53a8,0x53b8,0x53c8,0x53d1,0x53e1,0x53f1,0x5401,0x5411
  .hword 0x0003,0x542f,0x5438,0x5448,0x5458,0x5468,0x5478,0x5481
  .hword 0x5491,0x54a1,0x54b1,0x54c1,0x0003,0x54d8,0x54e7,0x54f1
  .hword 0x5508,0x5517,0x5521,0x5537,0x5541,0x5558,0x5568,0x5571
  .hword 0x5581,0x0006,0x5598,0x55a8,0x55b8,0x55c8,0x55d8,0x55e8
  .hword 0x55f8,0x5601,0x5611,0x0006,0x5628,0x5638,0x5648,0x5658
  .hword 0x5668,0x5678,0x5688,0x5691,0x56a1,0x0006,0x56bf,0x56c8
  .hword 0x56d8,0x56e8,0x56f8,0x5708,0x5711,0x5721,0x5731,0x5741
  .hword 0x5751,0x0003,0x51f8,0x0008,0x5208,0x5217,0x5221,0x5237
  .hword 0x5241,0x5258,0x5268,0x5271,0x5281,0x5291,0x52a1,0x52b1
  .hword 0x0003,0x52cf,0x52d8,0x52e8,0x52f8,0x5308,0x5318,0x5321
  .hword 0x5331,0x5341,0x5351,0x5361,0x0003,0x537f,0x5388,0x5398
  .hword 0x53a8,0x53b8,0x53c8,0x53d1,0x53e1,0x53f1,0x5401,0x5411
  .hword 0x0003,0x542f,0x5438,0x5448,0x5458,0x5468,0x5478,0x5481
  .hword 0x5491,0x54a1,0x54b1,0x54c1,0x0003,0x54d8,0x5767,0x5771
  .hword 0x5508,0x5517,0x5521,0x5537,0x5541,0x5558,0x5568,0x5571
  .hword 0x5581,0x0006,0x5598,0x55a8,0x55b8,0x55c8,0x55d8,0x55e8
  .hword 0x55f8,0x5601,0x5611,0x0006,0x5628,0x5638,0x5648,0x5658
  .hword 0x5668,0x5678,0x5688,0x5691,0x56a1,0x0006,0x56bf,0x56c8
  .hword 0x56d8,0x56e8,0x56f8,0x5708,0x5711,0x5721,0x5731,0x5741
  .hword 0x5751,0x0003,0x7080,0x1000,0x5788,0x0008,0x5798,0x57a7
  .hword 0x57b1,0x57c7,0x57d1,0x57e8,0x57f8,0x5801,0x5811,0x5821
  .hword 0x5831,0x5841,0x0003,0x585f,0x5868,0x5878,0x5888,0x5898
  .hword 0x58a8,0x58b1,0x58c1,0x58d1,0x58e1,0x58f1,0x0003,0x590f
  .hword 0x5918,0x5928,0x5938,0x5948,0x5958,0x5961,0x5971,0x5981
  .hword 0x5991,0x59a1,0x0003,0x59bf,0x59c8,0x59d8,0x59e8,0x59f8
  .hword 0x5a08,0x5a11,0x5a21,0x5a31,0x5a41,0x5a51,0x0003,0x5a68
  .hword 0x5a77,0x5a81,0x5a98,0x5aa7,0x5ab1,0x5ac7,0x5ad1,0x5ae8
  .hword 0x5af8,0x5b01,0x5b11,0x0006,0x5b28,0x5b38,0x5b48,0x5b58
  .hword 0x5b68,0x5b78,0x5b88,0x5b91,0x5ba1,0x0006,0x5bb8,0x5bc8
  .hword 0x5bd8,0x5be8,0x5bf8,0x5c08,0x5c18,0x5c21,0x5c31,0x0006
  .hword 0x5c4f,0x5c58,0x5c68,0x5c78,0x5c88,0x5c98,0x5ca1,0x5cb1
  .hword 0x5cc1,0x5cd1,0x5ce1,0x0003,0x5788,0x0008,0x5798,0x57a7
  .hword 0x57b1,0x57c7,0x57d1,0x57e8,0x57f8,0x5801,0x5811,0x5821
  .hword 0x5831,0x5841,0x0003,0x585f,0x5868,0x5878,0x5888,0x5898
  .hword 0x58a8,0x58b1,0x58c1,0x58d1,0x58e1,0x58f1,0x0003,0x590f
  .hword 0x5918,0x5928,0x5938,0x5948,0x5958,0x5961,0x5971,0x5981
  .hword 0x5991,0x59a1,0x0003,0x59bf,0x59c8,0x59d8,0x59e8,0x59f8
  .hword 0x5a08,0x5a11,0x5a21,0x5a31,0x5a41,0x5a51,0x0003,0x5a68
  .hword 0x5a77,0x5a81,0x5a98,0x5aa7,0x5ab1,0x5ac7,0x5ad1,0x5ae8
  .hword 0x5af8,0x5b01,0x5b11,0x0006,0x5b28,0x5b38,0x5b48,0x5b58
  .hword 0x5b68,0x5b78,0x5b88,0x5b91,0x5ba1,0x0006,0x5bb8,0x5bc8
  .hword 0x5bd8,0x5be8,0x5bf8,0x5c08,0x5c18,0x5c21,0x5c31,0x0006
  .hword 0x5c4f,0x5c58,0x5c68,0x5c78,0x5c88,0x5c98,0x5ca1,0x5cb1
  .hword 0x5cc1,0x5cd1,0x5ce1,0x0003,0x5788,0x0008,0x5798,0x57a7
  .hword 0x57b1,0x57c7,0x57d1,0x57e8,0x57f8,0x5801,0x5811,0x5821
  .hword 0x5831,0x5841,0x0003,0x585f,0x5868,0x5878,0x5888,0x5898
  .hword 0x58a8,0x58b1,0x58c1,0x58d1,0x58e1,0x58f1,0x0003,0x590f
  .hword 0x5918,0x5928,0x5938,0x5948,0x5958,0x5961,0x5971,0x5981
  .hword 0x5991,0x59a1,0x0003,0x59bf,0x59c8,0x59d8,0x59e8,0x59f8
  .hword 0x5a08,0x5a11,0x5a21,0x5a31,0x5a41,0x5a51,0x0003,0x5a68
  .hword 0x5a77,0x5a81,0x5a98,0x5aa7,0x5ab1,0x5ac7,0x5ad1,0x5ae8
  .hword 0x5af8,0x5b01,0x5b11,0x0006,0x5b28,0x5b38,0x5b48,0x5b58
  .hword 0x5b68,0x5b78,0x5b88,0x5b91,0x5ba1,0x0006,0x5bb8,0x5bc8
  .hword 0x5bd8,0x5be8,0x5bf8,0x5c08,0x5c18,0x5c21,0x5c31,0x0006
  .hword 0x5c4f,0x5c58,0x5c68,0x5c78,0x5c88,0x5c98,0x5ca1,0x5cb1
  .hword 0x5cc1,0x5cd1,0x5ce1,0x0003,0x5788,0x0008,0x5798,0x57a7
  .hword 0x57b1,0x57c7,0x57d1,0x57e8,0x57f8,0x5801,0x5811,0x5821
  .hword 0x5831,0x5841,0x0003,0x585f,0x5868,0x5878,0x5888,0x5898
  .hword 0x58a8,0x58b1,0x58c1,0x58d1,0x58e1,0x58f1,0x0003,0x590f
  .hword 0x5918,0x5928,0x5938,0x5948,0x5958,0x5961,0x5971,0x5981
  .hword 0x5991,0x59a1,0x0003,0x59bf,0x59c8,0x59d8,0x59e8,0x59f8
  .hword 0x5a08,0x5a11,0x5a21,0x5a31,0x5a41,0x5a51,0x0003,0x5a68
  .hword 0x5a77,0x5a81,0x5a98,0x5aa7,0x5ab1,0x5ac7,0x5ad1,0x5ae8
  .hword 0x5af8,0x5b01,0x5b11,0x0006,0x5b28,0x5b38,0x5b48,0x5b58
  .hword 0x5b68,0x5b78,0x5b88,0x5b91,0x5ba1,0x0006,0x5bb8,0x5bc8
  .hword 0x5bd8,0x5be8,0x5bf8,0x5c08,0x5c18,0x5c21,0x5c31,0x0006
  .hword 0x5c4f,0x5c58,0x5c68,0x5c78,0x5c88,0x5c98,0x5ca1,0x5cb1
  .hword 0x5cc1,0x5cd1,0x5ce1,0x0003,0x5788,0x0008,0x5798,0x57a7
  .hword 0x57b1,0x57c7,0x57d1,0x57e8,0x57f8,0x5801,0x5811,0x5821
  .hword 0x5831,0x5841,0x0003,0x585f,0x5868,0x5878,0x5888,0x5898
  .hword 0x58a8,0x58b1,0x58c1,0x58d1,0x58e1,0x58f1,0x0003,0x590f
  .hword 0x5918,0x5928,0x5938,0x5948,0x5958,0x5961,0x5971,0x5981
  .hword 0x5991,0x59a1,0x0003,0x59bf,0x59c8,0x59d8,0x59e8,0x59f8
  .hword 0x5a08,0x5a11,0x5a21,0x5a31,0x5a41,0x5a51,0x0003,0x5a68
  .hword 0x5a77,0x5a81,0x5a98,0x5aa7,0x5ab1,0x5ac7,0x5ad1,0x5ae8
  .hword 0x5af8,0x5b01,0x5b11,0x0006,0x5b28,0x5b38,0x5b48,0x5b58
  .hword 0x5b68,0x5b78,0x5b88,0x5b91,0x5ba1,0x0006,0x5bb8,0x5bc8
  .hword 0x5bd8,0x5be8,0x5bf8,0x5c08,0x5c18,0x5c21,0x5c31,0x0006
  .hword 0x5c4f,0x5c58,0x5c68,0x5c78,0x5c88,0x5c98,0x5ca1,0x5cb1
  .hword 0x5cc1,0x5cd1,0x5ce1,0x0003,0x5788,0x0008,0x5798,0x57a7
  .hword 0x57b1,0x57c7,0x57d1,0x57e8,0x57f8,0x5801,0x5811,0x5821
  .hword 0x5831,0x5841,0x0003,0x585f,0x5868,0x5878,0x5888,0x5898
  .hword 0x58a8,0x58b1,0x58c1,0x58d1,0x58e1,0x58f1,0x0003,0x590f
  .hword 0x5918,0x5928,0x5938,0x5948,0x5958,0x5961,0x5971,0x5981
  .hword 0x5991,0x59a1,0x0003,0x59bf,0x59c8,0x59d8,0x59e8,0x59f8
  .hword 0x5a08,0x5a11,0x5a21,0x5a31,0x5a41,0x5a51,0x0003,0x5a68
  .hword 0x5a77,0x5a81,0x5a98,0x5aa7,0x5ab1,0x5ac7,0x5ad1,0x5ae8
  .hword 0x5af8,0x5b01,0x5b11,0x0006,0x5b28,0x5b38,0x5b48,0x5b58
  .hword 0x5b68,0x5b78,0x5b88,0x5b91,0x5ba1,0x0006,0x5bb8,0x5bc8
  .hword 0x5bd8,0x5be8,0x5bf8,0x5c08,0x5c18,0x5c21,0x5c31,0x0006
  .hword 0x5c4f,0x5c58,0x5c68,0x5c78,0x5c88,0x5c98,0x5ca1,0x5cb1
  .hword 0x5cc1,0x5cd1,0x5ce1,0x0003,0x5788,0x0008,0x5798,0x57a7
  .hword 0x57b1,0x57c7,0x57d1,0x57e8,0x57f8,0x5801,0x5811,0x5821
  .hword 0x5831,0x5841,0x0003,0x585f,0x5868,0x5878,0x5888,0x5898
  .hword 0x58a8,0x58b1,0x58c1,0x58d1,0x58e1,0x58f1,0x0003,0x590f
  .hword 0x5918,0x5928,0x5938,0x5948,0x5958,0x5961,0x5971,0x5981
  .hword 0x5991,0x59a1,0x0003,0x59bf,0x59c8,0x59d8,0x59e8,0x59f8
  .hword 0x5a08,0x5a11,0x5a21,0x5a31,0x5a41,0x5a51,0x0003,0x5a68
  .hword 0x5a77,0x5a81,0x5a98,0x5aa7,0x5ab1,0x5ac7,0x5ad1,0x5ae8
  .hword 0x5af8,0x5b01,0x5b11,0x0006,0x5b28,0x5b38,0x5b48,0x5b58
  .hword 0x5b68,0x5b78,0x5b88,0x5b91,0x5ba1,0x0006,0x5bb8,0x5bc8
  .hword 0x5bd8,0x5be8,0x5bf8,0x5c08,0x5c18,0x5c21,0x5c31,0x0006
  .hword 0x5c4f,0x5c58,0x5c68,0x5c78,0x5c88,0x5c98,0x5ca1,0x5cb1
  .hword 0x5cc1,0x5cd1,0x5ce1,0x0003,0x5788,0x0008,0x5798,0x57a7
  .hword 0x57b1,0x57c7,0x57d1,0x57e8,0x57f8,0x5801,0x5811,0x5821
  .hword 0x5831,0x5841,0x0003,0x585f,0x5868,0x5878,0x5888,0x5898
  .hword 0x58a8,0x58b1,0x58c1,0x58d1,0x58e1,0x58f1,0x0003,0x590f
  .hword 0x5918,0x5928,0x5938,0x5948,0x5958,0x5961,0x5971,0x5981
  .hword 0x5991,0x59a1,0x0003,0x59bf,0x59c8,0x59d8,0x59e8,0x59f8
  .hword 0x5a08,0x5a11,0x5a21,0x5a31,0x5a41,0x5a51,0x0003,0x5a68
  .hword 0x5cf7,0x5d01,0x5a98,0x5aa7,0x5ab1,0x5ac7,0x5ad1,0x5ae8
  .hword 0x5af8,0x5b01,0x5b11,0x0006,0x5b28,0x5b38,0x5b48,0x5b58
  .hword 0x5b68,0x5b78,0x5b88,0x5b91,0x5ba1,0x0006,0x5bb8,0x5bc8
  .hword 0x5bd8,0x5be8,0x5bf8,0x5c08,0x5c18,0x5c21,0x5c31,0x0006
  .hword 0x5c4f,0x5c58,0x5c68,0x5c78,0x5c88,0x5c98,0x5ca1,0x5cb1
  .hword 0x5cc1,0x5cd1,0x5ce1,0x0003,0x5d18,0x0008,0x5d28,0x5d37
  .hword 0x5d41,0x5d57,0x5d61,0x5d78,0x5d88,0x5d91,0x5da1,0x5db1
  .hword 0x5dc1,0x5dd1,0x0003,0x5de8,0x0008,0x5df8,0x5e08,0x5e18
  .hword 0x5e28,0x5e38,0x5e41,0x5e51,0x5e61,0x5e71,0x5e81,0x0003
  .hword 0x5e98,0x0008,0x5ea8,0x5eb8,0x5ec8,0x5ed8,0x5ee8,0x5ef1
  .hword 0x5f01,0x5f11,0x5f21,0x5f31,0x0003,0x5f48,0x0008,0x5f58
  .hword 0x5f68,0x5f78,0x5f88,0x5f98,0x5fa1,0x5fb1,0x5fc1,0x5fd1
  .hword 0x5fe1,0x0003,0x5ff8,0x6007,0x6011,0x6028,0x6037,0x6041
  .hword 0x6057,0x6061,0x6078,0x6088,0x6091,0x60a1,0x0006,0x60b8
  .hword 0x60c8,0x60d8,0x60e8,0x60f8,0x6108,0x6118,0x6121,0x6131
  .hword 0x000e,0x6148,0x6158,0x6168,0x6178,0x6188,0x6198,0x61a1
  .hword 0x61b1,0x0006,0x61c8,0x0008,0x61d8,0x61e8,0x61f8,0x6208
  .hword 0x6218,0x6221,0x6231,0x6241,0x6251,0x6261,0x0003,0x5d18
  .hword 0x0008,0x5d28,0x5d37,0x5d41,0x5d57,0x5d61,0x5d78,0x5d88
  .hword 0x5d91,0x5da1,0x5db1,0x5dc1,0x5dd1,0x0003,0x5de8,0x0008
  .hword 0x5df8,0x5e08,0x5e18,0x5e28,0x5e38,0x5e41,0x5e51,0x5e61
  .hword 0x5e71,0x5e81,0x0003,0x5e98,0x0008,0x5ea8,0x5eb8,0x5ec8
  .hword 0x5ed8,0x5ee8,0x5ef1,0x5f01,0x5f11,0x5f21,0x5f31,0x0003
  .hword 0x5f48,0x0008,0x5f58,0x5f68,0x5f78,0x5f88,0x5f98,0x5fa1
  .hword 0x5fb1,0x5fc1,0x5fd1,0x5fe1,0x0003,0x5ff8,0x6007,0x6011
  .hword 0x6028,0x6037,0x6041,0x6057,0x6061,0x6078,0x6088,0x6091
  .hword 0x60a1,0x0006,0x60b8,0x60c8,0x60d8,0x60e8,0x60f8,0x6108
  .hword 0x6118,0x6121,0x6131,0x000e,0x6148,0x6158,0x6168,0x6178
  .hword 0x6188,0x6198,0x61a1,0x61b1,0x0006,0x61c8,0x0008,0x61d8
  .hword 0x61e8,0x61f8,0x6208,0x6218,0x6221,0x6231,0x6241,0x6251
  .hword 0x6261,0x0003,0x5d18,0x0008,0x5d28,0x5d37,0x5d41,0x5d57
  .hword 0x5d61,0x5d78,0x5d88,0x5d91,0x5da1,0x5db1,0x5dc1,0x5dd1
  .hword 0x0003,0x5de8,0x0008,0x5df8,0x5e08,0x5e18,0x5e28,0x5e38
  .hword 0x5e41,0x5e51,0x5e61,0x5e71,0x5e81,0x0003,0x5e98,0x0008
  .hword 0x5ea8,0x5eb8,0x5ec8,0x5ed8,0x5ee8,0x5ef1,0x5f01,0x5f11
  .hword 0x5f21,0x5f31,0x0003,0x5f48,0x0008,0x5f58,0x5f68,0x5f78
  .hword 0x5f88,0x5f98,0x5fa1,0x5fb1,0x5fc1,0x5fd1,0x5fe1,0x0003
  .hword 0x5ff8,0x6007,0x6011,0x6028,0x6037,0x6041,0x6057,0x6061
  .hword 0x6078,0x6088,0x6091,0x60a1,0x0006,0x60b8,0x60c8,0x60d8
  .hword 0x60e8,0x60f8,0x6108,0x6118,0x6121,0x6131,0x000e,0x6148
  .hword 0x6158,0x6168,0x6178,0x6188,0x6198,0x61a1,0x61b1,0x0006
  .hword 0x61c8,0x0008,0x61d8,0x61e8,0x61f8,0x6208,0x6218,0x6221
  .hword 0x6231,0x6241,0x6251,0x6261,0x0003,0x5d18,0x0008,0x5d28
  .hword 0x5d37,0x5d41,0x5d57,0x5d61,0x5d78,0x5d88,0x5d91,0x5da1
  .hword 0x5db1,0x5dc1,0x5dd1,0x0003,0x5de8,0x0008,0x5df8,0x5e08
  .hword 0x5e18,0x5e28,0x5e38,0x5e41,0x5e51,0x5e61,0x5e71,0x5e81
  .hword 0x0003,0x5e98,0x0008,0x5ea8,0x5eb8,0x5ec8,0x5ed8,0x5ee8
  .hword 0x5ef1,0x5f01,0x5f11,0x5f21,0x5f31,0x0003,0x5f48,0x0008
  .hword 0x5f58,0x5f68,0x5f78,0x5f88,0x5f98,0x5fa1,0x5fb1,0x5fc1
  .hword 0x5fd1,0x5fe1,0x0003,0x5ff8,0x6007,0x6011,0x6028,0x6037
  .hword 0x6041,0x6057,0x6061,0x6078,0x6088,0x6091,0x60a1,0x0006
  .hword 0x60b8,0x60c8,0x60d8,0x60e8,0x60f8,0x6108,0x6118,0x6121
  .hword 0x6131,0x000e,0x6148,0x6158,0x6168,0x6178,0x6188,0x6198
  .hword 0x61a1,0x61b1,0x0006,0x61c8,0x0008,0x61d8,0x61e8,0x61f8
  .hword 0x6208,0x6218,0x6221,0x6231,0x6241,0x6251,0x6261,0x0003
  .hword 0x5d18,0x0008,0x5d28,0x5d37,0x5d41,0x5d57,0x5d61,0x5d78
  .hword 0x5d88,0x5d91,0x5da1,0x5db1,0x5dc1,0x5dd1,0x0003,0x5de8
  .hword 0x0008,0x5df8,0x5e08,0x5e18,0x5e28,0x5e38,0x5e41,0x5e51
  .hword 0x5e61,0x5e71,0x5e81,0x0003,0x5e98,0x0008,0x5ea8,0x5eb8
  .hword 0x5ec8,0x5ed8,0x5ee8,0x5ef1,0x5f01,0x5f11,0x5f21,0x5f31
  .hword 0x0003,0x5f48,0x0008,0x5f58,0x5f68,0x5f78,0x5f88,0x5f98
  .hword 0x5fa1,0x5fb1,0x5fc1,0x5fd1,0x5fe1,0x0003,0x5ff8,0x6007
  .hword 0x6011,0x6028,0x6037,0x6041,0x6057,0x6061,0x6078,0x6088
  .hword 0x6091,0x60a1,0x0006,0x60b8,0x60c8,0x60d8,0x60e8,0x60f8
  .hword 0x6108,0x6118,0x6121,0x6131,0x000e,0x6148,0x6158,0x6168
  .hword 0x6178,0x6188,0x6198,0x61a1,0x61b1,0x0006,0x61c8,0x0008
  .hword 0x61d8,0x61e8,0x61f8,0x6208,0x6218,0x6221,0x6231,0x6241
  .hword 0x6251,0x6261,0x0003,0x5d18,0x0008,0x5d28,0x5d37,0x5d41
  .hword 0x5d57,0x5d61,0x5d78,0x5d88,0x5d91,0x5da1,0x5db1,0x5dc1
  .hword 0x5dd1,0x0003,0x5de8,0x0008,0x5df8,0x5e08,0x5e18,0x5e28
  .hword 0x5e38,0x5e41,0x5e51,0x5e61,0x5e71,0x5e81,0x0003,0x5e98
  .hword 0x0008,0x5ea8,0x5eb8,0x5ec8,0x5ed8,0x5ee8,0x5ef1,0x5f01
  .hword 0x5f11,0x5f21,0x5f31,0x0003,0x5f48,0x0008,0x5f58,0x5f68
  .hword 0x5f78,0x5f88,0x5f98,0x5fa1,0x5fb1,0x5fc1,0x5fd1,0x5fe1
  .hword 0x0003,0x5ff8,0x6007,0x6011,0x6028,0x6037,0x6041,0x6057
  .hword 0x6061,0x6078,0x6088,0x6091,0x60a1,0x0006,0x60b8,0x60c8
  .hword 0x60d8,0x60e8,0x60f8,0x6108,0x6118,0x6121,0x6131,0x000e
  .hword 0x6148,0x6158,0x6168,0x6178,0x6188,0x6198,0x61a1,0x61b1
  .hword 0x0006,0x61c8,0x0008,0x61d8,0x61e8,0x61f8,0x6208,0x6218
  .hword 0x6221,0x6231,0x6241,0x6251,0x6261,0x0003,0x5d18,0x0008
  .hword 0x5d28,0x5d37,0x5d41,0x5d57,0x5d61,0x5d78,0x5d88,0x5d91
  .hword 0x5da1,0x5db1,0x5dc1,0x5dd1,0x0003,0x5de8,0x0008,0x5df8
  .hword 0x5e08,0x5e18,0x5e28,0x5e38,0x5e41,0x5e51,0x5e61,0x5e71
  .hword 0x5e81,0x0003,0x5e98,0x0008,0x5ea8,0x5eb8,0x5ec8,0x5ed8
  .hword 0x5ee8,0x5ef1,0x5f01,0x5f11,0x5f21,0x5f31,0x0003,0x5f48
  .hword 0x0008,0x5f58,0x5f68,0x5f78,0x5f88,0x5f98,0x5fa1,0x5fb1
  .hword 0x5fc1,0x5fd1,0x5fe1,0x0003,0x5ff8,0x6007,0x6011,0x6028
  .hword 0x6037,0x6041,0x6057,0x6061,0x6078,0x6088,0x6091,0x60a1
  .hword 0x0006,0x60b8,0x60c8,0x60d8,0x60e8,0x60f8,0x6108,0x6118
  .hword 0x6121,0x6131,0x000e,0x6148,0x6158,0x6168,0x6178,0x6188
  .hword 0x6198,0x61a1,0x61b1,0x0006,0x61c8,0x0008,0x61d8,0x61e8
  .hword 0x61f8,0x6208,0x6218,0x6221,0x6231,0x6241,0x6251,0x6261
  .hword 0x0003,0x5d18,0x0008,0x5d28,0x5d37,0x5d41,0x5d57,0x5d61
  .hword 0x5d78,0x5d88,0x5d91,0x5da1,0x5db1,0x5dc1,0x5dd1,0x0003
  .hword 0x5de8,0x0008,0x5df8,0x5e08,0x5e18,0x5e28,0x5e38,0x5e41
  .hword 0x5e51,0x5e61,0x5e71,0x5e81,0x0003,0x5e98,0x0008,0x5ea8
  .hword 0x5eb8,0x5ec8,0x5ed8,0x5ee8,0x5ef1,0x5f01,0x5f11,0x5f21
  .hword 0x5f31,0x0003,0x5f48,0x0008,0x5f58,0x5f68,0x5f78,0x5f88
  .hword 0x5f98,0x5fa1,0x5fb1,0x5fc1,0x5fd1,0x5fe1,0x0003,0x5ff8
  .hword 0x6277,0x6281,0x6028,0x6037,0x6041,0x6057,0x6061,0x6078
  .hword 0x6088,0x6091,0x60a1,0x0006,0x60b8,0x60c8,0x60d8,0x60e8
  .hword 0x60f8,0x6108,0x6118,0x6121,0x6131,0x000e,0x6148,0x6158
  .hword 0x6168,0x6178,0x6188,0x6198,0x61a1,0x61b1,0x0006,0x61c8
  .hword 0x0008,0x61d8,0x61e8,0x61f8,0x6208,0x6218,0x6221,0x6231
  .hword 0x6241,0x6251,0x6261,0x0003,0x6298,0x0008,0x62a8,0x62b7
  .hword 0x62c1,0x62d7,0x62e1,0x62f8,0x6308,0x6311,0x6321,0x6331
  .hword 0x6341,0x6351,0x0003,0x636f,0x6378,0x6388,0x6398,0x63a8
  .hword 0x63b8,0x63c1,0x63d1,0x63e1,0x63f1,0x6401,0x0003,0x641f
  .hword 0x6428,0x6438,0x6448,0x6458,0x6468,0x6471,0x6481,0x6491
  .hword 0x64a1,0x64b1,0x0003,0x64cf,0x64d8,0x64e8,0x64f8,0x6508
  .hword 0x6518,0x6521,0x6531,0x6541,0x6551,0x6561,0x0003,0x6578
  .hword 0x6587,0x6591,0x65a8,0x65b7,0x65c1,0x65d7,0x65e1,0x65f8
  .hword 0x6608,0x6611,0x6621,0x0006,0x6638,0x6648,0x6658,0x6668
  .hword 0x6678,0x6688,0x6698,0x66a1,0x66b1,0x0006,0x66c8,0x66d8
  .hword 0x66e8,0x66f8,0x6708,0x6718,0x6728,0x6731,0x6741,0x0006
  .hword 0x675f,0x6768,0x6778,0x6788,0x6798,0x67a8,0x67b1,0x67c1
  .hword 0x67d1,0x67e1,0x67f1,0x0003,0x6298,0x0008,0x62a8,0x62b7
  .hword 0x62c1,0x62d7,0x62e1,0x62f8,0x6308,0x6311,0x6321,0x6331
  .hword 0x6341,0x6351,0x0003,0x636f,0x6378,0x6388,0x6398,0x63a8
  .hword 0x63b8,0x63c1,0x63d1,0x63e1,0x63f1,0x6401,0x0003,0x641f
  .hword 0x6428,0x6438,0x6448,0x6458,0x6468,0x6471,0x6481,0x6491
  .hword 0x64a1,0x64b1,0x0003,0x64cf,0x64d8,0x64e8,0x64f8,0x6508
  .hword 0x6518,0x6521,0x6531,0x6541,0x6551,0x6561,0x0003,0x6578
  .hword 0x6587,0x6591,0x65a8,0x65b7,0x65c1,0x65d7,0x65e1,0x65f8
  .hword 0x6608,0x6611,0x6621,0x0006,0x6638,0x6648,0x6658,0x6668
  .hword 0x6678,0x6688,0x6698,0x66a1,0x66b1,0x0006,0x66c8,0x66d8
  .hword 0x66e8,0x66f8,0x6708,0x6718,0x6728,0x6731,0x6741,0x0006
  .hword 0x675f,0x6768,0x6778,0x6788,0x6798,0x67a8,0x67b1,0x67c1
  .hword 0x67d1,0x67e1,0x67f1,0x0003,0x6298,0x0008,0x62a8,0x62b7
  .hword 0x62c1,0x62d7,0x62e1,0x62f8,0x6308,0x6311,0x6321,0x6331
  .hword 0x6341,0x6351,0x0003,0x636f,0x6378,0x6388,0x6398,0x63a8
  .hword 0x63b8,0x63c1,0x63d1,0x63e1,0x63f1,0x6401,0x0003,0x641f
  .hword 0x6428,0x6438,0x6448,0x6458,0x6468,0x6471,0x6481,0x6491
  .hword 0x64a1,0x64b1,0x0003,0x64cf,0x64d8,0x64e8,0x64f8,0x6508
  .hword 0x6518,0x6521,0x6531,0x6541,0x6551,0x6561,0x0003,0x6578
  .hword 0x6587,0x6591,0x65a8,0x65b7,0x65c1,0x65d7,0x65e1,0x65f8
  .hword 0x6608,0x6611,0x6621,0x0006,0x6638,0x6648,0x6658,0x6668
  .hword 0x6678,0x6688,0x6698,0x66a1,0x66b1,0x0006,0x66c8,0x66d8
  .hword 0x66e8,0x66f8,0x6708,0x6718,0x6728,0x6731,0x6741,0x0006
  .hword 0x675f,0x6768,0x6778,0x6788,0x6798,0x67a8,0x67b1,0x67c1
  .hword 0x67d1,0x67e1,0x67f1,0x0003,0x6298,0x0008,0x62a8,0x62b7
  .hword 0x62c1,0x62d7,0x62e1,0x62f8,0x6308,0x6311,0x6321,0x6331
  .hword 0x6341,0x6351,0x0003,0x636f,0x6378,0x6388,0x6398,0x63a8
  .hword 0x63b8,0x63c1,0x63d1,0x63e1,0x63f1,0x6401,0x0003,0x641f
  .hword 0x6428,0x6438,0x6448,0x6458,0x6468,0x6471,0x6481,0x6491
  .hword 0x64a1,0x64b1,0x0003,0x64cf,0x64d8,0x64e8,0x64f8,0x6508
  .hword 0x6518,0x6521,0x6531,0x6541,0x6551,0x6561,0x0003,0x6578
  .hword 0x6587,0x6591,0x65a8,0x65b7,0x65c1,0x65d7,0x65e1,0x65f8
  .hword 0x6608,0x6611,0x6621,0x0006,0x6638,0x6648,0x6658,0x6668
  .hword 0x6678,0x6688,0x6698,0x66a1,0x66b1,0x0006,0x66c8,0x66d8
  .hword 0x66e8,0x66f8,0x6708,0x6718,0x6728,0x6731,0x6741,0x0006
  .hword 0x675f,0x6768,0x6778,0x6788,0x6798,0x67a8,0x67b1,0x67c1
  .hword 0x67d1,0x67e1,0x67f1,0x0003,0x6298,0x0008,0x62a8,0x62b7
  .hword 0x62c1,0x62d7,0x62e1,0x62f8,0x6308,0x6311,0x6321,0x6331
  .hword 0x6341,0x6351,0x0003,0x636f,0x6378,0x6388,0x6398,0x63a8
  .hword 0x63b8,0x63c1,0x63d1,0x63e1,0x63f1,0x6401,0x0003,0x641f
  .hword 0x6428,0x6438,0x6448,0x6458,0x6468,0x6471,0x6481,0x6491
  .hword 0x64a1,0x64b1,0x0003,0x64cf,0x64d8,0x64e8,0x64f8,0x6508
  .hword 0x6518,0x6521,0x6531,0x6541,0x6551,0x6561,0x0003,0x6578
  .hword 0x6587,0x6591,0x65a8,0x65b7,0x65c1,0x65d7,0x65e1,0x65f8
  .hword 0x6608,0x6611,0x6621,0x0006,0x6638,0x6648,0x6658,0x6668
  .hword 0x6678,0x6688,0x6698,0x66a1,0x66b1,0x0006,0x66c8,0x66d8
  .hword 0x66e8,0x66f8,0x6708,0x6718,0x6728,0x6731,0x6741,0x0006
  .hword 0x675f,0x6768,0x6778,0x6788,0x6798,0x67a8,0x67b1,0x67c1
  .hword 0x67d1,0x67e1,0x67f1,0x0003,0x6298,0x0008,0x62a8,0x62b7
  .hword 0x62c1,0x62d7,0x62e1,0x62f8,0x6308,0x6311,0x6321,0x6331
  .hword 0x6341,0x6351,0x0003,0x636f,0x6378,0x6388,0x6398,0x63a8
  .hword 0x63b8,0x63c1,0x63d1,0x63e1,0x63f1,0x6401,0x0003,0x641f
  .hword 0x6428,0x6438,0x6448,0x6458,0x6468,0x6471,0x6481,0x6491
  .hword 0x64a1,0x64b1,0x0003,0x64cf,0x64d8,0x64e8,0x64f8,0x6508
  .hword 0x6518,0x6521,0x6531,0x6541,0x6551,0x6561,0x0003,0x6578
  .hword 0x6587,0x6591,0x65a8,0x65b7,0x65c1,0x65d7,0x65e1,0x65f8
  .hword 0x6608,0x6611,0x6621,0x0006,0x6638,0x6648,0x6658,0x6668
  .hword 0x6678,0x6688,0x6698,0x66a1,0x66b1,0x0006,0x66c8,0x66d8
  .hword 0x66e8,0x66f8,0x6708,0x6718,0x6728,0x6731,0x6741,0x0006
  .hword 0x675f,0x6768,0x6778,0x6788,0x6798,0x67a8,0x67b1,0x67c1
  .hword 0x67d1,0x67e1,0x67f1,0x0003,0x6298,0x0008,0x62a8,0x62b7
  .hword 0x62c1,0x62d7,0x62e1,0x62f8,0x6308,0x6311,0x6321,0x6331
  .hword 0x6341,0x6351,0x0003,0x636f,0x6378,0x6388,0x6398,0x63a8
  .hword 0x63b8,0x63c1,0x63d1,0x63e1,0x63f1,0x6401,0x0003,0x641f
  .hword 0x6428,0x6438,0x6448,0x6458,0x6468,0x6471,0x6481,0x6491
  .hword 0x64a1,0x64b1,0x0003,0x64cf,0x64d8,0x64e8,0x64f8,0x6508
  .hword 0x6518,0x6521,0x6531,0x6541,0x6551,0x6561,0x0003,0x6578
  .hword 0x6587,0x6591,0x65a8,0x65b7,0x65c1,0x65d7,0x65e1,0x65f8
  .hword 0x6608,0x6611,0x6621,0x0006,0x6638,0x6648,0x6658,0x6668
  .hword 0x6678,0x6688,0x6698,0x66a1,0x66b1,0x0006,0x66c8,0x66d8
  .hword 0x66e8,0x66f8,0x6708,0x6718,0x6728,0x6731,0x6741,0x0006
  .hword 0x675f,0x6768,0x6778,0x6788,0x6798,0x67a8,0x67b1,0x67c1
  .hword 0x67d1,0x67e1,0x67f1,0x0003,0x6298,0x0008,0x62a8,0x62b7
  .hword 0x62c1,0x62d7,0x62e1,0x62f8,0x6308,0x6311,0x6321,0x6331
  .hword 0x6341,0x6351,0x0003,0x636f,0x6378,0x6388,0x6398,0x63a8
  .hword 0x63b8,0x63c1,0x63d1,0x63e1,0x63f1,0x6401,0x0003,0x641f
  .hword 0x6428,0x6438,0x6448,0x6458,0x6468,0x6471,0x6481,0x6491
  .hword 0x64a1,0x64b1,0x0003,0x64cf,0x64d8,0x64e8,0x64f8,0x6508
  .hword 0x6518,0x6521,0x6531,0x6541,0x6551,0x6561,0x0003,0x6578
  .hword 0x6807,0x6811,0x65a8,0x65b7,0x65c1,0x65d7,0x65e1,0x65f8
  .hword 0x6608,0x6611,0x6621,0x0006,0x6638,0x6648,0x6658,0x6668
  .hword 0x6678,0x6688,0x6698,0x66a1,0x66b1,0x0006,0x66c8,0x66d8
  .hword 0x66e8,0x66f8,0x6708,0x6718,0x6728,0x6731,0x6741,0x0006
  .hword 0x675f,0x6768,0x6778,0x6788,0x6798,0x67a8,0x67b1,0x67c1
  .hword 0x67d1,0x67e1,0x67f1,0x0003,0x6828,0x6838,0x6848,0x6858
  .hword 0x6868,0x6878,0x6888,0x6898,0x68a8,0x68b8,0x68c8,0x68d8
  .hword 0x68e8,0x68f8,0x6908,0x6918,0x6928,0x6938,0x6948,0x6958
  .hword 0x6968,0x6978,0x6988,0x6998,0x000f,0x69a8,0x69b8,0x69c8
  .hword 0x69d8,0x69e8,0x69f1,0x6a01,0x0006,0x6a18,0x6a28,0x6a38
  .hword 0x6a48,0x6a58,0x6a68,0x6a78,0x6a88,0x6a98,0x6aa8,0x6ab8
  .hword 0x6ac8,0x6ad8,0x6ae8,0x6af8,0x6b08,0x6b18,0x6b28,0x6b38
  .hword 0x6b48,0x6b58,0x6b68,0x6b78,0x6b88,0x000f,0x6b98,0x6ba8
  .hword 0x6bb8,0x6bc8,0x6bd8,0x6be1,0x6bf1,0x0006,0x6c08,0x6c18
  .hword 0x6c28,0x6c38,0x6868,0x6878,0x6888,0x6898,0x6c48,0x6c58
  .hword 0x6c68,0x6c78,0x68e8,0x68f8,0x6908,0x6918,0x6c88,0x6c98
  .hword 0x6ca8,0x6cb8,0x6968,0x6978,0x6988,0x6998,0x000f,0x6cc8
  .hword 0x6cd8,0x6ce8,0x6cf8,0x6d08,0x6d11,0x6d21,0x0006,0x6d38
  .hword 0x6d48,0x6d58,0x6d68,0x6a58,0x6a68,0x6a78,0x6a88,0x6d78
  .hword 0x6d88,0x6d98,0x6da8,0x6ad8,0x6ae8,0x6af8,0x6b08,0x6db8
  .hword 0x6dc8,0x6dd8,0x6de8,0x6b58,0x6b68,0x6b78,0x6b88,0x000f
  .hword 0x6df8,0x6e08,0x6e18,0x6e28,0x6e38,0x6e41,0x6e51,0x0006
  .hword 0x6c08,0x6c18,0x6e68,0x6c38,0x6868,0x6878,0x6888,0x6898
  .hword 0x6c48,0x6c58,0x6e78,0x6c78,0x68e8,0x68f8,0x6908,0x6918
  .hword 0x6c88,0x6c98,0x6e88,0x6cb8,0x6968,0x6978,0x6988,0x6998
  .hword 0x000f,0x6e98,0x6ea8,0x6eb8,0x6ec8,0x6ed8,0x6ee1,0x6ef1
  .hword 0x0006,0x6d38,0x6d48,0x6f08,0x6d68,0x6a58,0x6a68,0x6a78
  .hword 0x6a88,0x6d78,0x6d88,0x6f18,0x6da8,0x6ad8,0x6ae8,0x6af8
  .hword 0x6b08,0x6db8,0x6dc8,0x6f28,0x6de8,0x6b58,0x6b68,0x6b78
  .hword 0x6b88,0x000f,0x6f38,0x6f48,0x6f58,0x6f68,0x6f78,0x6f81
  .hword 0x6f91,0x0006,0x6c08,0x6c18,0x6e68,0x6c38,0x6868,0x6878
  .hword 0x6888,0x6898,0x6c48,0x6c58,0x6e78,0x6c78,0x68e8,0x68f8
  .hword 0x6908,0x6918,0x6c88,0x6c98,0x6e88,0x6cb8,0x6968,0x6978
  .hword 0x6988,0x6998,0x000f,0x6fa8,0x6fb8,0x6fc8,0x6fd8,0x6fe8
  .hword 0x6ff1,0x7001,0x0006,0x6d38,0x6d48,0x6f08,0x6d68,0x6a58
  .hword 0x6a68,0x6a78,0x6a88,0x6d78,0x6d88,0x6f18,0x6da8,0x6ad8
  .hword 0x6ae8,0x6af8,0x6b08,0x6db8,0x6dc8,0x6f28,0x6de8,0x6b58
  .hword 0x6b68,0x6b78,0x6b88,0x000f,0x7018,0x7028,0x7038,0x7048
  .hword 0x7058,0x7061,0x7071,0x0006,0x6c08,0x6c18,0x6e68,0x6c38
  .hword 0x6868,0x6878,0x6888,0x6898,0x6c48,0x6c58,0x6e78,0x6c78
  .hword 0x68e8,0x68f8,0x6908,0x6918,0x6c88,0x6c98,0x6e88,0x6cb8
  .hword 0x6968,0x6978,0x6988,0x6998,0x0000,0x0040,0x6d38,0x6d48
  .hword 0x6f08,0x6d68,0x6a58,0x6a68,0x6a78,0x6a88,0x6d78,0x6d88
  .hword 0x6f18,0x6da8,0x6ad8,0x6ae8,0x6af8,0x6b08,0x6db8,0x6dc8
  .hword 0x6f28,0x6de8,0x6b58,0x6b68,0x6b78,0x6b88,0x0000,0x0040
  .hword 0x6c08,0x6c18,0x6e68,0x6c38,0x6868,0x6878,0x6888,0x6898
  .hword 0x6c48,0x6c58,0x6e78,0x6c78,0x68e8,0x68f8,0x6908,0x6918
  .hword 0x6c88,0x6c98,0x6e88,0x6cb8,0x6968,0x6978,0x6988,0x6998
  .hword 0x0000,0x0040,0x6d38,0x6d48,0x6f08,0x6d68,0x6a58,0x6a68
  .hword 0x6a78,0x6a88,0x6d78,0x6d88,0x6f18,0x6da8,0x6ad8,0x6ae8
  .hword 0x6af8,0x6b08,0x6db8,0x6dc8,0x6f28,0x6de8,0x6b58,0x6b68
  .hword 0x6b78,0x6b88,0x0000,0x0040,0x6c08,0x6c18,0x6e68,0x6c38
  .hword 0x6868,0x6878,0x6888,0x6898,0x6c48,0x6c58,0x6e78,0x6c78
  .hword 0x68e8,0x68f8,0x6908,0x6918,0x6c88,0x6c98,0x6e88,0x6cb8
  .hword 0x6968,0x6978,0x6988,0x6998,0x0000,0x0040,0x6d38,0x6d48
  .hword 0x6f08,0x6d68,0x6a58,0x6a68,0x6a78,0x6a88,0x6d78,0x6d88
  .hword 0x6f18,0x6da8,0x6ad8,0x6ae8,0x6af8,0x6b08,0x6db8,0x6dc8
  .hword 0x6f28,0x6de8,0x6b58,0x6b68,0x6b78,0x6b88,0x0000,0x0040
  .hword 0x6c08,0x6c18,0x6e68,0x6c38,0x6868,0x6878,0x6888,0x6898
  .hword 0x6c48,0x6c58,0x6e78,0x6c78,0x68e8,0x68f8,0x6908,0x6918
  .hword 0x6c88,0x6c98,0x6e88,0x6cb8,0x6968,0x6978,0x6988,0x6998
  .hword 0x0000,0x0040,0x6d38,0x6d48,0x6f08,0x6d68,0x6a58,0x6a68
  .hword 0x6a78,0x6a88,0x6d78,0x6d88,0x6f18,0x6da8,0x6ad8,0x6ae8
  .hword 0x6af8,0x6b08,0x6db8,0x6dc8,0x6f28,0x6de8,0x6b58,0x6b68
  .hword 0x6b78,0x6b88,0x0000,0x0040,0x0000,0x0000,0x0000,0x0000
  .rept 0xf2
  .long 0,0,0,0,0,0,0,0
  .endr



;@ vim:filetype=armasm
